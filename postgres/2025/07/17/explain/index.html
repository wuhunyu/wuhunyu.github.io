<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>postgres using explain - wuhunyu|blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="wuhunyu"><meta name="msapplication-TileImage" content="https://static.wuhunyu.top/images/avatar-compress.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="wuhunyu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="https://static.wuhunyu.top/images/avatar-compress.png"><link rel="apple-touch-icon" sizes="96x96" href="https://static.wuhunyu.top/images/avatar-compress.png"><link rel="apple-touch-icon" sizes="128x128" href="https://static.wuhunyu.top/images/avatar-compress.png"><link rel="apple-touch-icon" sizes="256x256" href="https://static.wuhunyu.top/images/avatar-compress.png"><meta name="description" content="你好，很高兴遇见你，我是 wuhunyu，一名 Java 开发。这是我的个人博客，我将会在这里分享自己的学习笔记"><meta property="og:type" content="blog"><meta property="og:title" content="postgres using explain"><meta property="og:url" content="https://wuhunyu.top/postgres/2025/07/17/explain/index.html"><meta property="og:site_name" content="wuhunyu"><meta property="og:description" content="你好，很高兴遇见你，我是 wuhunyu，一名 Java 开发。这是我的个人博客，我将会在这里分享自己的学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://static.wuhunyu.top/images/avatar-compress.png"><meta property="article:published_time" content="2025-07-17T09:47:00.000Z"><meta property="article:modified_time" content="2025-12-01T09:39:03.400Z"><meta property="article:author" content="wuhunyu"><meta property="article:tag" content="explain"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://static.wuhunyu.top/images/avatar-compress.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wuhunyu.top"},"headline":"有志者，事竟成","image":["https://static.wuhunyu.top/images/avatar-compress.png"],"datePublished":"2025-07-17T09:47:00.000Z","dateModified":"2025-12-01T09:39:03.400Z","author":{"@type":"Person","name":"wuhunyu"},"publisher":{"@type":"Organization","name":"wuhunyu|blog","logo":{"@type":"ImageObject","url":{"text":"wuhunyu"}}},"description":"你好，很高兴遇见你，我是 wuhunyu，一名 Java 开发。这是我的个人博客，我将会在这里分享自己的学习笔记"}</script><link rel="canonical" href="https://wuhunyu.top/postgres/2025/07/17/explain/index.html"><link rel="icon" href="https://static.wuhunyu.top/images/avatar-compress.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/customer.css"><link rel="stylesheet" href="/font/iconfont.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">wuhunyu</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/wuhunyu"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-10-tablet is-10-desktop is-10-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://static.wuhunyu.top/images/2025/07/4c269488a4246adb954b128b38ba2c27.jpg" alt="postgres using explain"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-07-17T09:47:00.000Z" title="7/17/2025, 9:47:00 AM">2025-07-17</time>发表</span><span class="level-item"><time dateTime="2025-12-01T09:39:03.400Z" title="12/1/2025, 9:39:03 AM">2025-12-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/postgres/">postgres</a></span><span class="level-item">1 小时读完 (大约8347个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">postgres using explain</h1><div class="content"><p><strong>14.1. 使用 EXPLAIN</strong></p>
<p>PostgreSQL 会为其接收的每个查询设计一个查询计划。选择正确的计划以匹配查询结构和数据属性对于获得良好性能至关重要，因此系统包含一个复杂的规划器，该规划器尝试选择好的计划。您可以使用 <code>EXPLAIN</code> 命令查看规划器为任何查询创建的查询计划。计划解读是一门艺术，需要一定的经验才能掌握，但本节旨在涵盖其基础知识。</p>
<p>本节中的示例取自执行 <code>VACUUM ANALYZE</code> 后的回归测试数据库，并使用了 v17 开发版本。如果您自己尝试这些示例，应该能获得类似的结果，但您的估计成本和行数可能会略有不同，因为 <code>ANALYZE</code> 的统计数据是随机抽样而非精确的，并且成本本身在某种程度上依赖于平台。</p>
<p>这些示例使用 <code>EXPLAIN</code> 默认的“文本”输出格式，该格式紧凑且方便人类阅读。如果您想将 <code>EXPLAIN</code> 的输出提供给程序进行进一步分析，则应改用其机器可读的输出格式之一（XML、JSON 或 YAML）。</p>
<span id="more"></span>

<p><strong>14.1.1. EXPLAIN 基础知识</strong></p>
<p>查询计划的结构是计划节点的树形结构。树的最底层节点是扫描节点：它们从表中返回原始行。针对不同的表访问方法，有不同类型的扫描节点：顺序扫描、索引扫描和位图索引扫描。此外，还有非表行源，例如 <code>VALUES</code> 子句和 <code>FROM</code> 子句中的集合返回函数，它们拥有自己的扫描节点类型。如果查询需要对原始行进行连接、聚合、排序或其他操作，那么扫描节点上方将有额外的节点来执行这些操作。同样，执行这些操作通常有不止一种可能的方法，因此这里也可以出现不同类型的节点。<code>EXPLAIN</code> 的输出为计划树中的每个节点提供一行，显示基本的节点类型以及规划器对该计划节点执行的成本估计。可能会出现额外的行，从节点的摘要行缩进，以显示节点的附加属性。第一行（最顶层节点的摘要行）是计划的估计总执行成本；规划器致力于将这个数字最小化。</p>
<p>这是一个简单的例子，只为展示输出的样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tenk1;</span><br><span class="line"></span><br><span class="line">                         QUERY PLAN</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"> Seq Scan on tenk1  (cost=0.00..445.00 rows=10000 width=244)</span><br></pre></td></tr></table></figure>

<p>由于此查询没有 <code>WHERE</code> 子句，它必须扫描表的所有行，因此规划器选择了使用简单的顺序扫描计划。括号中引用的数字（从左到右）是：</p>
<ul>
<li><strong>估计启动成本（Estimated start-up cost）</strong>。这是输出阶段开始前所花费的时间，例如，在排序节点中执行排序所需的时间。</li>
<li><strong>估计总成本（Estimated total cost）</strong>。这是基于计划节点运行完成的假设得出的，即所有可用行都已检索。实际上，节点的父节点可能在读取所有可用行之前停止（请参阅下面的 <code>LIMIT</code> 示例）。</li>
<li><strong>此计划节点输出的估计行数（Estimated number of rows output by this plan node）</strong>。同样，假定该节点已运行完成。</li>
<li><strong>此计划节点输出的行的估计平均宽度（以字节为单位）（Estimated average width of rows output by this plan node (in bytes)）</strong>。</li>
</ul>
<p>成本以规划器的成本参数（参见 <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/runtime-config-query.html#RUNTIME-CONFIG-QUERY-COSTS">Section 19.7.2</a>）确定的任意单位衡量。传统做法是以磁盘页面获取为单位衡量成本；也就是说，<code>seq_page_cost</code> 通常设置为 1.0，其他成本参数相对于它进行设置。本节中的示例使用默认的成本参数运行。</p>
<p>理解上层节点的成本包含其所有子节点的成本是很重要的。同样重要的是要认识到，成本只反映规划器关心的事情。特别是，成本不考虑将输出值转换为文本形式或将其传输到客户端所花费的时间，这在实际经过的时间中可能是重要因素；但规划器忽略这些成本，因为它无法通过更改计划来改变它们。（我们相信，每个正确的计划都将输出相同的行集。）</p>
<p><code>rows</code> 值有点棘手，因为它不是计划节点处理或扫描的行数，而是节点发出的行数。由于在节点处应用了任何 <code>WHERE</code> 子句条件进行过滤，这通常少于扫描的行数。理想情况下，顶层 <code>rows</code> 估计将近似于查询实际返回、更新或删除的行数。</p>
<p>回到我们的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1;</span><br><span class="line"></span><br><span class="line">                         QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.445</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br></pre></td></tr></table></figure>

<p>这些数字的推导非常直接。如果您执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> relpages, reltuples <span class="keyword">FROM</span> pg_class <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;tenk1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>您会发现 <code>tenk1</code> 有 345 个磁盘页面和 10000 行。估计成本计算为 (读取的磁盘页面 * <code>seq_page_cost</code>) + (扫描的行数 * <code>cpu_tuple_cost</code>)。默认情况下，<code>seq_page_cost</code> 是 1.0，<code>cpu_tuple_cost</code> 是 0.01，所以估计成本是 (345 * 1.0) + (10000 * 0.01) &#x3D; 445。</p>
<p>现在让我们修改查询以添加一个 <code>WHERE</code> 条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">7000</span>;</span><br><span class="line"></span><br><span class="line">                         QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.470</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">7000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (unique1 <span class="operator">&lt;</span> <span class="number">7000</span>)</span><br></pre></td></tr></table></figure>

<p>请注意，<code>EXPLAIN</code> 输出显示 <code>WHERE</code> 子句作为附加到 <code>Seq Scan</code> 计划节点的“过滤器”条件。这意味着计划节点检查它扫描的每一行的条件，并只输出通过条件的行。由于 <code>WHERE</code> 子句，输出行数的估计已减少。但是，扫描仍然需要访问所有 10000 行，因此成本没有降低；事实上，它略有上升（准确地说是增加了 <code>10000 * cpu_operator_cost</code>）以反映检查 <code>WHERE</code> 条件所花费的额外 CPU 时间。</p>
<p>这个查询实际选择的行数是 7000，但行数估计只是近似值。如果您尝试重复此实验，您很可能会得到一个略有不同的估计；此外，它可以在每个 <code>ANALYZE</code> 命令之后改变，因为 <code>ANALYZE</code> 生成的统计数据是从表的随机样本中获取的。</p>
<p>现在，让我们使条件更具限制性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                                  QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">         Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这里规划器决定使用两步计划：子计划节点访问索引以查找匹配索引条件的行位置，然后上层计划节点实际上从表本身获取这些行。单独获取行的成本比顺序读取它们昂贵得多，但由于不必访问表的所有页面，这仍然比顺序扫描便宜。（使用两个计划级别的原因是上层计划节点在读取它们之前，将索引识别的行位置按物理顺序排序，以最小化单独获取的成本。“位图”在节点名称中提到的机制是执行排序的机制。）</p>
<p>现在，让我们在 <code>WHERE</code> 子句中添加另一个条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> stringu1 <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                                  QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">5.04</span>.<span class="number">.225</span><span class="number">.20</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (stringu1 <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>::name)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">         Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>添加的条件 <code>stringu1 = &#39;xxx&#39;</code> 减少了输出行数估计，但没有减少成本，因为我们仍然需要访问相同的行集。这是因为 <code>stringu1</code> 子句不能作为索引条件应用，因为此索引只在 <code>unique1</code> 列上。相反，它被作为过滤器应用于使用索引检索的行。因此，成本实际上略有上升，以反映这种额外的检查。</p>
<p>在某些情况下，规划器会选择“简单”索引扫描计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">                                 QUERY PLAN</span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> tenk1_unique1 <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.8</span><span class="number">.30</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   Index Cond: (unique1 <span class="operator">=</span> <span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<p>在这种类型的计划中，表行按索引顺序获取，这使得读取它们更加昂贵，但由于行数很少，排序行位置的额外成本不值得。对于只获取单行的查询，您最常会看到这种计划类型。它也常用于具有匹配索引顺序的 <code>ORDER BY</code> 条件的查询，因为这样就不需要额外的排序步骤来满足 <code>ORDER BY</code>。在此示例中，添加 <code>ORDER BY unique1</code> 将使用相同的计划，因为索引已经隐式提供了请求的排序。</p>
<p>规划器可以通过多种方式实现 <code>ORDER BY</code> 子句。上面的示例显示这种排序子句可以隐式实现。规划器也可能添加一个显式的 <code>Sort</code> 步骤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> unique1;</span><br><span class="line"></span><br><span class="line">                            QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------</span></span><br><span class="line"> Sort  (cost<span class="operator">=</span><span class="number">1109.39</span>.<span class="number">.1134</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   Sort Key: unique1</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.445</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br></pre></td></tr></table></figure>

<p>如果计划的一部分保证了所需排序键前缀上的排序，那么规划器可能会决定改用增量排序步骤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> hundred, ten LIMIT <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                                              QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost<span class="operator">=</span><span class="number">19.35</span>.<span class="number">.39</span><span class="number">.49</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Incremental Sort  (cost<span class="operator">=</span><span class="number">19.35</span>.<span class="number">.2033</span><span class="number">.39</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         Sort Key: hundred, ten</span><br><span class="line">         Presorted Key: hundred</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk1_hundred <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.1574</span><span class="number">.20</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br></pre></td></tr></table></figure>

<p>与常规排序相比，增量排序允许在整个结果集排序完成之前返回元组，这尤其有利于 <code>LIMIT</code> 查询的优化。它还可以减少内存使用和将排序溢出到磁盘的可能性，但这需要以增加将结果集分成多个排序批次的开销为代价。</p>
<p>如果在 <code>WHERE</code> 子句中引用的多个列上有单独的索引，规划器可能会选择使用索引的 <code>AND</code> 或 <code>OR</code> 组合：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> unique2 <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">                                     QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">25.07</span>.<span class="number">.60</span><span class="number">.11</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   Recheck Cond: ((unique1 <span class="operator">&lt;</span> <span class="number">100</span>) <span class="keyword">AND</span> (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>))</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  BitmapAnd  (cost<span class="operator">=</span><span class="number">25.07</span>.<span class="number">.25</span><span class="number">.07</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.78</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">999</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">               Index Cond: (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>)</span><br></pre></td></tr></table></figure>

<p>但这需要访问两个索引，因此与仅使用一个索引并将另一个条件作为过滤器处理相比，不一定有优势。如果您更改涉及的范围，您会看到计划相应地更改。</p>
<p>这是一个显示 <code>LIMIT</code> 效果的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> unique2 <span class="operator">&gt;</span> <span class="number">9000</span> LIMIT <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                                     QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.14</span><span class="number">.28</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk1_unique2 <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.70</span><span class="number">.27</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         Index Cond: (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这与上面的查询相同，但我们添加了 <code>LIMIT</code>，这样就不需要检索所有行，规划器也改变了它的做法。请注意，<code>Index Scan</code> 节点的总成本和行数显示为如果它运行完成。但是，<code>Limit</code> 节点预计在检索到五分之一的行后停止，因此其总成本仅为五分之一，这就是查询的实际估计成本。此计划优于向先前计划添加 <code>Limit</code> 节点，因为 <code>Limit</code> 无法避免支付位图扫描的启动成本，因此该方法总成本将超过 25 个单位。</p>
<p>让我们尝试连接两个表，使用我们一直在讨论的列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, tenk2 t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2;</span><br><span class="line"></span><br><span class="line">                                      QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------</span></span><br><span class="line"> Nested Loop  (cost<span class="operator">=</span><span class="number">4.65</span>.<span class="number">.118</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">488</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">4.36</span>.<span class="number">.39</span><span class="number">.38</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.36</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk2_unique2 <span class="keyword">on</span> tenk2 t2  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.7</span><span class="number">.90</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         Index Cond: (unique2 <span class="operator">=</span> t1.unique2)</span><br></pre></td></tr></table></figure>

<p>在此计划中，我们有一个嵌套循环连接节点，其输入或子节点是两个表扫描。节点摘要行的缩进反映了计划树结构。连接的第一个或“外部”子节点是位图扫描，类似于我们之前看到的那些。它的成本和行数与我们从 <code>SELECT ... WHERE unique1 &lt; 10</code> 获得的结果相同，因为我们在该节点应用 <code>WHERE</code> 子句 <code>unique1 &lt; 10</code>。<code>t1.unique2 = t2.unique2</code> 子句尚未相关，因此它不影响外部扫描的行数。嵌套循环连接节点将为其从外部子节点获得的每一行运行其第二个或“内部”子节点一次。当前外部行中的列值可以插入到内部扫描中；在这里，外部行中的 <code>t1.unique2</code> 值可用，因此我们得到了一个计划和成本，类似于我们上面为简单 <code>SELECT ... WHERE t2.unique2 = constant</code> 情况所看到的。（估计成本实际上比上面看到的略低，这是由于在 <code>t2</code> 上重复索引扫描期间预期的缓存所致。）然后根据外部扫描的成本，加上每个外部行内部扫描的一次重复（这里是 <code>10 * 7.90</code>），再加上一点用于连接处理的 CPU 时间来设置循环节点的成本。</p>
<p>在本例中，连接的输出行数与两次扫描的行数乘积相同，但这并非在所有情况下都如此，因为可能存在提及两个表的额外 <code>WHERE</code> 子句，因此只能在连接点而不是任何输入扫描处应用。下面是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, tenk2 t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">AND</span> t2.unique2 <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">AND</span> t1.hundred <span class="operator">&lt;</span> t2.hundred;</span><br><span class="line"></span><br><span class="line">                                         QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------</span></span><br><span class="line"> Nested Loop  (cost<span class="operator">=</span><span class="number">4.65</span>.<span class="number">.49</span><span class="number">.36</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">33</span> width<span class="operator">=</span><span class="number">488</span>)</span><br><span class="line">   <span class="keyword">Join</span> <span class="keyword">Filter</span>: (t1.hundred <span class="operator">&lt;</span> t2.hundred)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">4.36</span>.<span class="number">.39</span><span class="number">.38</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.36</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Materialize  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.8</span><span class="number">.51</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk2_unique2 <span class="keyword">on</span> tenk2 t2  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.8</span><span class="number">.46</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">               Index Cond: (unique2 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>条件 <code>t1.hundred &lt; t2.hundred</code> 无法在 <code>tenk2_unique2</code> 索引中测试，因此它在连接节点应用。这减少了连接节点的估计输出行数，但没有改变任何输入扫描。</p>
<p>请注意，这里规划器选择通过在连接上放置一个 <code>Materialize</code> 计划节点来“具体化”连接的内部关系。这意味着 <code>t2</code> 索引扫描只会执行一次，即使嵌套循环连接节点需要读取该数据十次，即对于外部关系的每一行一次。<code>Materialize</code> 节点在读取数据时将其保存在内存中，然后在每次后续通过时从内存中返回数据。</p>
<p>在处理外连接时，您可能会看到附加了“Join Filter”和纯“Filter”条件的连接计划节点。Join Filter 条件来自外连接的 <code>ON</code> 子句，因此未能通过 Join Filter 条件的行仍然可以作为空扩展行发出。但纯 Filter 条件在外连接规则之后应用，因此可以无条件地删除行。在内连接中，这些过滤器类型之间没有语义差异。</p>
<p>如果我们稍微改变查询的选择性，我们可能会得到一个非常不同的连接计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, tenk2 t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2;</span><br><span class="line"></span><br><span class="line">                                        QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------</span></span><br><span class="line"> Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">226.23</span>.<span class="number">.709</span><span class="number">.73</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">488</span>)</span><br><span class="line">   Hash Cond: (t2.unique2 <span class="operator">=</span> t1.unique2)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> tenk2 t2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.445</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">224.98</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">               Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">               <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">                     Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这里，规划器选择使用哈希连接，其中一个表的行被输入到内存中的哈希表，然后扫描另一个表，并探测哈希表以查找与每行的匹配项。再次注意缩进如何反映计划结构：<code>tenk1</code> 上的位图扫描是 <code>Hash</code> 节点的输入，该节点构造哈希表。然后将其返回到 <code>Hash Join</code> 节点，该节点从其外部子计划读取行并为每行搜索哈希表。</p>
<p>另一种可能的连接类型是合并连接，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, onek t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2;</span><br><span class="line"></span><br><span class="line">                                        QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------</span></span><br><span class="line"> <span class="keyword">Merge</span> <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">0.56</span>.<span class="number">.233</span><span class="number">.49</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">488</span>)</span><br><span class="line">   <span class="keyword">Merge</span> Cond: (t1.unique2 <span class="operator">=</span> t2.unique2)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk1_unique2 <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.643</span><span class="number">.28</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> onek_unique2 <span class="keyword">on</span> onek t2  (cost<span class="operator">=</span><span class="number">0.28</span>.<span class="number">.166</span><span class="number">.28</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br></pre></td></tr></table></figure>

<p>合并连接要求其输入数据按连接键排序。在本例中，每个输入都通过使用索引扫描按正确顺序访问行进行排序；但也可以使用顺序扫描和排序。（由于索引扫描所需的非顺序磁盘访问，顺序扫描和排序通常在排序多行时优于索引扫描。）</p>
<p>一种查看变体计划的方法是强制规划器不考虑它认为最便宜的策略，使用 <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/runtime-config-query.html#GUC-ENABLE-BITMAPSCAN">Section 19.7.1</a> 中描述的启用&#x2F;禁用标志。（这是一个粗糙但有用的工具。另请参阅 <a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/planner-optimizer.html">Section 14.3</a>）。例如，如果我们不相信合并连接是上一个示例的最佳连接类型，我们可以尝试</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> enable_mergejoin <span class="operator">=</span> off;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, onek t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2;</span><br><span class="line"></span><br><span class="line">                                        QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------</span></span><br><span class="line"> Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">226.23</span>.<span class="number">.344</span><span class="number">.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">488</span>)</span><br><span class="line">   Hash Cond: (t2.unique2 <span class="operator">=</span> t1.unique2)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> onek t2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.114</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">224.98</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">               Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">               <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">                     Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这表明规划器认为在这种情况下哈希连接会比合并连接贵近 50%。当然，下一个问题是它是否正确。我们可以使用 <code>EXPLAIN ANALYZE</code> 来调查这一点，如下所述。</p>
<p>有些查询计划涉及子计划，它们源自原始查询中的子 SELECT。此类查询有时可以转换为普通的连接计划，但当它们无法转换时，我们会得到如下计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN VERBOSE <span class="keyword">SELECT</span> unique1</span><br><span class="line"><span class="keyword">FROM</span> tenk1 t</span><br><span class="line"><span class="keyword">WHERE</span> t.ten <span class="operator">&lt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> o.ten <span class="keyword">FROM</span> onek o <span class="keyword">WHERE</span> o.four <span class="operator">=</span> t.four);</span><br><span class="line"></span><br><span class="line">                               QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> public.tenk1 t  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.586095</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">5000</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">   Output: t.unique1</span><br><span class="line">   <span class="keyword">Filter</span>: (<span class="keyword">ALL</span> (t.ten <span class="operator">&lt;</span> (SubPlan <span class="number">1</span>).col1))</span><br><span class="line">   SubPlan <span class="number">1</span></span><br><span class="line">     <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> public.onek o  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.116</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">250</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">           Output: o.ten</span><br><span class="line">           <span class="keyword">Filter</span>: (o.four <span class="operator">=</span> t.four)</span><br></pre></td></tr></table></figure>

<p>这个相当人为的例子说明了几点：外部计划级别的值可以向下传递到子计划（这里，<code>t.four</code> 被向下传递），并且子选择的结果可用于外部计划。<code>EXPLAIN</code> 用 <code>(subplan_name).colN</code> 这样的表示法显示这些结果值，它指的是子 SELECT 的第 N 个输出列。</p>
<p>在上面的示例中，<code>ALL</code> 运算符为外部查询的每一行再次运行子计划（这解释了其高估计成本）。一些查询可以使用哈希子计划来避免这种情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t</span><br><span class="line"><span class="keyword">WHERE</span> t.unique1 <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> o.unique1 <span class="keyword">FROM</span> onek o);</span><br><span class="line"></span><br><span class="line">                                         QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> tenk1 t  (cost<span class="operator">=</span><span class="number">61.77</span>.<span class="number">.531</span><span class="number">.77</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">5000</span> width<span class="operator">=</span><span class="number">244</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (<span class="keyword">NOT</span> (<span class="keyword">ANY</span> (unique1 <span class="operator">=</span> (hashed SubPlan <span class="number">1</span>).col1)))</span><br><span class="line">   SubPlan <span class="number">1</span></span><br><span class="line">     <span class="operator">-</span><span class="operator">&gt;</span>  Index <span class="keyword">Only</span> Scan <span class="keyword">using</span> onek_unique1 <span class="keyword">on</span> onek o  (cost<span class="operator">=</span><span class="number">0.28</span>.<span class="number">.59</span><span class="number">.27</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1000</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，子计划只运行一次，其输出被加载到内存中的哈希表，然后由外部 <code>ANY</code> 运算符进行探测。这要求子 SELECT 不引用外部查询的任何变量，并且 <code>ANY</code> 的比较运算符适合哈希。</p>
<p>如果除了不引用外部查询的任何变量之外，子 SELECT 不能返回多于一行，那么它可能被实现为 <code>initplan</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN VERBOSE <span class="keyword">SELECT</span> unique1</span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1 <span class="keyword">WHERE</span> t1.ten <span class="operator">=</span> (<span class="keyword">SELECT</span> (random() <span class="operator">*</span> <span class="number">10</span>)::<span class="type">integer</span>);</span><br><span class="line"></span><br><span class="line">                             QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> public.tenk1 t1  (cost<span class="operator">=</span><span class="number">0.02</span>.<span class="number">.470</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1000</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">   Output: t1.unique1</span><br><span class="line">   <span class="keyword">Filter</span>: (t1.ten <span class="operator">=</span> (InitPlan <span class="number">1</span>).col1)</span><br><span class="line">   InitPlan <span class="number">1</span></span><br><span class="line">     <span class="operator">-</span><span class="operator">&gt;</span>  <span class="keyword">Result</span>  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.0</span><span class="number">.02</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">4</span>)</span><br><span class="line">           Output: ((random() <span class="operator">*</span> <span class="string">&#x27;10&#x27;</span>::<span class="type">double precision</span>))::<span class="type">integer</span></span><br></pre></td></tr></table></figure>

<p><code>initplan</code> 在外部计划的每次执行中只运行一次，其结果被保存以供外部计划的后续行重复使用。因此，在这个例子中，<code>random()</code> 只评估一次，并且 <code>t1.ten</code> 的所有值都与相同的随机选择的整数进行比较。这与没有子 SELECT 构造时发生的情况大不相同。</p>
<p><strong>14.1.2. EXPLAIN ANALYZE</strong></p>
<p>可以使用 <code>EXPLAIN</code> 的 <code>ANALYZE</code> 选项检查规划器估计的准确性。使用此选项，<code>EXPLAIN</code> 实际上会执行查询，然后显示在每个计划节点中累积的真实行数和真实运行时间，以及普通 <code>EXPLAIN</code> 显示的相同估计值。例如，我们可能会得到这样的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, tenk2 t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">10</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2;</span><br><span class="line"></span><br><span class="line">                                                           QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Nested Loop  (cost<span class="operator">=</span><span class="number">4.65</span>.<span class="number">.118</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">488</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.017</span>.<span class="number">.0</span><span class="number">.051</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">4.36</span>.<span class="number">.39</span><span class="number">.38</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.009</span>.<span class="number">.0</span><span class="number">.017</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">         Heap Blocks: exact<span class="operator">=</span><span class="number">10</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.4</span><span class="number">.36</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.004</span>.<span class="number">.0</span><span class="number">.004</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">10</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk2_unique2 <span class="keyword">on</span> tenk2 t2  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.7</span><span class="number">.90</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.003</span>.<span class="number">.0</span><span class="number">.003</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> loops<span class="operator">=</span><span class="number">10</span>)</span><br><span class="line">         Index Cond: (unique2 <span class="operator">=</span> t1.unique2)</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.485</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.073</span> ms</span><br></pre></td></tr></table></figure>

<p>请注意，“actual time”值以毫秒为单位（实时时间），而成本估计以任意单位表示；因此它们不太可能匹配。通常最重要的是查看估计的行数是否与实际情况合理接近。在这个例子中，估计值都非常准确，但实际上这很不常见。</p>
<p>在某些查询计划中，子计划节点可能会多次执行。例如，在上述嵌套循环计划中，内部索引扫描将每外部行执行一次。在这种情况下，<code>loops</code> 值报告节点的总执行次数，显示的实际时间和行值是每次执行的平均值。这样做是为了使数字与成本估计的显示方式保持可比性。乘以 <code>loops</code> 值以获得节点中实际花费的总时间。在上面的例子中，我们在 <code>tenk2</code> 上执行索引扫描总共花费了 0.030 毫秒。</p>
<p>在某些情况下，<code>EXPLAIN ANALYZE</code> 除了计划节点执行时间和行数外，还会显示额外的执行统计信息。例如，<code>Sort</code> 和 <code>Hash</code> 节点提供了额外的信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> tenk1 t1, tenk2 t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> t1.unique2 <span class="operator">=</span> t2.unique2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.fivethous;</span><br><span class="line"></span><br><span class="line">                                                                 QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Sort  (cost<span class="operator">=</span><span class="number">713.05</span>.<span class="number">.713</span><span class="number">.30</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">488</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">2.995</span>.<span class="number">.3</span><span class="number">.002</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Sort Key: t1.fivethous</span><br><span class="line">   Sort <span class="keyword">Method</span>: quicksort  Memory: <span class="number">74</span>kB</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Hash <span class="keyword">Join</span>  (cost<span class="operator">=</span><span class="number">226.23</span>.<span class="number">.709</span><span class="number">.73</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">488</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.515</span>.<span class="number">.2</span><span class="number">.920</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Hash Cond: (t2.unique2 <span class="operator">=</span> t1.unique2)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> tenk2 t2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.445</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.026</span>.<span class="number">.1</span><span class="number">.790</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10000</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Hash  (cost<span class="operator">=</span><span class="number">224.98</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.476</span>.<span class="number">.0</span><span class="number">.477</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Buckets: <span class="number">1024</span>  Batches: <span class="number">1</span>  Memory Usage: <span class="number">35</span>kB</span><br><span class="line">               <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1 t1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.224</span><span class="number">.98</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.030</span>.<span class="number">.0</span><span class="number">.450</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">                     Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">                     Heap Blocks: exact<span class="operator">=</span><span class="number">90</span></span><br><span class="line">                     <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.013</span>.<span class="number">.0</span><span class="number">.013</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">                           Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.187</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">3.036</span> ms</span><br></pre></td></tr></table></figure>

<p><code>Sort</code> 节点显示使用的排序方法（特别是排序是在内存中还是在磁盘上）以及所需的内存或磁盘空间量。<code>Hash</code> 节点显示哈希桶和批次的数量以及哈希表使用的峰值内存量。（如果批次数量超过一个，还将涉及磁盘空间使用，但未显示。）</p>
<p>另一种额外信息类型是被过滤条件删除的行数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> ten <span class="operator">&lt;</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">                                               QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.470</span><span class="number">.00</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">7000</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.030</span>.<span class="number">.1</span><span class="number">.995</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">7000</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (ten <span class="operator">&lt;</span> <span class="number">7</span>)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">3000</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.102</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">2.145</span> ms</span><br></pre></td></tr></table></figure>

<p>这些计数对于在连接节点应用的过滤器条件特别有价值。“Rows Removed”行仅在至少有一行被扫描（或者在连接节点的情况下，潜在的连接对）被过滤器条件拒绝时才出现。</p>
<p>与过滤条件类似的情况发生在“有损”索引扫描中。例如，考虑以下搜索包含特定点的多边形：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> polygon_tbl <span class="keyword">WHERE</span> f1 @<span class="operator">&gt;</span> polygon <span class="string">&#x27;(0.5,2.0)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                                              QUERY PLAN</span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Seq Scan <span class="keyword">on</span> polygon_tbl  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.09</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">85</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.023</span>.<span class="number">.0</span><span class="number">.023</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="keyword">Filter</span>: (f1 @<span class="operator">&gt;</span> <span class="string">&#x27;((0.5,2))&#x27;</span>::polygon)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">7</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.039</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.033</span> ms</span><br></pre></td></tr></table></figure>

<p>规划器认为（非常正确地）这个样本表太小，不值得使用索引扫描，所以我们有一个普通的顺序扫描，其中所有行都被过滤条件拒绝。但如果我们强制使用索引扫描，我们会看到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> enable_seqscan <span class="keyword">TO</span> off;</span><br><span class="line"></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> polygon_tbl <span class="keyword">WHERE</span> f1 @<span class="operator">&gt;</span> polygon <span class="string">&#x27;(0.5,2.0)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                                                        QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Index Scan <span class="keyword">using</span> gpolygonind <span class="keyword">on</span> polygon_tbl  (cost<span class="operator">=</span><span class="number">0.13</span>.<span class="number">.8</span><span class="number">.15</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">85</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.074</span>.<span class="number">.0</span><span class="number">.074</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Index Cond: (f1 @<span class="operator">&gt;</span> <span class="string">&#x27;((0.5,2))&#x27;</span>::polygon)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Index Recheck: <span class="number">1</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.039</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.098</span> ms</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到索引返回了一个候选行，然后该行被索引条件的重新检查拒绝了。发生这种情况是因为 GiST 索引对于多边形包含测试是“有损的”：它实际上返回与目标重叠的多边形的行，然后我们必须对这些行进行精确的包含测试。</p>
<p><code>EXPLAIN</code> 有一个 <code>BUFFERS</code> 选项，可以与 <code>ANALYZE</code> 结合使用以获取更多运行时统计信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN (ANALYZE, BUFFERS) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> unique2 <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">                                                           QUERY PLAN</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">25.07</span>.<span class="number">.60</span><span class="number">.11</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.105</span>.<span class="number">.0</span><span class="number">.114</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   Recheck Cond: ((unique1 <span class="operator">&lt;</span> <span class="number">100</span>) <span class="keyword">AND</span> (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>))</span><br><span class="line">   Heap Blocks: exact<span class="operator">=</span><span class="number">10</span></span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">14</span> read<span class="operator">=</span><span class="number">3</span></span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  BitmapAnd  (cost<span class="operator">=</span><span class="number">25.07</span>.<span class="number">.25</span><span class="number">.07</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.100</span>.<span class="number">.0</span><span class="number">.101</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Buffers: shared hit<span class="operator">=</span><span class="number">4</span> read<span class="operator">=</span><span class="number">3</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.027</span>.<span class="number">.0</span><span class="number">.027</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">               Buffers: shared hit<span class="operator">=</span><span class="number">2</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.19</span><span class="number">.78</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">999</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.070</span>.<span class="number">.0</span><span class="number">.070</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">999</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>)</span><br><span class="line">               Buffers: shared hit<span class="operator">=</span><span class="number">2</span> read<span class="operator">=</span><span class="number">3</span></span><br><span class="line"> Planning:</span><br><span class="line">   Buffers: shared hit<span class="operator">=</span><span class="number">3</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.162</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.143</span> ms</span><br></pre></td></tr></table></figure>

<p><code>BUFFERS</code> 提供的数据有助于识别查询中哪些部分是 I&#x2F;O 密集型。</p>
<p>请记住，由于 <code>EXPLAIN ANALYZE</code> 实际运行查询，任何副作用都会照常发生，即使查询可能输出的任何结果都被丢弃以利于打印 <code>EXPLAIN</code> 数据。如果您想分析数据修改查询而不更改表，您可以在之后回滚命令，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">UPDATE</span> tenk1 <span class="keyword">SET</span> hundred <span class="operator">=</span> hundred <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                                                           QUERY PLAN</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> <span class="keyword">Update</span> <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.225</span><span class="number">.23</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">1.634</span>.<span class="number">.1</span><span class="number">.635</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Heap Scan <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">5.06</span>.<span class="number">.225</span><span class="number">.23</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">10</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.065</span>.<span class="number">.0</span><span class="number">.141</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Recheck Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">         Heap Blocks: exact<span class="operator">=</span><span class="number">90</span></span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Bitmap Index Scan <span class="keyword">on</span> tenk1_unique1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.5</span><span class="number">.04</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> width<span class="operator">=</span><span class="number">0</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.031</span>.<span class="number">.0</span><span class="number">.031</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">100</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">               Index Cond: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.151</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">1.856</span> ms</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>如本例所示，当查询是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 或 <code>MERGE</code> 命令时，应用表更改的实际工作由顶层 Insert、Update、Delete 或 Merge 计划节点完成。该节点下的计划节点执行定位旧行和&#x2F;或计算新数据的工作。因此，上面我们看到了与我们已经看到的位图表扫描相同的类型，其输出被馈送到一个 <code>Update</code> 节点，该节点存储更新的行。值得注意的是，尽管数据修改节点可能占用相当多的运行时间（这里它消耗了大部分时间），但规划器目前没有为该工作添加任何成本估计。那是因为要完成的工作对于每个正确的查询计划都是相同的，因此它不影响规划决策。</p>
<p>当 <code>UPDATE</code>、<code>DELETE</code> 或 <code>MERGE</code> 命令影响分区表或继承层次结构时，输出可能如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">UPDATE</span> gtest_parent <span class="keyword">SET</span> f1 <span class="operator">=</span> <span class="built_in">CURRENT_DATE</span> <span class="keyword">WHERE</span> f2 <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">                                       QUERY PLAN</span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------</span></span><br><span class="line"> <span class="keyword">Update</span> <span class="keyword">on</span> gtest_parent  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.06</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">0</span> width<span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">   <span class="keyword">Update</span> <span class="keyword">on</span> gtest_child gtest_parent_1</span><br><span class="line">   <span class="keyword">Update</span> <span class="keyword">on</span> gtest_child2 gtest_parent_2</span><br><span class="line">   <span class="keyword">Update</span> <span class="keyword">on</span> gtest_child3 gtest_parent_3</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Append  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.3</span><span class="number">.06</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">3</span> width<span class="operator">=</span><span class="number">14</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> gtest_child gtest_parent_1  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.01</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">14</span>)</span><br><span class="line">               <span class="keyword">Filter</span>: (f2 <span class="operator">=</span> <span class="number">101</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> gtest_child2 gtest_parent_2  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.01</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">14</span>)</span><br><span class="line">               <span class="keyword">Filter</span>: (f2 <span class="operator">=</span> <span class="number">101</span>)</span><br><span class="line">         <span class="operator">-</span><span class="operator">&gt;</span>  Seq Scan <span class="keyword">on</span> gtest_child3 gtest_parent_3  (cost<span class="operator">=</span><span class="number">0.00</span>.<span class="number">.1</span><span class="number">.01</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span> width<span class="operator">=</span><span class="number">14</span>)</span><br><span class="line">               <span class="keyword">Filter</span>: (f2 <span class="operator">=</span> <span class="number">101</span>)</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>Update</code> 节点需要考虑三个子表，而不是最初提到的分区表（因为它从不存储任何数据）。因此，有三个输入扫描子计划，每个表一个。为了清晰起见，<code>Update</code> 节点被注释以显示将要更新的特定目标表，其顺序与相应的子计划相同。</p>
<p><code>EXPLAIN ANALYZE</code> 显示的 <code>Planning time</code> 是从解析的查询生成查询计划并对其进行优化所需的时间。它不包括解析或重写。</p>
<p><code>EXPLAIN ANALYZE</code> 显示的 <code>Execution time</code> 包括执行器启动和关闭时间，以及运行任何触发器的触发时间，但不包括解析、重写或规划时间。执行 BEFORE 触发器所花费的时间（如果有）包含在相关 Insert、Update 或 Delete 节点的时间中；但执行 AFTER 触发器所花费的时间不计入其中，因为 AFTER 触发器在整个计划完成后才触发。每个触发器（无论是 BEFORE 还是 AFTER）中花费的总时间也单独显示。请注意，延迟约束触发器直到事务结束才会执行，因此 <code>EXPLAIN ANALYZE</code> 完全不考虑它们。</p>
<p>顶级节点显示的时间不包括将查询的输出数据转换为可显示形式或将其发送到客户端所需的任何时间。虽然 <code>EXPLAIN ANALYZE</code> 永远不会将数据发送到客户端，但可以通过指定 <code>SERIALIZE</code> 选项来指示它将查询的输出数据转换为可显示形式并测量所需时间。该时间将单独显示，并且也包含在总 <code>Execution time</code> 中。</p>
<p><strong>14.1.3. 注意事项</strong></p>
<p><code>EXPLAIN ANALYZE</code> 测量的运行时间与相同查询的正常执行方式之间存在两种显著差异。首先，由于没有输出行传递给客户端，因此不包括网络传输成本。除非指定 <code>SERIALIZE</code>，否则也不包括 I&#x2F;O 转换成本。其次，<code>EXPLAIN ANALYZE</code> 添加的测量开销可能很大，尤其是在 <code>gettimeofday()</code> 操作系统调用缓慢的机器上。您可以使用 <code>pg_test_timing</code> 工具来测量您系统上计时开销。</p>
<p><code>EXPLAIN</code> 的结果不应外推到与您实际测试的情况大相径庭的场景；例如，不能假定在玩具大小的表上的结果适用于大型表。规划器的成本估算不是线性的，因此它可能会为更大或更小的表选择不同的计划。一个极端的例子是，对于只占用一个磁盘页面的表，您几乎总是会得到一个顺序扫描计划，无论是否有索引可用。规划器知道无论如何处理表都需要读取一个磁盘页面，因此花费额外的页面读取来查看索引没有价值。（我们上面在 <code>polygon_tbl</code> 示例中看到了这一点。）</p>
<p>在某些情况下，实际值和估计值可能不匹配，但实际上并没有问题。一个这样的情况发生在计划节点执行因 <code>LIMIT</code> 或类似效果而提前停止时。例如，在我们之前使用的 <code>LIMIT</code> 查询中，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tenk1 <span class="keyword">WHERE</span> unique1 <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">AND</span> unique2 <span class="operator">&gt;</span> <span class="number">9000</span> LIMIT <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                                                          QUERY PLAN</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> Limit  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.14</span><span class="number">.33</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.051</span>.<span class="number">.0</span><span class="number">.071</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">   <span class="operator">-</span><span class="operator">&gt;</span>  Index Scan <span class="keyword">using</span> tenk1_unique2 <span class="keyword">on</span> tenk1  (cost<span class="operator">=</span><span class="number">0.29</span>.<span class="number">.70</span><span class="number">.50</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">10</span> width<span class="operator">=</span><span class="number">244</span>) (actual <span class="type">time</span><span class="operator">=</span><span class="number">0.051</span>.<span class="number">.0</span><span class="number">.070</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">2</span> loops<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line">         Index Cond: (unique2 <span class="operator">&gt;</span> <span class="number">9000</span>)</span><br><span class="line">         <span class="keyword">Filter</span>: (unique1 <span class="operator">&lt;</span> <span class="number">100</span>)</span><br><span class="line">         <span class="keyword">Rows</span> Removed <span class="keyword">by</span> <span class="keyword">Filter</span>: <span class="number">287</span></span><br><span class="line"> Planning <span class="type">Time</span>: <span class="number">0.077</span> ms</span><br><span class="line"> Execution <span class="type">Time</span>: <span class="number">0.086</span> ms</span><br></pre></td></tr></table></figure>

<p><code>Index Scan</code> 节点的估计成本和行数显示为它已运行完成。但实际上 <code>Limit</code> 节点在获取到两行后停止请求行，因此实际行数仅为 2，并且运行时间低于成本估计所暗示的。这不是估计错误，只是估计值和真实值显示方式上的差异。</p>
<p>合并连接也有可能让不熟悉的人感到困惑的测量伪影。如果合并连接用尽了另一个输入，并且一个输入中的下一个键值大于另一个输入中的最后一个键值，它将停止读取一个输入；在这种情况下，将不再有匹配项，因此不需要扫描第一个输入的其余部分。这导致不读取一个子节点的全部内容，其结果类似于 <code>LIMIT</code> 中提到的情况。此外，如果外部（第一个）子节点包含具有重复键值的行，则内部（第二个）子节点会回溯并重新扫描与其键值匹配的那部分行。<code>EXPLAIN ANALYZE</code> 将这些相同的内部行的重复发出计为实际的额外行。当有许多外部重复项时，内部子计划节点的报告实际行数可能显著大于内部关系中实际的行数。</p>
<p>由于实现限制，<code>BitmapAnd</code> 和 <code>BitmapOr</code> 节点始终将其实际行数报告为零。</p>
<p>通常，<code>EXPLAIN</code> 将显示规划器创建的每个计划节点。但是，在某些情况下，执行器可以根据规划时不可用的参数值确定某些节点不需要执行，因为它们无法生成任何行。（目前这只可能发生在正在扫描分区表的 <code>Append</code> 或 <code>MergeAppend</code> 节点的子节点。）发生这种情况时，这些计划节点将从 <code>EXPLAIN</code> 输出中省略，并显示 <code>Subplans Removed: N</code> 注释。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/using-explain.html">using-explain</a></p>
</blockquote>
</div><div class="article-licensing box"><div class="licensing-title"><p>postgres using explain</p><p><a href="https://wuhunyu.top/postgres/2025/07/17/explain/index.html">https://wuhunyu.top/postgres/2025/07/17/explain/index.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>wuhunyu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-07-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-12-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/explain/">explain</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://wuhunyu.top" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/chat/2025/08/odt/index.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">珂朵莉树</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/ai/rag/2025/06/langchain4j-mcp-example/index.html"><span class="level-item">基于 langchain4j 的简易 MCP Client</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-2-tablet is-2-desktop is-2-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://static.wuhunyu.top/images/avatar-compress.png" alt="wuhunyu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">wuhunyu</p><p class="is-size-6 is-block">有志者，事竟成</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>🐱喵星🐱</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">247</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">103</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wuhunyu" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wuhunyu"><i class="iconfont icon-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="LeetCode" href="https://leetcode.cn/u/wuhunyu"><i class="iconfont icon-likou"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:wuhunyu@gmail.com"><i class="iconfont icon-a-031mail2"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">1</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/chart/2025/12/01/mermaid/index.html"><img src="https://static.wuhunyu.top/images/2025/12/c0f63c86b515122fbce3496a2153801d.png" alt="Mermaid 简单实用与实践"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-12-01T08:59:00.000Z">2025-12-01</time></p><p class="title"><a href="/chart/2025/12/01/mermaid/index.html">Mermaid 简单实用与实践</a></p><p class="categories"><a href="/categories/chart/">chart</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/java/2025/11/17/jackson-mixin/index.html"><img src="https://static.wuhunyu.top/images/2025/11/be8f1c0759a95e6f49f6f5df7cdcd9a1.jpg" alt="jackson mixin 特性简单应用"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-11-17T10:14:00.000Z">2025-11-17</time></p><p class="title"><a href="/java/2025/11/17/jackson-mixin/index.html">jackson mixin 特性简单应用</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/oss/2025/10/31/migration-minio-to-rustfs/index.html"><img src="https://static.wuhunyu.top/images/2025/10/6e8e85469a3bbe17e0fa3bd99ff19a30.png" alt="迁移 minio 到 rustfs"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-10-31T14:42:00.000Z">2025-10-31</time></p><p class="title"><a href="/oss/2025/10/31/migration-minio-to-rustfs/index.html">迁移 minio 到 rustfs</a></p><p class="categories"><a href="/categories/oss/">oss</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/java/2025/10/10/multipart-file/index.html"><img src="https://static.wuhunyu.top/images/2025/10/771da8902ad6b83b69d055b57aa2fe3e.png" alt="MultipartFile 输入流可重复读吗"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-10-10T10:53:00.000Z">2025-10-10</time></p><p class="title"><a href="/java/2025/10/10/multipart-file/index.html">MultipartFile 输入流可重复读吗</a></p><p class="categories"><a href="/categories/MultipartFile/">MultipartFile</a> / <a href="/categories/MultipartFile/%E6%B5%81/">流</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/linux/2025/10/04/mac-mini/index.html"><img src="https://static.wuhunyu.top/images/2025/10/fbe798875f3ca35e68f356b42d5865bf.png" alt="记一次个人服务器操作系统切换"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-10-04T13:19:00.000Z">2025-10-04</time></p><p class="title"><a href="/linux/2025/10/04/mac-mini/index.html">记一次个人服务器操作系统切换</a></p><p class="categories"><a href="/categories/linux/">linux</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Docker-Hub/"><span class="level-start"><span class="level-item">Docker Hub</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/GitHub-Actions/"><span class="level-start"><span class="level-item">GitHub Actions</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><span class="level-start"><span class="level-item">LeetCode每日一题</span></span><span class="level-end"><span class="level-item tag">208</span></span></a></li><li><a class="level is-mobile" href="/categories/MultipartFile/"><span class="level-start"><span class="level-item">MultipartFile</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/MultipartFile/%E6%B5%81/"><span class="level-start"><span class="level-item">流</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/MyBatis/"><span class="level-start"><span class="level-item">MyBatis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/ai/"><span class="level-start"><span class="level-item">ai</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/ai/dart/"><span class="level-start"><span class="level-item">dart</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/chart/"><span class="level-start"><span class="level-item">chart</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/jvm/"><span class="level-start"><span class="level-item">jvm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/mongodb/"><span class="level-start"><span class="level-item">mongodb</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/oss/"><span class="level-start"><span class="level-item">oss</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/postgres/"><span class="level-start"><span class="level-item">postgres</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/spring-event/"><span class="level-start"><span class="level-item">spring event</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/spring-event/spring-transaction/"><span class="level-start"><span class="level-item">spring transaction</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%8A%98%E5%8F%A0%E8%87%AA%E8%A1%8C%E8%BD%A6/"><span class="level-start"><span class="level-item">折叠自行车</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%97%85%E6%B8%B8/"><span class="level-start"><span class="level-item">旅游</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%97%85%E6%B8%B8/%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路线规划</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%A0%B4%E8%A7%A3/"><span class="level-start"><span class="level-item">破解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"><span class="level-start"><span class="level-item">碎碎念</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%9D%A2%E7%BB%8F/"><span class="level-start"><span class="level-item">面经</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DataGrip/"><span class="tag">DataGrip</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dijkstra-%E7%AE%97%E6%B3%95/"><span class="tag">Dijkstra 算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker-Hub/"><span class="tag">Docker Hub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub-Actions/"><span class="tag">GitHub Actions</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GoLand/"><span class="tag">GoLand</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IntelliJ-IDEA/"><span class="tag">IntelliJ IDEA</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JetBrains-%E5%85%A8%E5%AE%B6%E6%A1%B6/"><span class="tag">JetBrains 全家桶</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode-%E9%87%8C%E7%A8%8B%E7%A2%91/"><span class="tag">LeetCode 里程碑</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo mb-2" href="/">wuhunyu · <a href="http://beian.miit.gov.cn/" target="_blank" style="display: inline-block">赣ICP备2022010426号</a></a><a class="is-block" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=36070302361043" target="_blank">赣公网安备 36070302361043号</a><p class="is-size-7"><span class="is-size-7">© 2025 wuhunyu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p style="align-items: center; line-height: 28px;">本网站由<a style="margin: 0 2px" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="_blank" rel="noopener noreferrer"><img style="height: 28px;" src="/images/upyun.png" alt="又拍云"></a>提供CDN加速/云存储服务</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script defer src="https://events.vercount.one/js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>