{"posts":[{"title":"216. 组合总和 III","text":"组合总和 III 难度: medium 原始链接: https://leetcode.cn/problems/combination-sum-iii 标签: 回溯 解法一: 回溯go123456789101112131415161718192021222324func combinationSum3(k int, n int) [][]int { ans := [][]int{} var dfs func(cur, sum int, list []int) dfs = func(cur, sum int, list []int) { if len(list) == k &amp;&amp; sum == n { newList := make([]int, k) copy(newList, list) ans = append(ans, newList) return } if cur &gt; 9 || len(list) &gt; k || sum &gt; n { return } for i := cur; i &lt;= 9; i++ { list = append(list, i) sum += i dfs(i+1, sum, list) sum -= i list = list[:len(list)-1] } } dfs(1, 0, []int{}) return ans}","link":"/leetcode/2024/04/combination-sum-iii/index.html"},{"title":"377. 组合总和 IV","text":"组合总和 IV 难度: medium 原始链接: https://leetcode.cn/problems/combination-sum-iv 标签: 动态规划 解法一: 递归, 记忆化搜索go1234567891011121314151617181920212223func combinationSum4(nums []int, target int) int { record := make([]int, target+1) for i := 1; i &lt;= target; i++ { record[i] = -1 } var dfs func(cur int) int dfs = func(cur int) int { if cur == 0 { return 1 } else if record[cur] &gt; -1 { return record[cur] } sum := 0 for _, num := range nums { if cur &gt;= num { sum += dfs(cur - num) } } record[cur] = sum return sum } return dfs(target)} 解法二: 迭代go1234567891011121314func combinationSum4(nums []int, target int) int { record := make([]int, target+1) record[0] = 1 for i := 1; i &lt;= target; i++ { sum := 0 for _, num := range nums { if i &gt;= num { sum += record[i-num] } } record[i] = sum } return record[target]}","link":"/leetcode/2024/04/combination-sum-iv/index.html"},{"title":"705. 设计哈希集合","text":"设计哈希集合 难度: easy 原始链接: https://leetcode.cn/problems/design-hashset 标签: 数组 解法一: 数组go1234567891011121314151617181920212223242526272829type MyHashSet struct { data []bool}func Constructor() MyHashSet { return MyHashSet{ data: make([]bool, 1000001), }}func (this *MyHashSet) Add(key int) { this.data[key] = true}func (this *MyHashSet) Remove(key int) { this.data[key] = false}func (this *MyHashSet) Contains(key int) bool { return this.data[key]}/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */","link":"/leetcode/2024/04/design-hashset/index.html"},{"title":"706. 设计哈希映射","text":"设计哈希映射 难度: easy 原始链接: https://leetcode.cn/problems/design-hashmap 标签: 数组 解法一: 数组go1234567891011121314151617181920212223242526272829303132333435const N = 1000001type MyHashMap struct { data []int}func Constructor() MyHashMap { data := make([]int, N) for i := 0; i &lt; N; i++ { data[i] = -1 } return MyHashMap{ data, }}func (this *MyHashMap) Put(key int, value int) { this.data[key] = value}func (this *MyHashMap) Get(key int) int { return this.data[key]}func (this *MyHashMap) Remove(key int) { this.data[key] = -1}/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","link":"/leetcode/2024/04/design-hashmap/index.html"},{"title":"2810. 故障键盘","text":"故障键盘 难度: easy 原始链接: https://leetcode.cn/problems/faulty-keyboard 标签: 双端队列 解法一: 双端队列go1234567891011121314151617181920212223func finalString(s string) string { queues := [][]rune{ []rune{}, []rune{}, } for _, ch := range s { if ch == 'i' { queues[0], queues[1] = queues[1], queues[0] } else { queues[0] = append(queues[0], ch) } } sb := strings.Builder{} n1 := len(queues[0]) n2 := len(queues[1]) for i := n2 - 1; i &gt;= 0; i-- { sb.WriteString(string(queues[1][i])) } for i := 0; i &lt; n1; i++ { sb.WriteString(string(queues[0][i])) } return sb.String()}","link":"/leetcode/2024/04/faulty-keyboard/index.html"},{"title":"MongoDB 入门","text":"MongoDB 入门数据库shell12345678910111213# 查询所有数据库show databases; | show dsb;# 创建/切换到指定的数据库。如果数据库不存在任何集合，使用 `show dbs` 将不会展示该数据库 use [database]; # 创建(如果不存在)/切换到 test 数据库 use test;# 查询当前所在的数据库db# 删除当前数据库db.dropDatabase(); 集合shell1234567891011121314# 查询数据库中的所有集合show collections; | show tables;# 显式创建集合db.createCollection(&quot;[集合名称]&quot;); # 创建一个集合名称为 user 的集合 db.createCollection(&quot;user&quot;); # 通过新增一条文档记录，隐式创建一个集合。比如：往 user 集合中插入一条 name 为 wuhunyu 的文档，将会隐式地创建 user 集合 db.user.insert({name: &quot;wuhunyu&quot;});# 删除一个集合db.[集合].drop(); # 删除一个名称为 user 的集合 db.user.drop(); 文档插入shell12345678910111213141516# 单行插入db.[集合名称].insert([文档]) # 往 user 集合中插入一条 name 为 wuhunyu 的文档 db.user.insert({name: &quot;wuhunyu&quot;});# 批量插入db.[集合名称].insertMany([文档1, 文档2...]); # 批量插入 db.user.insertMany([{_id: 1, name: &quot;1号&quot;}, {name: &quot;2号&quot;, age: 25}, {name: &quot;3号&quot;, bir: &quot;2023-12-16&quot;}]); # 使用 insert 也可以批量插入 db.user.insert([{_id: 1, name: &quot;1号&quot;}, {name: &quot;2号&quot;, age: 25}, {name: &quot;3号&quot;, bir: &quot;2023-12-16&quot;}]); # js 脚本插入for (let i = 0; i &lt; 10; i++) { db.user.insert({_id: i, name: i + &quot;号&quot;, age: i + 20});} 删除shell123456789101112131415# 删除集合全部的文档记录db.[集合].remove({}); # 删除 user 集合中的全部数据 db.user.remove({}); # 删除 user 集合中的 _id 为 1 的文档记录 db.user.remove({_id: 1}); # 如果是 mongo 自动生成的 id，需要使用 ObjectId(&quot;[id]&quot;) 的方式指定 _id db.user.remove({_id: ObjectId(&quot;657d08e9cb5c0571e33ee6b4&quot;)}); # 删除 user 集合中的 name 为 &quot;1号&quot; 的文档记录 db.user.remove({name: &quot;1号&quot;}); # 删除一条记录db.[集合].remove({}, {justOne: true}); # 删除 user 集合中 age 字段为 20 的第一条记录 db.user.remove({age: 20}, {justOne: true}); 修改shell12345678910111213141516171819# 修改# 查询条件 可以类比成 where 条件# 修改值 可以类比成 set# multi 表示是否批量更新，默认为 false，即为只更新找到的第一条记录# upsert 表示查询条件查询不存在记录时，是否新增，默认为 falsedb.[集合].update( {[查询条件]}, {[修改值]}, { multi: &lt;boolean&gt;, upsert: &lt;boolean&gt;, }); # 修改 user 集合中第一条 age 为 20 的文档记录。这种修改方式类似于删除之后再新增，修改之后的字段只会保留 _id 和 age 字段 db.user.update({age: 20}, {age: 25}); # 修改 user 集合中第一条 age 为 20 的文档记录。这种修改方式类似于部分修改，只修改指定的字段 db.user.update({age: 20}, {$set: {age: 25}}); # 修改 user 集合中的所有 age 为 20 的文档记录 db.user.update({age: 20}, {$set: {age: 25}}, {multi: true}); 查询shell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 查询全部db.[集合].find(); # 查询 user 集合中的全部文档记录 db.user.find(); # 格式化显示，对于较长的文档记录，可以使用 .pretty() 来格式化展示 db.user.find().pretty(); # 操作符$gt &gt;$lt &lt;$gte &gt;=$lte &lt;=$ne !=# 条件查询db.[集合].find({[查询条件]}); # and 条件查询 # 查询 user 集合中，age 等于 25 的记录 db.user.find({age: 25}); # 查询 user 集合中，age 大于等于 25 的记录 db.user.find({age: {$gte: 25}}); # 查询 user 集合中，age 大于等于 25 且 小于等于 30 的记录 db.user.find({age: {$gte: 25, $lte: 30}}); # 错误写法：后一个 age 条件会覆盖掉前一个查询条件，等价于 `db.user.find({age: 30})` db.user.find({age: 25, age: 30}); # or 条件查询 # 查询 user 集合中，age 大于等于 25 或者 name 为 &quot;1号&quot; 的记录 db.user.find({$or: [{age: {$gte: 25}}, {name: &quot;1号&quot;}]}); # and 和 or 的联合查询 # 查询 user 集合中，age大于等于 25 或者 name 为 &quot;1号&quot; 且 age 等于 20 的记录 db.user.find({$or: [{age: {$gte: 25}}, {name: &quot;1号&quot;, age: 20}]});# 数组结构。在 mongo 中，数组结构的查询和和普通的查询也是一样的# 比如，user 集合中一条文档记录有一个字段是 likes# { &quot;_id&quot; : ObjectId(&quot;657d1dfacb5c0571e33ee6c3&quot;), &quot;name&quot; : &quot;test&quot;, &quot;likes&quot; : [ &quot;看电视&quot;, &quot;看书&quot;, &quot;打篮球&quot; ] }# 如果要查询，likes 中包含了 &quot;看书&quot; 的记录db.user.find({likes: &quot;看书&quot;});# 模糊查询。mongo 中并没有像是 `%`, `_` 的标识符，需要通过正则表达式的方式来实现模糊查询# 查询 user 集合中，name 包含 &quot;号&quot; 的记录db.user.find({name: /号/}).pretty();# 排序db.[集合].find().sort({[排序条件]}); # 1: 升序; -1: 降序 # 查询 user 集合中全部的记录，按 age 倒序，name 顺序 排序 db.user.find().sort({age: -1, name: 1}); # 分页# skip 偏移量，从 0 开始# limit 最大条数db.[集合].find().skip([skip]).limit([limit]); # 查询 user 集合全部的记录，只保留前 5 条记录，如果 skip 为 0，可以省略 skip，等价于 `db.user.find()limit(5);` db.user.find().skip(0).limit(5); # 统计数据量db.[集合].count(); # 统计 user 集合的中数据量 db.user.count(); # 统计 user 集合中，age 小于等于 25 的记录数量 db.user.find({age: {$lte: 25}}).count();# 返回指定的字段db.[集合].find([查询条件], [映射字段]); # 查询 user 集合中的 name 字段。其中，1 表示显示，0 表示不显示 db.user.find({}, {name: 1}); $type$type 操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 shell123# 查询 user 集合中，name 为字符串类型的文档记录，等价于 `db.user.find({name: {$type: 2}});`db.user.find({name: {$type: &quot;string&quot;}});# 值得一提的是，mongo 中的整形的默认类型是 Double 索引shell12345678910111213141516171819# 查询集合下的所有索引db.[集合].getIndexes(); # 查询 user 集合下的所有索引 db.user.getIndexes(); # 创建一个缩影db.[索引].craeteIndex([索引字段], [索引配置]); # 创建一个名称为 idx_name_age 的索引，索引字段为 (name, age), 都为升序排列 db.user.createIndex({name: 1, age: 1}, {name: &quot;idx_name_age&quot;}); # 删除集合下的全部索引db.[集合].dropIndexes(); # 删除 user 集合下的所有索引(除了 id 索引) db.user.dropIndexes();# 删除指定索引db.[集合].dropIndex([索引名称]); # 删除 user 集合的 idx_name_age 索引 db.user.dropIndex(&quot;idx_name_age&quot;); 聚合管道 $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 聚合函数 表达式 描述 $sum 计算总和。 $avg 计算平均值 $min 获取集合中所有文档对应值得最小值。 $max 获取集合中所有文档对应值得最大值。 $push 将值加入一个数组中，不会判断是否有重复的值。 $addToSet 将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。 $first 根据资源文档的排序获取第一个文档数据。 $last 根据资源文档的排序获取最后一个文档数据 测试数据shell1234567891011121314151617181920212223242526db.mycol.insert([ { title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }, { title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 10 }, { title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750 }]); 示例操作shell123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# 管道操作# $project 映射 title 和 by_user 字段db.mycol.aggregate([ { $project: { _id: 0, title: 1, by_user: 1 } }]);# $match 过滤 likes &gt;= 100, tags 包含 mongo 的记录db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $project: { _id: 0, title: 1, by_user: 1 } }]);# 分页db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $project: { _id: 0, title: 1, by_user: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $unwind 数组拆分db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $unwind: &quot;$tags&quot; }, { $project: { _id: 0, title: 1, by_user: 1, tags: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $sort 排序db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $unwind: &quot;$tags&quot; }, { $project: { _id: 0, title: 1, by_user: 1, tags: 1 } }, { $sort: { title: 1, tags: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $group 分组db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;database&quot; } }, { $group: { _id: { author: &quot;$by_user&quot;, url: &quot;$url&quot; }, minLikes: { $min: &quot;$likes&quot; }, maxLikes: { $max: &quot;$likes&quot; }, avgLikes: { $avg: &quot;$likes&quot; }, count: { $sum: 1 }, sum: { $sum: &quot;$likes&quot; } } }]).pretty();","link":"/mongodb/MongoDB%20%E5%85%A5%E9%97%A8/index.html"},{"title":"MyBatis 缓存","text":"MyBatis 缓存MyBatis 有两级缓存，其中一级缓存默认开启，二级缓存需要手动开启。不过 MyBatis 的缓存很容易失效，所以建议保持默认配置只开启一级缓存即可。本文将以案例的形式来介绍 MyBatis 的缓存 本文所使用的例子完整示例存放在 GitHub 中 MyBatis 的缓存分为 一级缓存 和 二级缓存一级缓存一级缓存 默认开启，同一个 SqlSession 对象共享一个缓存 失效场景 没有使用同一个 SqlSession 发生了任意修改类操作 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 localCacheScope 属性配置为 STATEMENT 二级缓存二级缓存需要手动开启，同一个 namespace 共享一个缓存，也可以使用配置的方法使得多个 namespace 共享一个缓存 失效场景 发生了任意修改类操作，会清空所有的二级缓存。当然，一级缓存也会被清空 如果使用 MyBatisPlus 默认提供的查询语句，没有在 Mapper 接口上配置 @CacheNamespaceRef 也会导致二级缓存不生效 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 mapper 映射文件没有配置 cache 标签 一级缓存示例项目工程 MyBatis 核心配置 xml12345678910&lt;settings&gt; &lt;!-- 二级缓存关闭 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt; &lt;!-- 一级缓存配置为 session 级别，简单理解就是开启一级缓存 --&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;!-- 开启下划线转驼峰 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 日志实现 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; logback 日志配置 xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration scan=&quot;false&quot;&gt; &lt;contextName&gt;mybatis&lt;/contextName&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%logger{50}] - %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;!-- mapper 层开启 debug 日志 --&gt; &lt;logger name=&quot;top.wuhunyu.mybatis.cache.mapper&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt; User 实体 Java1234567891011121314151617181920212223@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable { private static final long serialVersionUID = -2716722547404828511L; /** * 用户id */ private Long id; /** * 用户名称 */ private String userName; /** * 年龄 */ private Integer age;} UserMapper Java12345678910111213141516171819public interface UserMapper { /** * 根据用户id查询用户信息 * * @param id 用户id 非空 * @return 用户实体对象 */ User findUserById(@Param(&quot;id&quot;) Long id); /** * 根据用户id修改用户信息 * * @param user 用户实体对象 */ void updateUserById(@Param(&quot;user&quot;) User user); } UserMapper.xml 映射文件 xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.wuhunyu.mybatis.cache.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findUserById&quot; resultType=&quot;top.wuhunyu.mybatis.cache.domain.User&quot;&gt; select u.id, u.user_name, u.age from `user` u where u.id = #{id} &lt;/select&gt; &lt;update id=&quot;updateUserById&quot;&gt; update `user` set user_name = #{user.userName}, age = #{user.age} where id = #{user.id} &lt;/update&gt;&lt;/mapper&gt; 一级缓存生效演示同一个 SqlSession 同一个 Mapper 对象分别查询同一条 sql 时 Java123456789101112try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertSame(user1, user2);} 日志打印情况如下 图中只打印了一次 sql，表示第二次查询并没有真的发起 sql 查询，而是从一级缓存中直接获取。由于一级缓存可以理解为一个 Map，并不存在序列化操作，因此直接比较 user1 和 user2 的内存地址也是相同的 同一个 SqlSession 不同 Mapper 对象分别查询同一条 sql 时 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class); UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class); User user1 = userMapper1.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper2.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertSame(user1, user2);} 日志打印情况如下 图中只打印了一次 sql，表示一级缓存生效 一级缓存失效演示没有使用同一个 SqlSession Java123456789101112131415try ( // 关闭自动提交事务 SqlSession sqlSession1 = sqlSessionFactory.openSession(false); SqlSession sqlSession2 = sqlSessionFactory.openSession(false);) { UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = userMapper1.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); sqlSession1.commit(); User user2 = userMapper2.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession2.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 图中分别打印了两次 sql，user1 和 user2 的内存地址也不一样了，表示一级缓存失效了 发生了任意修改类操作 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); userMapper.updateUserById(new User(2L, &quot;李四-2&quot;, 21)); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 同样打印了两次查询 sql，这是由于 updateUserById 发生了修改操作导致的缓存失效 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); sqlSession.clearCache(); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 由于手动触发了 clearCache，导致一级缓存失效了 localCacheScope 属性配置为 STATEMENT 修改 localCacheScope 的值为 STATEMENT 拿之前一级缓存生效的例子 Java123456789101112try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 localCacheScope 为 STATEMENT 时，表示缓存作用于 STATEMENT，而一个 STATEMENT 就是一条 sql，也就表示一级缓存失效了 二级缓存示例项目工程 application.yml 配置 yaml1234567891011121314151617181920212223242526spring: application: name: mybatis-plus datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test username: root password: 123456server: port: 10000# mybatis-plus 配置mybatis-plus: configuration: # 开启下划线转驼峰 map-underscore-to-camel-case: true # 日志实现 log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl # 二级缓存开启 cache-enabled: true # 一级缓存配置为 session 级别，简单理解就是开启一级缓存 local-cache-scope: session # mapper.xml 位置 mapper-locations: classpath*:/top/wuhunyu.mybatis/plus/cache/mapper/**/*Mapper.xml 主启动类配置 mapper 扫描路径 切换成了 MybatisPlus 之后，先看看一级缓存是否还生效 一级缓存生效演示 同一个 SqlSession，使用 Mybatis 原生 sql 写法 Java1234User user1 = userMapper.findUserById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.findUserById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 可以看到，查询的 sql 语句只被执行了一次，日志还打印了缓存被击中的概率为 0.5，说明第二次查询确实从缓存中获取成功了 另外，日志有一条 WARN。这是由于二级缓存的结果会序列化保存的缘故 通过 debug 可以观察到两个 user 对象的 hash 值并不相同，表示不是同一个对象，但确实走了二级缓存，这是由于二级缓存反序列导致的 这条 WARN 日志就是针对序列化可能产生 bug 而打印的警告，详情可以通过日志给出的链接自行了解 此处以及之后的例子都不对这个 WARN 日志进行处理 同一个 SqlSession，使用 MybatisPlus api 的写法在 UserMapper 上加上 @CacheNamespaceRef(UserMapper.class) 注解 Java12345678910111213141516171819@CacheNamespaceRef(UserMapper.class)public interface UserMapper extends BaseMapper&lt;User&gt; { /** * 根据用户id查询用户信息 * * @param id 用户id 非空 * @return 用户实体对象 */ User findUserById(@Param(&quot;id&quot;) Long id); /** * 根据用户id修改用户信息 * * @param user 用户实体对象 */ void updateUserById(@Param(&quot;user&quot;) User user);} 测试用例如下 Java1234User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.selectById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 能够观察到走了二级缓存 不同 SqlSession，使用 MybatisPlus api 的写法 Java12345678910User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);ExecutorService executor = Executors.newSingleThreadExecutor();CountDownLatch countDownLatch = new CountDownLatch(1);executor.execute(() -&gt; { User user2 = userMapper.selectById(1L); log.info(&quot;user2: {}&quot;, user2); countDownLatch.countDown();});countDownLatch.await(); 日志打印情况如下 也是没有问题的 二级缓存失效演示 发生了任意修改类操作 Java12345678910111213User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);userMapper.updateUserById(new User(2L, &quot;张三&quot;, 21));ExecutorService executor = Executors.newSingleThreadExecutor();CountDownLatch countDownLatch = new CountDownLatch(1);AtomicReference&lt;User&gt; userAtomicReference = new AtomicReference&lt;&gt;();executor.execute(() -&gt; { User user2 = userMapper.selectById(1L); log.info(&quot;user2: {}&quot;, user2); userAtomicReference.set(user2); countDownLatch.countDown();});countDownLatch.await(); 日志打印情况如下 可以看到二级缓存的集中率都是 0.0，表示二级缓存没有被击中 如果使用 MyBatisPlus 默认提供的查询语句，没有在 Mapper 接口上配置 @CacheNamespaceRef Java1234User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.selectById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 发生了两次 sql 查询，说明缓存失效 mapper 映射文件没有配置 cache 标签 Java1234User user1 = userMapper.findUserById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.findUserById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下","link":"/mybatis/mybatis-cache/index.html"},{"title":"GitHub Actions 简单使用","text":"GitHub Actions 是什么官方文档 是这么介绍的 在 GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程。 您可以发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程中。 我的理解可以理解为一个有条件（比如push事件，也可以是 cron 表达式定义的一个定时任务）触发的工作流任务。而这个工作流任务是可以由我们开发者自定义的，执行这些任务的环境由 GitHub 提供，一般是 ubuntu 环境。通过这个环境，我们可以执行一些自定义脚本，亦或是调用其他开发者发布的插件来实现一些开发者想要的功能 GitHub Actions 可以做什么传统 CI/CD 能做的编译，打包，发布，使用 GitHub Actions 肯定也是能实现的 这里，我想使用两个我自己的案例来演示说明，我使用 GitHub Actions 做了些什么 个人博客编译，打包，发布 作为拉取 docker-hub 官方镜像的中转工具 前置准备工作如何自定义工作流任务 只需要在仓库存在 .github/workflows/*.yml，在满足触发条件之后，就会被自动执行 这个配置文件可以有多个，执行的时候是并行的，但也可以定义工作流的依赖关系实现串行化 关于执行环境 可以自定义选择 Linux，Windows 和 macOS，具体的版本可以访问这里查看 Linux 环境已经自带了 Docker 环境，无需重复安装 关于插件 GitHub Actions 的插件分为官方和非官方的，其中官方的插件地址都是 https://github.com/actions 开头的 比如检出仓库代码的插件 checkout 比如第三方部署到 GitHub Pages 的插件 peaceiris/actions-gh-pages 可以在 GitHub 市场 中寻找符合自己需求的插件 个人博客编译，打包，发布.github/workflows/deploy.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172name: Deploy My Hexo Blogon: push: branches: - mainjobs: build: runs-on: ubuntu-latest # 权限控制 permissions: contents: read pages: write id-token: write steps: # 检出仓库代码 - name: Checkout Repository uses: actions/checkout@v4 # 设置 Node.js 版本 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: '20.9.0' # 缓存 npm 依赖 - name: Cache npm dependencies uses: actions/cache@v2 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-v2 restore-keys: | ${{ runner.os }}-node- # 安装 Hexo CLI - name: Install Hexo CLI run: npm install hexo-cli -g # 安装 npm 依赖 - name: Install npm dependencies run: | npm install --prefix themes/icarus npm install # 生成静态文件 - name: Generate static files run: | hexo clean hexo g # 部署到云服务器 - name: Deploy to Cloud Server uses: easingthemes/ssh-deploy@main with: SSH_PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }} ARGS: &quot;-avz --delete&quot; SOURCE: ${{ secrets.SOURCE }} REMOTE_HOST: ${{ secrets.HOST }} REMOTE_PORT: ${{ secrets.PORT }} REMOTE_USER: ${{ secrets.USER }} TARGET: ${{ secrets.TARGET }} # 部署到 wuhunyu.github.io - name: Deploy to Github Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: ${{ secrets.ACCESS_TOKEN }} external_repository: ${{ secrets.PAGE_REPO }} publish_branch: ${{ secrets.PAGE_BRAN }} publish_dir: ${{ secrets.SOURCE }} commit_message: ${{ github.event.head_commit.message }} 简单说明一下这个 actions 的内容 actions 的名称是 Deploy My Hexo Blog 当仓库的 main 分支有 push 事件发生时自动触发 工作流的执行环境是 ubuntu-latest 其次是关于权限控制的说明 最后按 steps 的声明顺序，任务会被依次执行，如果中途出现了错误，则会直接中断后续的任务。每个任务的作用在注释中已经写了，就不再多说明了。值得注意的是，其中有 ${{ }} 的符号，这是从当前上下文取值的占位符，其中 secrets 是由开发者自定义的环境变量，具体可以在每个仓库的 settings/secrets/actions 进行设置 action 运行的控制台像这样，按执行顺序列出了每个任务的日志 作为拉取 docker-hub 官方镜像的中转工具 前些天在掘金上看到了有人已经实现了，功能要比我这个更加健壮，地址如下 docker_image_pusher 下面展示的这个工具是我个人使用，每次拉取镜像也不会太大，像是磁盘不够的情况暂时还不需要考虑 .github/workflows/docker-hub.yml 123456789101112131415161718192021222324252627282930313233name: Pull and Push Docker Imageson: push: branches: - mainjobs: deploy: runs-on: ubuntu-latest steps: # 检出仓库代码 - name: Checkout Repository uses: actions/checkout@v4 # 安装 jq 以处理 JSON 文件 - name: Install jq run: sudo apt-get install -y jq # 登录到阿里云容器镜像服务 - name: Log in to Alibaba Cloud Registry run: echo &quot;${{ secrets.ALIYUN_REGISTRY_PASSWORD }}&quot; | docker login -u &quot;${{ secrets.ALIYUN_REGISTRY_USERNAME }}&quot; registry.cn-guangzhou.aliyuncs.com --password-stdin # 拉取和推送 Docker 镜像 - name: Pull and Push Docker images env: ALIYUN_NAMESPACE: ${{ secrets.ALIYUN_REGISTRY_NAMESPACE }} run: | for image in $(jq -r '.[]' images.json); do echo &quot;Processing image: ${image}&quot; docker pull ${image} aliyun_image=&quot;registry.cn-guangzhou.aliyuncs.com/${{ env.ALIYUN_NAMESPACE }}/${image##*/}&quot; docker tag ${image} $aliyun_image docker push ${aliyun_image} done 同样也是当仓库的 main 分支有 push 事件发生时自动触发 之后登陆阿里云的 docker hub 镜像 读取仓库中的 images.json 配置文件，形如 1234[ &quot;redis&quot;, &quot;nginx:latest&quot;] 在容器内 pull 镜像之后再 push 给阿里云的 docker hub 这里利用 actions 的容器可访问外网的能力将 docker 镜像中转到内网可访问的镜像站 其他除了以上两个案例，GitHub 有一个叫 Releases 的概念，也可以借由 GitHub Actions 来打包 .github/workflows/buildAndRelease.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344name: Build And Releaseon: push: tags: - 'v*.*.*'jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Code uses: actions/checkout@v4 - name: Set Up JDK 21 uses: actions/setup-java@v4 with: java-version: '21' distribution: 'adopt' - name: Build with Maven run: mvn clean package -DskipTests - name: Create Release id: create_release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false - name: Upload JAR to Release uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.create_release.outputs.upload_url }} asset_path: ${{ secrets.ASSET_PATH }} asset_name: ${{ secrets.ASSET_NAME }} asset_content_type: application/java-archive Releases 基于 tag，所以需要 actions 的触发条件可以设置为 tag 被 push 时 效果如下 总结 GitHub Actions 是 GitHub 免费开放给开发者的自动化工作流 基于 GitHub Actions，可以解放部分项目本地编译，部署的服务器资源。我借用这个功能实现了几个小功能，包括个人博客的编译部署，docker hub 镜像中转工具 最后如果借用 GitHub Actions 的容器资源来做爬虫节点是不是也挺好，官方给的服务器资源配置也还不错，可以查看这个 引用资源 GitHub Actions 文档 用于公共存储库的 GitHub 托管的标准运行器 checkout peaceiris/actions-gh-pages GitHub 市场 docker-hub docker_image_pusher starter","link":"/tools/github-actions-example/index.html"},{"title":"JetBrains 全家桶破解","text":"前排说明 破解原理基于 Gitee 上的一个开源插件 ja-netfilter，博主写这篇文章的目的并非倡导破解，该插件博主并未参与开发，仅仅作为一个使用者 截止到 2024年04月06日，博主目前使用的版本如下，实测有效可用，但并非是最新版本，至于其他版本是否支持，博主并未测试 ide 使用版本 IntelliJ IDEA 2023.3.6 WebStorm 2023.2.6 GoLand 2023.2.6 DataGrip 2023.2.3 破解需要 ja-netfilter 插件，以及当前还可用的激活码(需要激活第一次，以后便不需要了) 插件作者的使用教程可以参考这篇文章，本篇文章是基于插件作者的文章以及实际安装过程写给博主自己用的 文中仅仅介绍如何破解 JetBrains 家族的软件 演示环境基于博主的 MacOS 操作步骤 下载破解插件 ja-netfilter，文件的名称是 ja-netfilter-2022.2.0.zip 解压后的文件结构如下，ja-netfilter.jar所在的磁盘路径需要记下来（比如在我的电脑上是 /Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar） 123456789101112131415.├── README.pdf├── config│ ├── dns.conf│ ├── native.conf│ ├── power.conf│ └── url.conf├── ja-netfilter.jar├── plugins│ ├── dns.jar│ ├── hideme.jar│ ├── native.jar│ ├── power.jar│ └── url.jar└── sha1sum.txt 修改 config/dns.conf 配置文件，替换成以下内容即可 12[DNS]EQUAL,jetbrains.com 修改 config/url.conf 配置文件，替换成以下内容即可 12[URL]PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action 修改 JetBrains 各个 ide 的配置文件，配置文件的后缀都是 .vmoptions ide 对应的 vmoptions 配置文件名称 可能存在的路径 IntelliJ IDEA idea.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/IntelliJIdea[具体版本号]/idea.vmoptions WebStorm webstorm.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/WebStorm[具体版本号]/webstorm.vmoptions GoLand goland.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/GoLand[具体版本号]/goland.vmoptions DataGrip datagrip.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/DataGrip[具体版本号]/datagrip.vmoptions 其他方式：又或者此刻你还能打开 ide 正常使用，通过在 ide 中找到 Help -&gt; Edit Custom VM Options 也能在 ide 中打开此配置文件 在 .vmoptions 中加入以下配置 1234# 激活-javaagent:[ja-netfilter.jar 所在的绝对路径]--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 以我的电脑上ja-netfilter.jar 所在的绝对路径是 /Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar 为例，最后需要添加的配置如下 1234# 激活-javaagent:/Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 启动 ide，输入 Activation code 激活，后续即便现在所使用的激活码失效，也不需要再次激活 关于激活码，ja-netfilter 插件作者的文章中提到了热心大佬的key。博主自己试过好几个倒是都无效 博主目前的解决方案是在taobao购买了一个激活码用于第一次激活","link":"/tools/jetbrains-active/index.html"},{"title":"VisualVM 远程连接","text":"VisualVM 远程连接简介 VisualVM is a visual tool integrating commandline JDK tools and lightweight profiling capabilities.Designed for both development and production time use.谷歌翻译：VisualVM 是一个集成了命令行 JDK 工具和轻量级分析功能的可视化工具。 专为开发和生产时间使用而设计。 服务端jstatd 授权文件 - jstatd.all.policyjdk8123grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; { permission java.security.AllPermission;}; jdk9+1234567grant codebase &quot;jrt:/jdk.jstatd&quot; { permission java.security.AllPermission;};grant codebase &quot;jrt:/jdk.internal.jvmstat&quot; { permission java.security.AllPermission;}; 启动 jstatd tool12# -p 指定使用的端口，默认使用的是 1099 端口jstatd -J-Djava.security.policy=&lt;jstatd.all.policy文件的路径&gt;/jstatd.all.policy -J-Djava.rmi.server.hostname=&lt;对外暴露的主机ip&gt; -p 1099 开放端口 1099 端口：jstatd 工具默认使用的是 1099 端口 其他：jstatd 工具还会使用一个端口，需要在运行期间查询获的。可通过 netstat 指令查询获取 1234&gt; netstat -tanp | grep jstatdtcp6 0 0 :::1099 :::* LISTEN 4046836/jstatd tcp6 0 0 :::40499 :::* LISTEN 4046836/jstatd tcp6 0 0 xx.xx.xx.xx:40499 xx.xx.xx.xx:60082 ESTABLISHED 4046836/jstatd 那么除了 1099 端口以外，还需要开放 40499 端口 注意：40499 端口是在 jstatd 运行之后查询获得的，每次重启 jstatd 都可能会不一样 客户端安装 VisualVm12# mac 环境brew install visualvm 远程连接服务端 选择需要查看的 JVM 进程 查看 GC 情况 CPU 内存指标需要使用 JMX，使用 JMX 需要服务端的 JVM 应用开启相关配置","link":"/jvm/2024/02/VisualVM%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/index.html"},{"title":"2824. 统计和小于目标的下标对数目","text":"2824. 统计和小于目标的下标对数目 难度: easy 原始链接: https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target 标签: 排序, 二分 解法一: 枚举go123456789101112func countPairs(nums []int, target int) int { ans := 0 length := len(nums) for i := 0; i &lt; length; i++ { for j := i + 1; j &lt; length; j++ { if nums[i] + nums[j] &lt; target { ans++ } } } return ans} 解法二: 排序, 二分go1234567891011121314151617181920func countPairs(nums []int, target int) int { sort.Ints(nums) ans := 0 length := len(nums) for i := 0; i &lt; length; i++ { left := i right := length - 1 curTarget := target - nums[i] for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if nums[mid] &gt;= curTarget { right = mid - 1 } else { left = mid } } ans += left - i } return ans}","link":"/leetcode/2023/11/count-pairs-whose-sum-is-less-than-target/index.html"},{"title":"2316. 统计无向图中无法互相到达点对数","text":"2316. 统计无向图中无法互相到达点对数 难度: medium 原始链接: https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031func countPairs(n int, edges [][]int) int64 { grip := make([][]int, n) for i := 0; i &lt; n; i++ { grip[i] = []int{} } for _, edge := range edges { grip[edge[0]] = append(grip[edge[0]], edge[1]) grip[edge[1]] = append(grip[edge[1]], edge[0]) } visit := make([]bool, n) var ans int64 var total int64 for i := 0; i &lt; n; i++ { size := dfs(i, grip, visit) ans += size * total total += size } return ans}func dfs(num int, grip [][]int, visit []bool) int64 { if visit[num] { return 0 } visit[num] = true var size int64 = 1 for _, num2 := range grip[num] { size += dfs(num2, grip, visit) } return size}","link":"/leetcode/2023/11/count-unreachable-pairs-of-nodes-in-an-undirected-graph/index.html"},{"title":"1670. 设计前中后队列","text":"1670. 设计前中后队列 难度: medium 原始链接: https://leetcode.cn/problems/design-front-middle-back-queue 标签: 队列 解法一: 队列java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class FrontMiddleBackQueue { private Deque&lt;Integer&gt; leftDeque; private Deque&lt;Integer&gt; rightDeque; public FrontMiddleBackQueue() { this.leftDeque = new LinkedList&lt;&gt;(); this.rightDeque = new LinkedList&lt;&gt;(); } public void pushFront(int val) { leftDeque.addFirst(val); if (leftDeque.size() &gt; rightDeque.size() + 1) { rightDeque.addFirst(leftDeque.pollLast()); } } public void pushMiddle(int val) { if (leftDeque.size() &gt; rightDeque.size()) { rightDeque.addFirst(leftDeque.pollLast()); } leftDeque.addLast(val); } public void pushBack(int val) { rightDeque.addLast(val); if (rightDeque.size() &gt; leftDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } } public int popFront() { if (leftDeque.isEmpty()) { return -1; } Integer ans = leftDeque.pollFirst(); if (leftDeque.size() &lt; rightDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } return ans; } public int popMiddle() { if (leftDeque.isEmpty()) { return -1; } Integer ans = leftDeque.pollLast(); if (leftDeque.size() &lt; rightDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } return ans; } public int popBack() { if (rightDeque.isEmpty()) { if (leftDeque.isEmpty()) { return -1; } return leftDeque.pollLast(); } Integer ans = rightDeque.pollLast(); if (leftDeque.size() &gt; rightDeque.size() + 1) { rightDeque.addFirst(leftDeque.pollLast()); } return ans; } }/** * Your FrontMiddleBackQueue object will be instantiated and called as such: * FrontMiddleBackQueue obj = new FrontMiddleBackQueue(); * obj.pushFront(val); * obj.pushMiddle(val); * obj.pushBack(val); * int param_4 = obj.popFront(); * int param_5 = obj.popMiddle(); * int param_6 = obj.popBack(); */","link":"/leetcode/2023/11/design-front-middle-back-queue/index.html"},{"title":"1657. 确定两个字符串是否接近","text":"1657. 确定两个字符串是否接近 难度: medium 原始链接: https://leetcode.cn/problems/determine-if-two-strings-are-close 标签: 哈希计数 解法一: 哈希计数go1234567891011121314151617181920func closeStrings(word1 string, word2 string) bool { n := len(word1) if n != len(word2) { return false } counter := [2][26]int{} flags := [2]int{} for i := 0; i &lt; n; i++ { counter[0][word1[i] - 'a']++ counter[1][word2[i] - 'a']++ flags[0] |= 1 &lt;&lt; int(word1[i] - 'a') flags[1] |= 1 &lt;&lt; int(word2[i] - 'a') } if flags[0] != flags[1] { return false } sort.Ints(counter[0][:]) sort.Ints(counter[1][:]) return counter[0] == counter[1]}","link":"/leetcode/2023/11/determine-if-two-strings-are-close/index.html"},{"title":"1410. HTML 实体解析器","text":"1410. HTML 实体解析器 难度: medium 原始链接: https://leetcode.cn/problems/html-entity-parser 标签: 模拟 解法一: 模拟go123456789101112131415161718192021222324252627282930func entityParser(text string) string { n := len(text) sb := strings.Builder{} wordMap := map[string]string{ &quot;&amp;quot;&quot;: &quot;\\&quot;&quot;, &quot;&amp;apos;&quot;: &quot;'&quot;, &quot;&amp;amp;&quot;: &quot;&amp;&quot;, &quot;&amp;gt;&quot;: &quot;&gt;&quot;, &quot;&amp;lt;&quot;: &quot;&lt;&quot;, &quot;&amp;frasl;&quot;: &quot;/&quot;, } for i := 0; i &lt; n; { isReplace := false if text[i] == '&amp;' { for source, target := range wordMap { if i + len(source) &lt;= n &amp;&amp; text[i:i+len(source)] == source { sb.WriteString(target) i += len(source) isReplace = true break } } } if(!isReplace) { sb.WriteString(string(text[i])) i++ } } return sb.String()}","link":"/leetcode/2023/11/html-entity-parser/index.html"},{"title":"2342. 数位和相等数对的最大和","text":"2342. 数位和相等数对的最大和 难度: medium 原始链接: https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits 标签: 哈希, 贪心 解法一: 哈希, 贪心go1234567891011121314151617181920212223242526272829303132func maximumSum(nums []int) int { maxSumMap := make(map[int]int) ans := -1 for _, num := range nums { numSum := calcNumSum(num) if maxNum, exists := maxSumMap[numSum]; exists { if maxNum &lt; num { maxSumMap[numSum] = num } ans = max(ans, maxNum + num) } else { maxSumMap[numSum] = num } } return ans}func calcNumSum(num int) int { sum := 0 for num != 0 { sum += num % 10 num /= 10 } return sum}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/max-sum-of-a-pair-with-equal-sum-of-digits/index.html"},{"title":"2530. 执行 K 次操作后的最大分数","text":"2530. 执行 K 次操作后的最大分数 难度: medium 原始链接: https://leetcode.cn/problems/maximal-score-after-applying-k-operations 标签: 大根堆 解法一: 大根堆java123456789101112131415class Solution { public long maxKelements(int[] nums, int k) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); for (int num : nums) { priorityQueue.offer(num); } long ans = 0; for (int i = 0; i &lt; k; i++) { int num = priorityQueue.poll(); ans += num; priorityQueue.offer((num + 2) / 3); } return ans; }}","link":"/leetcode/2023/11/maximal-score-after-applying-k-operations/index.html"},{"title":"318. 最大单词长度乘积","text":"318. 最大单词长度乘积 难度: medium 原始链接: https://leetcode.cn/problems/maximum-product-of-word-lengths 标签: 位运算 解法一: 位运算go123456789101112131415161718192021222324252627func maxProduct(words []string) int { length := len(words) arr := make([]int, length) for i := 0; i &lt; length; i++ { num := 0 for _, word := range words[i] { num |= 1 &lt;&lt; int(word - 'a') } arr[i] = num } ans := 0 for i := 0; i &lt; length; i++ { for j := 0; j &lt; length; j++ { if arr[i] &amp; arr[j] == 0 { ans = max(ans, len(words[i]) * len(words[j])) } } } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/maximum-product-of-word-lengths/index.html"},{"title":"53. 最大子数组和","text":"53. 最大子数组和 难度: medium 原始链接: https://leetcode.cn/problems/maximum-subarray 标签: 动态规划, 分治法 解法一: 动态规划go12345678910111213141516func maxSubArray(nums []int) int { ans := nums[0] pre := nums[0] for _, num := range nums[1:] { pre = max(pre + num, num) ans = max(ans, pre) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2} 解法二: 分治法go12345678910111213141516171819202122232425262728293031323334353637383940414243func maxSubArray(nums []int) int { return dfs(nums, 0, len(nums) - 1)}func dfs(nums []int, left int, right int) int { if left == right { return nums[left] } mid := ((right - left) &gt;&gt; 1) + left leftSum := dfs(nums, left, mid) rightSum := dfs(nums, mid + 1, right) midSum := calcMidSubArray(nums, left, right, mid) return max(leftSum, max(rightSum, midSum))}func calcMidSubArray(nums []int, left, right, mid int) int { leftSum := -1000000000 sum := 0 for i := mid; i &gt;= left; i-- { sum += nums[i] if sum &gt; leftSum { leftSum = sum } } rightSum := -1000000000 sum = 0 for i := mid + 1; i &lt;= right; i++ { sum += nums[i] if sum &gt; rightSum { rightSum = sum } } return leftSum + rightSum}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/maximum-subarray/index.html"},{"title":"2216. 美化数组的最少删除数","text":"2216. 美化数组的最少删除数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful 标签: 模拟 解法一: 模拟go1234567891011121314func minDeletion(nums []int) int { count := 1 pre := nums[0] for _, num := range nums[1:] { if pre != num || pre == num &amp;&amp; (count &amp; 1) == 0 { count++ pre = num } } if (count &amp; 1) != 0 { return len(nums) - count + 1 } return len(nums) - count}","link":"/leetcode/2023/11/minimum-deletions-to-make-array-beautiful/index.html"},{"title":"2304. 网格中的最小路径代价","text":"2304. 网格中的最小路径代价 难度: medium 原始链接: https://leetcode.cn/problems/minimum-path-cost-in-a-grid 标签: 动态规划 解法一: 递归go1234567891011121314151617181920212223242526272829303132333435func minPathCost(grid [][]int, moveCost [][]int) int { m := len(grid) n := len(grid[0]) ans := math.MaxInt visits := make([][]int, m) for i := 0; i &lt; m; i++ { visits[i] = make([]int, n) } for i := 0; i &lt; n; i++ { ans = min(ans, dfs(grid, moveCost, visits, 0, i, m, n)) } return ans}func dfs(grid [][]int, moveCost [][]int, visits [][]int, i, j, m, n int) int { if visits[i][j] != 0 { return visits[i][j] } if i == m - 1 { return grid[i][j] } minVal := math.MaxInt for k := 0; k &lt; n; k++ { minVal = min(minVal, dfs(grid, moveCost, visits, i + 1, k, m, n) + moveCost[grid[i][j]][k]) } visits[i][j] = grid[i][j] + minVal return visits[i][j]}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2} 解法二: 迭代go123456789101112131415161718192021222324252627282930313233func minPathCost(grid [][]int, moveCost [][]int) int { m := len(grid) n := len(grid[0]) arr := [][]int{ make([]int, n), make([]int, n), } for i := 0; i &lt; n; i++ { arr[0][i] = grid[0][i] } for i := 1; i &lt; m; i++ { for j := 0; j &lt; n; j++ { minVal := math.MaxInt for k := 0; k &lt; n; k++ { minVal = min(minVal, arr[0][k] + moveCost[grid[i - 1][k]][j]) } arr[1][j] = minVal + grid[i][j] } arr[0], arr[1] = arr[1], arr[0] } ans := math.MaxInt for _, num := range arr[0] { ans = min(ans, num) } return ans}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/minimum-path-cost-in-a-grid/index.html"},{"title":"1155. 掷骰子等于目标和的方法数","text":"1155. 掷骰子等于目标和的方法数 难度: medium 原始链接: https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum 标签: 动态规划 解法一: 动态规划go12345678910111213141516func numRollsToTarget(n int, k int, target int) int { pre := make([]int, target + 1) pre[0] = 1 for i := 1; i &lt;= n; i++ { cur := make([]int, target + 1) for j := 0; j &lt;= target; j++ { for x := 1; x &lt;= k; x++ { if j &gt;= x { cur[j] = (cur[j] + pre[j - x]) % (1e9 + 7) } } } pre = cur } return pre[target]}","link":"/leetcode/2023/11/number-of-dice-rolls-with-target-sum/index.html"},{"title":"117. 填充每个节点的下一个右侧节点指针 II","text":"117. 填充每个节点的下一个右侧节点指针 II 难度: medium 原始链接: https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii 标签: bfs 解法一: bfsgo1234567891011121314151617181920212223242526272829303132333435/** * Definition for a Node. * type Node struct { * Val int * Left *Node * Right *Node * Next *Node * } */func connect(root *Node) *Node { if root == nil { return nil } queue := []*Node{root} for len(queue) &gt; 0 { length := len(queue) var pre *Node for i := 0; i &lt; length; i++ { node := queue[i] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } if i &gt; 0 { pre.Next = node } pre = node } queue = queue[length:] } return root} 解法二: 利用 Next 指针go123456789101112131415161718192021222324252627282930313233/** * Definition for a Node. * type Node struct { * Val int * Left *Node * Right *Node * Next *Node * } */func connect(root *Node) *Node { if root == nil { return nil } cur := root for cur != nil { linkNodeRoot := &amp;Node{Val: -1} curLinkNode := linkNodeRoot for cur != nil { if cur.Left != nil { curLinkNode.Next = cur.Left curLinkNode = curLinkNode.Next } if cur.Right != nil { curLinkNode.Next = cur.Right curLinkNode = curLinkNode.Next } cur = cur.Next } cur = linkNodeRoot.Next } return root}","link":"/leetcode/2023/11/populating-next-right-pointers-in-each-node-ii/index.html"},{"title":"1457. 二叉树中的伪回文路径","text":"1457. 二叉树中的伪回文路径 难度: medium 原始链接: https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree 标签: dfs 解法一: dfsgo1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func pseudoPalindromicPaths (root *TreeNode) int { flag := 0 var dfs func(node *TreeNode) int dfs = func(node *TreeNode) int { if node == nil { return 0 } count := 0 flag ^= 1 &lt;&lt; node.Val if node.Left == nil &amp;&amp; node.Right == nil { if flag == 0 || (flag &amp; (flag - 1)) == 0 { count = 1 } } else { count = dfs(node.Left) + dfs(node.Right) } flag ^= 1 &lt;&lt; node.Val return count } return dfs(root)}","link":"/leetcode/2023/11/pseudo-palindromic-paths-in-a-binary-tree/index.html"},{"title":"307. 区域和检索 - 数组可修改","text":"307. 区域和检索 - 数组可修改 难度: medium 原始链接: https://leetcode.cn/problems/range-sum-query-mutable 标签: 线段树 解法一: 线段树go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879type NumArray struct { leftNumArray *NumArray rightNumArray *NumArray left int right int sum int}func Constructor(nums []int) NumArray { return *dfs(nums, 0, len(nums) - 1)}func dfs(nums []int, left, right int) *NumArray { if left == right { return &amp;NumArray{ leftNumArray: nil, rightNumArray: nil, left: left, right: right, sum: nums[left], } } mid := ((right - left) &gt;&gt; 1) + left leftNumArray := dfs(nums, left, mid) rightNumArray := dfs(nums, mid + 1, right) return &amp;NumArray{ leftNumArray: leftNumArray, rightNumArray: rightNumArray, left: left, right: right, sum: leftNumArray.sum + rightNumArray.sum, }}func queryRange(numArray *NumArray, left, right int) int { if numArray.left == left &amp;&amp; numArray.right == right { return numArray.sum } mid := ((numArray.right - numArray.left) &gt;&gt; 1) + numArray.left if left &gt; mid { return queryRange(numArray.rightNumArray, left, right) } else if right &lt;= mid { return queryRange(numArray.leftNumArray, left, right) } return queryRange(numArray.leftNumArray, left, mid) + queryRange(numArray.rightNumArray, mid + 1, right)}func updateRange(numArray *NumArray, left, right, val int) *NumArray { if numArray.left == numArray.right &amp;&amp; numArray.left == left { numArray.sum = val return numArray } mid := ((numArray.right - numArray.left) &gt;&gt; 1) + numArray.left if left &gt; mid { updateRange(numArray.rightNumArray, left, right, val) } else if right &lt;= mid { updateRange(numArray.leftNumArray, left, right, val) } else { updateRange(numArray.leftNumArray, left, mid, val) updateRange(numArray.rightNumArray, mid + 1, right, val) } numArray.sum = numArray.leftNumArray.sum + numArray.rightNumArray.sum return numArray}func (this *NumArray) Update(index int, val int) { updateRange(this, index, index, val)}func (this *NumArray) SumRange(left int, right int) int { return queryRange(this, left, right)}/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * obj.Update(index,val); * param_2 := obj.SumRange(left,right); */","link":"/leetcode/2023/11/range-sum-query-mutable/index.html"},{"title":"187. 重复的DNA序列","text":"187. 重复的DNA序列 难度: medium 原始链接: https://leetcode.cn/problems/repeated-dna-sequences 标签: 哈希, 位运算 解法一: 哈希go12345678910111213141516171819202122func findRepeatedDnaSequences(s string) []string { length := len(s) if length &lt; 10 { return []string{} } hash := map[string]int{} str := &quot;0&quot; ans := []string{} for i := 0; i &lt; length; i++ { for len(str) &lt; 10 { str += string(s[i]) i++ } str += string(s[i]) str = str[1:] if hash[str] == 1 { ans = append(ans, str) } hash[str]++ } return ans} 解法二: 位运算go1234567891011121314151617181920212223242526272829303132func findRepeatedDnaSequences(s string) []string { length := len(s) if length &lt; 10 { return []string{} } num := 0 dict := map[byte]int{ 'A': 0, 'C': 1, 'G': 2, 'T': 3, } for i := 0; i &lt; 10; i++ { num = (num &lt;&lt; 2) | dict[s[i]] } hash := map[int]int{ num: 1, } ans := []string{} for i := 10; i &lt; length; i++ { num = ((num &lt;&lt; 2) | dict[s[i]]) &amp; ((1 &lt;&lt; 20) - 1) if hash[num] == 1 { sb := strings.Builder{} for j := i - 9; j &lt;= i; j++ { sb.WriteString(string(s[j])) } ans = append(ans, sb.String()) } hash[num]++ } return ans}","link":"/leetcode/2023/11/repeated-dna-sequences/index.html"},{"title":"2103. 环和杆","text":"2103. 环和杆 难度: easy 原始链接: https://leetcode.cn/problems/rings-and-rods 标签: 位运算 解法一: 位运算go1234567891011121314151617181920212223func countPoints(rings string) int { flag := 0 length := len(rings) for i := 1; i &lt; length; i += 2 { shift := 0 if rings[i - 1] == 'R' { shift = 1 } else if rings[i - 1] == 'G' { shift = 1 &lt;&lt; 1 } else if rings[i - 1] == 'B' { shift = 1 &lt;&lt; 2 } flag |= shift &lt;&lt; (int(rings[i] - '0') * 3) } ans := 0 for flag != 0 { if (flag &amp; 7) == 7 { ans++ } flag &gt;&gt;= 3 } return ans}","link":"/leetcode/2023/11/rings-and-rods/index.html"},{"title":"260. 只出现一次的数字 III","text":"260. 只出现一次的数字 III 难度: medium 原始链接: https://leetcode.cn/problems/single-number-iii 标签: 位运算 解法一: 位运算go1234567891011121314func singleNumber(nums []int) []int { xor := 0 for _, num := range nums { xor ^= num } mask := xor &amp; ((^xor) + 1) num1 := 0 for _, num := range nums { if (num &amp; mask) != 0 { num1 ^= num } } return []int{num1, xor ^ num1}}","link":"/leetcode/2023/11/single-number-iii/index.html"},{"title":"2336. 无限集中的最小数字","text":"2336. 无限集中的最小数字 难度: medium 原始链接: https://leetcode.cn/problems/smallest-number-in-infinite-set 标签: 有序哈希, 优先级队列 解法一: 有序哈希java123456789101112131415161718192021222324252627class SmallestInfiniteSet { private TreeSet&lt;Integer&gt; treeSet; public SmallestInfiniteSet() { treeSet = new TreeSet&lt;&gt;(); for (int i = 1; i &lt;= 1000; i++) { treeSet.add(i); } } public int popSmallest() { return treeSet.pollFirst(); } public void addBack(int num) { treeSet.add(num); } }/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 解法二: 优先级队列java1234567891011121314151617181920212223242526272829303132333435363738class SmallestInfiniteSet { private PriorityQueue&lt;Integer&gt; priorityQueue; private boolean[] exists; private int min; public SmallestInfiniteSet() { priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); min = 1; exists = new boolean[1001]; } public int popSmallest() { if (!priorityQueue.isEmpty() &amp;&amp; exists[priorityQueue.peek()]) { Integer ans = priorityQueue.poll(); exists[ans] = false; return ans; } return min++; } public void addBack(int num) { if (num &lt; min &amp;&amp; !exists[num]) { priorityQueue.offer(num); exists[num] = true; } }}/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */","link":"/leetcode/2023/11/smallest-number-in-infinite-set/index.html"},{"title":"2300. 咒语和药水的成功对数","text":"2300. 咒语和药水的成功对数 难度: medium 原始链接: https://leetcode.cn/problems/successful-pairs-of-spells-and-potions 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920212223func successfulPairs(spells []int, potions []int, success int64) []int { sort.Ints(potions) ans := make([]int, len(spells)) length := len(potions) for i, num := range spells { ans[i] = length - halfSearch(potions, int((success + int64(num) - 1) / int64(num))) } return ans}func halfSearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if nums[mid] &lt; target { left = mid + 1 } else { right = mid - 1 } } return left}","link":"/leetcode/2023/11/successful-pairs-of-spells-and-potions/index.html"},{"title":"2652. 倍数求和","text":"2652. 倍数求和 难度: easy 原始链接: https://leetcode.cn/problems/sum-multiples 标签: 模拟 解法一: 枚举go123456789func sumOfMultiples(n int) int { sum := 0 for i := 0; i &lt;= n; i++ { if i % 3 == 0 || i % 5 == 0 || i % 7 == 0 { sum += i } } return sum}","link":"/leetcode/2023/11/sum-multiples/index.html"},{"title":"907. 子数组的最小值之和","text":"907. 子数组的最小值之和 难度: medium 原始链接: https://leetcode.cn/problems/sum-of-subarray-minimums 标签: 单调栈 解法一: 单调栈go123456789101112131415161718192021222324252627282930313233343536func sumSubarrayMins(arr []int) int { n := len(arr) leftArr := make([]int, n) queue := []int{} for i, num := range arr { for len(queue) &gt; 0 &amp;&amp; arr[queue[len(queue) - 1]] &gt; num { queue = queue[:len(queue) - 1] } if len(queue) == 0 { leftArr[i] = -1 } else { leftArr[i] = queue[len(queue) - 1] } queue = append(queue, i) } rightArr := make([]int, n) queue = []int{} for i := n - 1; i &gt;= 0; i-- { num := arr[i] for len(queue) &gt; 0 &amp;&amp; arr[queue[len(queue) - 1]] &gt;= num { queue = queue[:len(queue) - 1] } if len(queue) == 0 { rightArr[i] = n } else { rightArr[i] = queue[len(queue) - 1] } queue = append(queue, i) } ans := 0 const MOD = 1000000007 for i, num := range arr { ans = (ans + num * (i - leftArr[i]) * (rightArr[i] - i)) % MOD } return ans}","link":"/leetcode/2023/11/sum-of-subarray-minimums/index.html"},{"title":"1726. 同积元组","text":"1726. 同积元组 难度: medium 原始链接: https://leetcode.cn/problems/tuple-with-same-product 标签: 哈希, 数学 解法一: 哈希, 数学go1234567891011121314func tupleSameProduct(nums []int) int { mulMap := make(map[int]int) length := len(nums) for i := 0; i &lt; length; i++ { for j := i + 1; j &lt; length; j++ { mulMap[nums[i] * nums[j]]++ } } ans := 0 for _, count := range mulMap { ans += count * (count - 1) * 4 } return ans}","link":"/leetcode/2023/11/tuple-with-same-product/index.html"},{"title":"1038. 从二叉搜索树到更大和树","text":"1038. 从二叉搜索树到更大和树 难度: medium 原始链接: https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree 标签: 中序遍历 解法一: 中序遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func bstToGst(root *TreeNode) *TreeNode { var dfs func (node *TreeNode, sum int) int dfs = func (node *TreeNode, sum int) int { if node == nil { return sum } node.Val += dfs(node.Right, sum) return dfs(node.Left, node.Val) } dfs(root, 0) return root}","link":"/leetcode/2023/12/binary-search-tree-to-greater-sum-tree/index.html"},{"title":"2706. 购买两块巧克力","text":"2706. 购买两块巧克力 难度: easy 原始链接: https://leetcode.cn/problems/buy-two-chocolates 标签: 一次遍历 解法一: 一次遍历go12345678910111213141516func buyChoco(prices []int, money int) int { first := 100 second := 100 for _, price := range prices { if first &gt; price { second = first first = price } else if second &gt; price { second = price } } if first + second &gt; money { return money } return money - first - second}","link":"/leetcode/2023/12/buy-two-chocolates/index.html"},{"title":"1094. 拼车","text":"1094. 拼车 难度: medium 原始链接: https://leetcode.cn/problems/car-pooling 标签: 堆排序, 差分数组 解法一: 堆排序java123456789101112131415161718class Solution { public boolean carPooling(int[][] trips, int capacity) { Arrays.sort(trips, (arr1, arr2) -&gt; arr1[1] - arr2[1]); PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr1[2] - arr2[2]); int peopleCount = 0; for (int[] trip : trips) { while (!priorityQueue.isEmpty() &amp;&amp; trip[1] &gt;= priorityQueue.peek()[2]) { peopleCount -= priorityQueue.poll()[0]; } priorityQueue.offer(trip); peopleCount += trip[0]; if (peopleCount &gt; capacity) { return false; } } return true; }} 解法二: 差分数组go123456789101112131415func carPooling(trips [][]int, capacity int) bool { arr := make([]int, 1001) for _, trip := range trips { arr[trip[1]] += trip[0] arr[trip[2]] -= trip[0] } sum := 0 for _, num := range arr { sum += num if sum &gt; capacity { return false } } return true}","link":"/leetcode/2023/12/car-pooling/index.html"},{"title":"2828. 判别首字母缩略词","text":"2828. 判别首字母缩略词 难度: easy 原始链接: https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words 标签: 模拟 解法一: 朴素模拟go1234567891011func isAcronym(words []string, s string) bool { if len(words) != len(s) { return false } for i, word := range words { if word[0] != s[i] { return false } } return true} 解法二: java 一行java1234567class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { return Objects.equals(words.stream() .map(word -&gt; String.valueOf(word.charAt(0))) .collect(Collectors.joining()), s); }}","link":"/leetcode/2023/12/check-if-a-string-is-an-acronym-of-words/index.html"},{"title":"70. 爬楼梯","text":"70. 爬楼梯 难度: easy 原始链接: https://leetcode.cn/problems/climbing-stairs 标签: 动态规划 解法一: 动态规划: O(n) 空间复杂度go123456789101112func climbStairs(n int) int { if n == 1 { return 1 } dp := make([]int, n + 1) dp[1] = 1 dp[2] = 2 for i := 3; i &lt;= n; i++ { dp[i] = dp[i - 2] + dp[i - 1] } return dp[n]} 解法二: 动态规划: O(1) 空间复杂度go1234567891011func climbStairs(n int) int { if n == 1 { return 1 } i1 := 1 i2 := 2 for i := 3; i &lt;= n; i++ { i1, i2 = i2, i1 + i2 } return i2}","link":"/leetcode/2023/12/climbing-stairs/index.html"},{"title":"1185. 一周中的第几天","text":"1185. 一周中的第几天层 难度: easy 原始链接: https://leetcode.cn/problems/day-of-the-week 标签: 模拟 解法一: 按年份一次计算go123456789101112131415161718192021222324func dayOfTheWeek(day int, month int, year int) string { daySum := 0 for i := 1970; i &lt; year; i++ { if isLeep(i) { daySum += 366 } else { daySum += 365 } } months := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} for i := 1; i &lt; month; i++ { daySum += months[i - 1] } if month &gt; 2 &amp;&amp; isLeep(year) { daySum++ } daySum += day days := []string{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;} return days[(daySum + 3) % 7]}func isLeep(year int) bool { return (year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0))} 解法二: 日期工具类java1234567class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] weeks = {&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; LocalDate date = LocalDate.of(year, month, day); return weeks[date.getDayOfWeek().getValue() - 1]; }}","link":"/leetcode/2023/12/day-of-the-week/index.html"},{"title":"1154. 一年中的第几天","text":"1154. 一年中的第几天 难度: easy 原始链接: https://leetcode.cn/problems/day-of-the-year 标签: 直接计算 解法一: 直接计算go123456789101112131415161718func dayOfYear(date string) int { year, _ := strconv.Atoi(date[:4]) month, _ := strconv.Atoi(date[5:7]) day, _ := strconv.Atoi(date[8:]) months := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} daySum := 0 for i := 1; i &lt; month; i++ { daySum += months[i - 1] } if month &gt; 2 &amp;&amp; isLeep(year) { daySum++ } return daySum + day}func isLeep(year int) bool { return (year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0))}","link":"/leetcode/2023/12/day-of-the-year/index.html"},{"title":"2660. 保龄球游戏的获胜者","text":"2660. 保龄球游戏的获胜者 难度: easy 原始链接: https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game 标签: 模拟 解法一: 模拟go1234567891011121314151617181920212223242526func isWinner(player1 []int, player2 []int) int { player1Score := calcScore(player1) player2Score := calcScore(player2) if player1Score == player2Score { return 0 } else if player1Score &gt; player2Score { return 1 } return 2}func calcScore(player []int) int { sum := 0 counter := 0 for _, score := range player { sum += score if counter &gt; 0 { counter-- sum += score } if score == 10 { counter = 2 } } return sum}","link":"/leetcode/2023/12/determine-the-winner-of-a-bowling-game/index.html"},{"title":"1901. 寻找峰值 II","text":"1901. 寻找峰值 II 难度: medium 原始链接: https://leetcode.cn/problems/find-a-peak-element-ii 标签: 二分查找 解法一: 暴力go123456789101112131415func findPeakGrid(mat [][]int) []int { m := len(mat) n := len(mat[0]) for r := 0; r &lt; m; r++ { for c := 0; c &lt; n; c++ { if (r == 0 || mat[r][c] &gt; mat[r - 1][c]) &amp;&amp; (r == m - 1 || mat[r][c] &gt; mat[r + 1][c]) &amp;&amp; (c == 0 || mat[r][c] &gt; mat[r][c - 1]) &amp;&amp; (c == n - 1 || mat[r][c] &gt; mat[r][c + 1]) { return []int{r, c} } } } return []int{}} 解法二: 二分查找go12345678910111213141516171819202122232425func findPeakGrid(mat [][]int) []int { m := len(mat) left := 0 right := m - 1 for left &lt; right { mid := ((right - left) &gt;&gt; 1) + left i := maxIndex(mat[mid]) if mat[mid][i] &lt; mat[mid + 1][i] { left = mid + 1 } else { right = mid } } return []int{left, maxIndex(mat[left])}}func maxIndex(nums []int) int { ans := 0 for i, num := range nums { if nums[ans] &lt; num { ans = i } } return ans}","link":"/leetcode/2023/12/find-a-peak-element-ii/index.html"},{"title":"162. 寻找峰值","text":"162. 寻找峰值 难度: medium 原始链接: https://leetcode.cn/problems/find-peak-element 标签: 二分查找 解法一: 半分查找go12345678910111213func findPeakElement(nums []int) int { left := 0 right := len(nums) - 1 for left &lt; right { mid := ((right - left) &gt;&gt; 1) + left if nums[mid] &lt; nums[mid + 1] { left = mid + 1 } else { right = mid } } return left}","link":"/leetcode/2023/12/find-peak-element/index.html"},{"title":"2661. 找出叠涂元素","text":"2661. 找出叠涂元素 难度: medium 原始链接: https://leetcode.cn/problems/first-completely-painted-row-or-column 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425262728func firstCompleteIndex(arr []int, mat [][]int) int { m := len(mat) n := len(mat[0]) type point struct { x int y int } hash := make([]point, m * n + 1) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { hash[mat[i][j]] = point{ x: i, y: j, } } } rows := make([]int, m) cols := make([]int, n) for i, num := range arr { r, c := hash[num].x, hash[num].y rows[r]++ cols[c]++ if rows[r] == n || cols[c] == m { return i } } return -1}","link":"/leetcode/2023/12/first-completely-painted-row-or-column/index.html"},{"title":"2697. 字典序最小回文串","text":"2697. 字典序最小回文串 难度: easy 原始链接: https://leetcode.cn/problems/lexicographically-smallest-palindrome 标签: 双指针 解法一: go 双指针go123456789101112131415func makeSmallestPalindrome(s string) string { bytes := []byte(s) left := 0 right := len(s) - 1 for left &lt; right { if bytes[left] &lt;= bytes[right] { bytes[right] = bytes[left] } else { bytes[left] = bytes[right] } left++ right-- } return string(bytes)} 解法二: java 一行代码java1234567class Solution { public String makeSmallestPalindrome(String s) { return IntStream.range(0, s.length()) .mapToObj(i -&gt; String.valueOf((char) Math.min(s.charAt(i), s.charAt(s.length() - i - 1)))) .collect(Collectors.joining()); }}","link":"/leetcode/2023/12/lexicographically-smallest-palindrome/index.html"},{"title":"2008. 出租车的最大盈利","text":"2008. 出租车的最大盈利 难度: medium 原始链接: https://leetcode.cn/problems/maximum-earnings-from-taxi 标签: 二分查找 解法一: 二分查找go123456789101112131415161718192021222324252627func maxTaxiEarnings(n int, rides [][]int) int64 { sort.Slice(rides, func (i, j int) bool { return rides[i][1] &lt; rides[j][1] }) dp := make([]int64, len(rides) + 1) for i, ride := range rides { start := ride[0] end := ride[1] tip := ride[2] j := halfSearch(rides, i, start) dp[i + 1] = max(dp[i], dp[j] + int64(end - start + tip)) } return dp[len(rides)]}func halfSearch(rides [][]int, right, target int) int { left := 0 for left &lt;= right { mid := ((right - left + 1) &gt;&gt; 1) + left if rides[mid][1] &lt;= target { left = mid + 1 } else { right = mid - 1 } } return left}","link":"/leetcode/2023/12/maximum-earnings-from-taxi/index.html"},{"title":"1423. 可获得的最大点数","text":"1423. 可获得的最大点数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards 标签: 滑动窗口 解法一: 正向计算go1234567891011121314151617181920212223242526func maxScore(cardPoints []int, k int) int { left := 0 sum := 0 for left &lt; k { sum += cardPoints[left] left++ } left-- right := len(cardPoints) - 1 ans := sum for i := 0; i &lt; k; i++ { sum -= cardPoints[left] sum += cardPoints[right] left-- right-- ans = max(ans, sum) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2} 解法二: 反向计算go123456789101112131415161718192021222324func maxScore(cardPoints []int, k int) int { allSum := 0 sum := 0 n := len(cardPoints) m := n - k for i := 0; i &lt; m; i++ { allSum += cardPoints[i] sum += cardPoints[i] } curMin := sum for i := m; i &lt; n; i++ { sum += cardPoints[i] - cardPoints[i - m] curMin = min(curMin, sum) allSum += cardPoints[i] } return allSum - curMin}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/12/maximum-points-you-can-obtain-from-cards/index.html"},{"title":"746. 使用最小花费爬楼梯","text":"746. 使用最小花费爬楼梯 难度: easy 原始链接: https://leetcode.cn/problems/min-cost-climbing-stairs 标签: 动态规划 解法一: 动态规划: O(n) 空间复杂度go1234567891011121314151617func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n) dp[0] = cost[0] dp[1] = cost[1] for i := 2; i &lt; n; i++ { dp[i] = cost[i] + min(dp[i - 1], dp[i - 2]) } return min(dp[n - 2], dp[n - 1])}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2} 解法二: 动态规划: O(1) 空间复杂度go12345678910111213141516func minCostClimbingStairs(cost []int) int { n := len(cost) cost1 := cost[0] cost2 := cost[1] for i := 2; i &lt; n; i++ { cost1, cost2 = cost2, cost[i] + min(cost1, cost2) } return min(cost1, cost2)}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/12/min-cost-climbing-stairs/index.html"},{"title":"2477. 到达首都的最少油耗","text":"2477. 到达首都的最少油耗 难度: medium 原始链接: https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital 标签: 贪心, 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223func minimumFuelCost(roads [][]int, seats int) int64 { n := len(roads) trees := make([][]int, n + 1) for _, road := range roads { trees[road[0]] = append(trees[road[0]], road[1]) trees[road[1]] = append(trees[road[1]], road[0]) } var ans int64 = 0 var dfs func (son, parent int) int dfs = func (son, parent int) int { count := 0 for _, tree := range trees[son] { if tree != parent { curCount := dfs(tree, son) + 1 count += curCount ans += int64((curCount + seats - 1) / seats) } } return count } dfs(0, -1) return ans}","link":"/leetcode/2023/12/minimum-fuel-cost-to-report-to-the-capital/index.html"},{"title":"1954. 收集足够苹果的最小花园周长","text":"1954. 收集足够苹果的最小花园周长 难度: medium 原始链接: https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples 标签: 数学 解法一: 数学go123456789func minimumPerimeter(neededApples int64) int64 { var d int64 var sum int64 for sum &lt; neededApples { d++ sum += 12 * d * d } return 8 * d}","link":"/leetcode/2023/12/minimum-garden-perimeter-to-collect-enough-apples/index.html"},{"title":"2454. 下一个更大元素 IV","text":"2454. 下一个更大元素 IV 难度: hard 原始链接: https://leetcode.cn/problems/next-greater-element-iv 标签: 单调栈 解法一: 单调栈go12345678910111213141516171819202122func secondGreaterElement(nums []int) []int { length := len(nums) ans := make([]int, length) for i := 0; i &lt; length; i++ { ans[i] = -1 } list1 := []int{} list2 := []int{} for i, num := range nums { for len(list2) &gt; 0 &amp;&amp; nums[list2[len(list2) - 1]] &lt; num { ans[list2[len(list2) - 1]] = num list2 = list2[:len(list2) - 1] } pos := len(list1) - 1 for pos &gt;= 0 &amp;&amp; nums[list1[pos]] &lt; num { pos-- } list2 = append(list2, list1[pos + 1:]...) list1 = append(list1[:pos + 1], i) } return ans} 其他 “下一个更大元素”496. 下一个更大元素 Igo12345678910111213141516171819202122func nextGreaterElement(nums1 []int, nums2 []int) []int { stack := []int{} length2 := len(nums2) moreLargeArr := make(map[int]int, length2) for i := length2 - 1; i &gt;= 0; i-- { for len(stack) &gt; 0 &amp;&amp; stack[len(stack) - 1] &lt; nums2[i] { stack = stack[:len(stack) - 1] } if len(stack) == 0 { moreLargeArr[nums2[i]] = -1 } else { moreLargeArr[nums2[i]] = stack[len(stack) - 1] } stack = append(stack, nums2[i]) } length1 := len(nums1) ans := make([]int, length1) for i, num := range nums1 { ans[i] = moreLargeArr[num] } return ans} 503. 下一个更大元素 IIgo1234567891011121314151617func nextGreaterElements(nums []int) []int { stack := []int{} n := len(nums) doubleN := n &lt;&lt; 1 ans := make([]int, n) for i := 0; i &lt; n; i++ { ans[i] = -1 } for i := 0; i &lt; doubleN; i++ { for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack) - 1]] &lt; nums[i % n] { ans[stack[len(stack) - 1]] = nums[i % n] stack = stack[:len(stack) - 1] } stack = append(stack, i % n) } return ans} 556. 下一个更大元素 IIIgo1234567891011121314151617181920212223242526272829303132333435363738394041func nextGreaterElement(n int) int { nums := toArr(n) length := len(nums) for i := len(nums) - 2; i &gt;= 0; i-- { if nums[i] &lt; nums[i + 1] { sort.Ints(nums[i + 1:]) for j := i + 1; j &lt; length; j++ { if nums[i] &lt; nums[j] { nums[i], nums[j] = nums[j], nums[i] break } } maxMinNum := toNum(nums) if maxMinNum &lt;= math.MaxInt32 { return maxMinNum } break } } return -1}func toArr(n int) []int { arr := []int{} for n != 0 { arr = append(arr, n % 10) n /= 10 } for i, j := 0, len(arr) - 1; i &lt; j; i, j = i + 1, j - 1 { arr[i], arr[j] = arr[j], arr[i] } return arr}func toNum(nums []int) int { num := 0 for i := 0; i &lt; len(nums); i++ { num = num * 10 + nums[i] } return num}","link":"/leetcode/2023/12/next-greater-element-iv/index.html"},{"title":"2048. 下一个更大的数值平衡数","text":"2048. 下一个更大的数值平衡数 难度: medium 原始链接: https://leetcode.cn/problems/next-greater-numerically-balanced-number 标签: 枚举 解法一: 枚举go1234567891011121314151617181920212223242526func nextBeautifulNumber(n int) int { for i := n + 1; ; i++ { if isBeautifulNumber(i) { return i } } return -1}func isBeautifulNumber(num int) bool { countMark := make([]int, 8) for num != 0 { div := num % 10 if div &gt;= 8 || countMark[div] &gt;= div { return false } countMark[div]++ num /= 10 } for i, count := range countMark { if count &gt; 0 &amp;&amp; count != i { return false } } return true}","link":"/leetcode/2023/12/next-greater-numerically-balanced-number/index.html"},{"title":"1276. 不浪费原料的汉堡制作方案","text":"1276. 不浪费原料的汉堡制作方案 难度: medium 原始链接: https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients 标签: 二分查找 解法一: 二分查找go12345678910111213141516171819func numOfBurgers(tomatoSlices int, cheeseSlices int) []int { if (tomatoSlices &amp; 1) == 1 || (tomatoSlices &gt;&gt; 1) &lt; cheeseSlices || (tomatoSlices &gt;&gt; 2) &gt; cheeseSlices { return []int{} } left := 0 right := tomatoSlices &gt;&gt; 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left target := (mid &lt;&lt; 1) + ((cheeseSlices - mid) &lt;&lt; 2) if target == tomatoSlices { return []int{cheeseSlices - mid, mid} } else if target &gt; tomatoSlices { left = mid + 1 } else { right = mid - 1 } } return []int{}}","link":"/leetcode/2023/12/number-of-burgers-with-no-waste-of-ingredients/index.html"},{"title":"1631. 最小体力消耗路径","text":"1631. 最小体力消耗路径 难度: medium 原始链接: https://leetcode.cn/problems/path-with-minimum-effort 标签: 二分查找, 并查集 解法一: 二分查找go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func minimumEffortPath(heights [][]int) int { m := len(heights) n := len(heights[0]) directions := [][]int{ {0, -1}, {1, 0}, {0, 1}, {-1, 0}, } var dfs func (heights [][]int, visit []bool, r, c, limit int) bool dfs = func (heights [][]int, visit []bool, r, c, limit int) bool { if visit[r * n + c] { return false } if r == m - 1 &amp;&amp; c == n - 1 { return true } visit[r * n + c] = true ans := false for _, direction := range directions { newR := r + direction[0] newC := c + direction[1] if newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n &amp;&amp; abs(heights[newR][newC] - heights[r][c]) &lt;= limit { ans = ans || dfs(heights, visit, newR, newC, limit) } } return ans } left := 0 right := 1000000 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if dfs(heights, make([]bool, m * n), 0, 0, mid) { right = mid - 1 } else { left = mid + 1 } } return left}func abs(num int) int { if num &gt;= 0 { return num } return -num} 解法二: 并查集go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475func minimumEffortPath(heights [][]int) int { m := len(heights) n := len(heights[0]) edges := [][]int{} for r, height := range heights { for c, num := range height { if c + 1 &lt; n { edges = append(edges, []int{ abs(heights[r][c + 1] - num), r * n + c, r * n + c + 1, }) } if r + 1 &lt; m { edges = append(edges, []int{ abs(heights[r + 1][c] - num), r * n + c, (r + 1) * n + c, }) } } } sort.Slice(edges, func(i, j int) bool { return edges[i][0] &lt;= edges[j][0] }) unionFind := newConstruct(m * n) for _, edge := range edges { unionFind.union(edge[1], edge[2]) if unionFind.find(0) == unionFind.find(m * n - 1) { return edge[0] } } return 0}type UnionFind struct { parents []int}func newConstruct(n int) *UnionFind { parents := make([]int, n) for i := 0; i &lt; n; i++ { parents[i] = i } return &amp;UnionFind{ parents: parents, }}func (this *UnionFind) union(num1, num2 int) { parents := this.parents target1 := this.find(num1) target2 := this.find(num2) if target1 == target2 { return } parents[target1] = target2}func (this *UnionFind) find(num int) int { parents := this.parents if parents[num] == num { return num } return this.find(parents[num])}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2023/12/path-with-minimum-effort/index.html"},{"title":"1962. 移除石子使总数最小","text":"1962. 移除石子使总数最小 难度: medium 原始链接: https://leetcode.cn/problems/remove-stones-to-minimize-the-total 标签: 优先队列 解法一: 优先队列java12345678910111213141516class Solution { public int minStoneSum(int[] piles, int k) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); for (int pile : piles) { priorityQueue.offer(pile); } for (int i = 0; i &lt; k; i++) { priorityQueue.offer((priorityQueue.poll() + 1) &gt;&gt; 1); } int sum = 0; for (Integer num : priorityQueue) { sum += num; } return sum; }}","link":"/leetcode/2023/12/remove-stones-to-minimize-the-total/index.html"},{"title":"1466. 重新规划路线","text":"1466. 重新规划路线 难度: medium 原始链接: https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero 标签: dfs 解法一: dfsgo123456789101112131415161718192021222324252627282930func minReorder(n int, connections [][]int) int { roads := make([][]int, n) for _, connection := range connections { roads[connection[0]] = append(roads[connection[0]], -connection[1]) roads[connection[1]] = append(roads[connection[1]], connection[0]) } ans := 0 var dfs func (start, parent int) dfs = func (start, parent int) { for _, road := range roads[start] { if abs(road) == parent { continue } if road &lt; 0 { ans++ road = -road } dfs(road, start) } } dfs(0, 0) return ans}func abs(num int) int { if num &gt;= 0 { return num } return -num} java12345678910111213141516171819202122232425class Solution { public int minReorder(int n, int[][] connections) { List&lt;int[]&gt;[] roads = new ArrayList[n]; for (int i = 0; i &lt; n; i++) { roads[i] = new ArrayList&lt;&gt;(); } for (int[] connection : connections) { roads[connection[0]].add(new int[]{connection[1], 1}); roads[connection[1]].add(new int[]{connection[0], 0}); } return this.dfs(0, -1, roads); } private int dfs(int start, int parent, List&lt;int[]&gt;[] roads) { int ans = 0; for (int[] road : roads[start]) { if (road[0] == parent) { continue; } ans += road[1] + this.dfs(road[0], start, roads); } return ans; }}","link":"/leetcode/2023/12/reorder-routes-to-make-all-paths-lead-to-the-city-zero/index.html"},{"title":"2415. 反转二叉树的奇数层","text":"2415. 反转二叉树的奇数层 难度: medium 原始链接: https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func reverseOddLevels(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} isOdd := false for len(queue) &gt; 0 { size := len(queue) for i := 0; i &lt; size; i++ { if queue[i].Left != nil { queue = append(queue, queue[i].Left, queue[i].Right) } } if isOdd { left := 0 right := size - 1 for left &lt; right { queue[left].Val, queue[right].Val = queue[right].Val, queue[left].Val left++ right-- } } isOdd = !isOdd queue = queue[size:] } return root} 解法二: 深度优先遍历go1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func reverseOddLevels(root *TreeNode) *TreeNode { var dfs func (node1, node2 *TreeNode, isOdd bool) dfs = func (node1, node2 *TreeNode, isOdd bool) { if node1 == nil || node2 == nil { return } if isOdd { node1.Val, node2.Val = node2.Val, node1.Val } dfs(node1.Left, node2.Right, !isOdd) dfs(node1.Right, node2.Left, !isOdd) } dfs(root.Left, root.Right, true) return root}","link":"/leetcode/2023/12/reverse-odd-levels-of-binary-tree/index.html"},{"title":"2182. 构造限制重复的字符串","text":"2182. 构造限制重复的字符串 难度: medium 原始链接: https://leetcode.cn/problems/construct-string-with-repeat-limit 标签: 贪心, 大根堆 解法一: 贪心, 大根堆java1234567891011121314151617181920212223242526272829303132333435363738class Solution { public String repeatLimitedString(String s, int repeatLimit) { int n = s.length(); int[] wordCount = new int[26]; for (int i = 0; i &lt; n; i++) { wordCount[s.charAt(i) - 'a']++; } PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr2[1] - arr1[1]); for (int i = 0; i &lt; 26; i++) { if (wordCount[i] &gt; 0) { priorityQueue.offer(new int[] { wordCount[i], i }); } } StringBuffer sb = new StringBuffer(); while (!priorityQueue.isEmpty()) { int[] arr = priorityQueue.poll(); int count = Math.min(arr[0], repeatLimit); char ch = (char) (arr[1] + 'a'); for (int i = 0; i &lt; count; i++) { sb.append(ch); } if (arr[0] &gt; repeatLimit) { if (priorityQueue.isEmpty()) { break; } int[] arr2 = priorityQueue.poll(); sb.append((char) (arr2[1] + 'a')); if (arr2[0] &gt; 1) { arr2[0]--; priorityQueue.offer(arr2); } arr[0] -= repeatLimit; priorityQueue.offer(arr); } } return sb.toString(); }}","link":"/leetcode/2024/01/construct-string-with-repeat-limit/index.html"},{"title":"2085. 统计出现过一次的公共字符串","text":"2085. 统计出现过一次的公共字符串 难度: easy 原始链接: https://leetcode.cn/problems/count-common-words-with-one-occurrence 标签: 哈希 解法一: 双哈希go1234567891011121314151617func countWords(words1 []string, words2 []string) int { hash1 := make(map[string]int, len(words1)) hash2 := make(map[string]int, len(words2)) for _, word := range words1 { hash1[word]++ } for _, word := range words2 { hash2[word]++ } ans := 0 for word, count := range hash1 { if count == 1 &amp;&amp; hash2[word] == 1 { ans++ } } return ans} 解法二: 单哈希go12345678910111213141516171819func countWords(words1 []string, words2 []string) int { hash := make(map[string]int, len(words1)) for _, word := range words1 { hash[word]++ } ans := 0 for _, word := range words2 { if count, exists := hash[word]; exists { if count == 1 { ans++ hash[word] = -1 } else if count == -1 { ans-- delete(hash, word) } } } return ans}","link":"/leetcode/2024/01/count-common-words-with-one-occurrence/index.html"},{"title":"2707. 字符串中的额外字符","text":"2707. 字符串中的额外字符 难度: medium 原始链接: https://leetcode.cn/problems/extra-characters-in-a-string 标签: 动态规划, 前缀树 解法一: 动态规划java12345678910111213141516171819202122232425262728293031323334class Solution { public int minExtraChar(String s, String[] dictionary) { int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 1; for (String word : dictionary) { if (this.isSameFromLast(s, i, word)) { dp[i + 1] = Math.min(dp[i + 1], dp[i - word.length() + 1]); } } } return dp[n]; } private boolean isSameFromLast(String str, int endIndex, String subStr) { int n1 = str.length(); int n2 = subStr.length(); if (n2 &gt; endIndex + 1) { return false; } int i = endIndex; int j = n2 - 1; while (j &gt;= 0) { if (str.charAt(i) != subStr.charAt(j)) { return false; } i--; j--; } return true; }} 解法二: 前缀树java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { public static class Trie { private Trie[] tries; private boolean isEnd; public Trie() { this.tries = new Trie[26]; this.isEnd = false; } public void insert(String word) { int n = word.length(); Trie trie = this; for (int i = 0; i &lt; n; i++) { int j = word.charAt(i) - 'a'; if (trie.tries[j] == null) { trie.tries[j] = new Trie(); } trie = trie.tries[j]; } trie.isEnd = true; } public Trie track(char ch) { return tries[ch - 'a']; } public boolean isEnd() { return isEnd; } } public int minExtraChar(String s, String[] dictionary) { Trie root = new Trie(); for (String word : dictionary) { StringBuilder sb = new StringBuilder(word); root.insert(sb.reverse().toString()); } int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 1; Trie trie = root; for (int j = i; j &gt;= 0; j--) { trie = trie.track(s.charAt(j)); if (trie == null) { break; } if (trie.isEnd()) { dp[i + 1] = Math.min(dp[i + 1], dp[j]); } } } return dp[n]; }}","link":"/leetcode/2024/01/extra-characters-in-a-string/index.html"},{"title":"2744. 最大字符串配对数目","text":"2744. 最大字符串配对数目 难度: easy 原始链接: https://leetcode.cn/problems/find-maximum-number-of-string-pairs 标签: 哈希 解法一: 哈希go123456789101112131415161718192021func maximumNumberOfStringPairs(words []string) int { n := len(words) set := make(map[string]bool, n) ans := 0 for _, word := range words { if set[revertStr(word)] { ans++ } set[word] = true } return ans}func revertStr(str string) string { n := len(str) bytes := make([]byte, n) for i := 0; i &lt; n; i++ { bytes[i] = str[n - i - 1] } return string(bytes)}","link":"/leetcode/2024/01/find-maximum-number-of-string-pairs/index.html"},{"title":"2670. 找出不同元素数目差数组","text":"2670. 找出不同元素数目差数组 难度: easy 原始链接: https://leetcode.cn/problems/find-the-distinct-difference-array 标签: 哈希 解法一: 哈希go123456789101112131415161718func distinctDifferenceArray(nums []int) []int { leftCount := make(map[int]int) rightCount := make(map[int]int) for _, num := range nums { rightCount[num]++ } n := len(nums) ans := make([]int, n) for i, num := range nums { rightCount[num]-- if rightCount[num] == 0 { delete(rightCount, num) } leftCount[num]++ ans[i] = len(leftCount) - len(rightCount) } return ans}","link":"/leetcode/2024/01/find-the-distinct-difference-array/index.html"},{"title":"2807. 在链表中插入最大公约数","text":"2807. 在链表中插入最大公约数 难度: medium 原始链接: https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list 标签: 辗转相除法 解法一: 辗转相除法go1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func insertGreatestCommonDivisors(head *ListNode) *ListNode { first := head second := head.Next for second != nil { first.Next = &amp;ListNode{ Val: gcd(first.Val, second.Val), Next: second, } first, second = second, second.Next } return head}func gcd(num1, num2 int) int { for num2 != 0 { num1, num2 = num2, num1 % num2 } return num1}","link":"/leetcode/2024/01/insert-greatest-common-divisors-in-linked-list/index.html"},{"title":"2765. 最长交替子数组","text":"2765. 最长交替子数组 难度: easy 原始链接: https://leetcode.cn/problems/longest-alternating-subarray 标签: 双重循环 解法一: 双重循环go12345678910111213141516171819202122232425262728293031323334func alternatingSubarray(nums []int) int { n := len(nums) ans := -1 for i := 0; i &lt; n; i++ { ans = max(ans, maxAlternating(nums[i:])) } return ans}func maxAlternating(nums []int) int { n := len(nums) if n &lt;= 1 { return -1 } ans := 1 for i := 1; i &lt; n; i++ { if ((i&amp;1) == 0 &amp;&amp; nums[i] != nums[i-2]) || ((i&amp;1) == 1 &amp;&amp; nums[i] != nums[i-1]+1) { break } ans++ } if ans == 1 { return -1 } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/longest-alternating-subarray/index.html"},{"title":"2861. 最大合金数","text":"2861. 最大合金数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-alloys 标签: 二分查找 解法一: 二分查找go123456789101112131415161718192021222324252627282930313233343536373839404142func maxNumberOfAlloys(n int, k int, budget int, composition [][]int, stock []int, cost []int) int { ans := 0 for _, arr := range composition { left := 0 right := 200000000 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if isSuccess(mid, budget, arr, stock, cost) { left = mid } else { right = mid - 1 } } ans = max(ans, left) } return ans}func isSuccess(count, budget int, composition []int, stock []int, cost []int) bool { total := 0 for i, num := range composition { total += max(0, count*num-stock[i]) * cost[i] if total &gt; budget { return false } } return total &lt;= budget}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/maximum-number-of-alloys/index.html"},{"title":"1599. 经营摩天轮的最大利润","text":"1599. 经营摩天轮的最大利润 难度: medium 原始链接: https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel 标签: 模拟 解法一: 模拟go1234567891011121314151617181920212223242526272829func minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int { peopleSum := 0 curPeople := 0 i := 0 n := len(customers) curCost := 0 maxCost := 0 ans := -1 for i &lt; n || curPeople &lt; peopleSum { if i &lt; n { peopleSum += customers[i] } curPeople += min(4, peopleSum - curPeople) curCost = curPeople * boardingCost - (i + 1) * runningCost if maxCost &lt; curCost { maxCost = curCost ans = i + 1 } i++ } return ans}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/maximum-profit-of-operating-a-centennial-wheel/index.html"},{"title":"2397. 被列覆盖的最多行数","text":"2397. 被列覆盖的最多行数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-rows-covered-by-columns 标签: 回溯, 枚举 解法一: 回溯, 枚举java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int maximumRows(int[][] matrix, int numSelect) { List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); this.collectAllCombinations(0, numSelect, matrix[0].length, 0, 0, nums); List&lt;Integer&gt; rowBits = this.arrayRow2Bit(matrix); int ans = 0; for (Integer num : nums) { int count = 0; for (Integer rowBit : rowBits) { if ((num | rowBit) == num) { count++; } } ans = Math.max(ans, count); } return ans; } private List&lt;Integer&gt; arrayRow2Bit(int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int m = matrix.length; int n = matrix[0].length; for (int i = 0; i &lt; m; i++) { int num = 0; for (int j = 0; j &lt; n; j++) { if (matrix[i][j] == 1) { num |= 1 &lt;&lt; j; } } ans.add(num); } return ans; } private void collectAllCombinations(int start, int size, int n, int bitNum, int num, List&lt;Integer&gt; nums) { if (bitNum == size) { nums.add(num); return; } for (int i = start; i &lt; n; i++) { int numCopy = num; bitNum++; num |= 1 &lt;&lt; i; this.collectAllCombinations(i + 1, size, n, bitNum, num, nums); bitNum--; num = numCopy; } }}","link":"/leetcode/2024/01/maximum-rows-covered-by-columns/index.html"},{"title":"670. 最大交换","text":"670. 最大交换 难度: medium 原始链接: https://leetcode.cn/problems/maximum-swap 标签: 一次遍历 解法一: 一次遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243func maximumSwap(num int) int { numArr := toNumArr(num) n := len(numArr) maxIndex := n - 1 left := -1 right := -1 for i := n - 1; i &gt;= 0; i-- { if numArr[i] &gt; numArr[maxIndex] { maxIndex = i } else if numArr[i] &lt; numArr[maxIndex] { left = i right = maxIndex } } if left != -1 { numArr[left], numArr[right] = numArr[right], numArr[left] return toNum(numArr) } return num}func toNumArr(num int) []int { numArr := []int{} for num != 0 { numArr = append(numArr, num%10) num /= 10 } left, right := 0, len(numArr)-1 for left &lt; right { numArr[left], numArr[right] = numArr[right], numArr[left] left++ right-- } return numArr}func toNum(numArr []int) int { ans := 0 for _, num := range numArr { ans = ans*10 + num } return ans}","link":"/leetcode/2024/01/maximum-swap/index.html"},{"title":"2645. 构造有效字符串的最少插入数","text":"2645. 构造有效字符串的最少插入数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-additions-to-make-valid-string 标签: 动态规划, 模拟 解法一: 模拟go123456789101112131415func addMinimum(word string) int { insertList := [][]int{ {2, 0, 1}, {1, 2, 0}, {0, 1, 2}, } word += &quot;a&quot; pre := 'c' ans := 0 for _, ch := range word { ans += insertList[pre - 'a'][ch - 'a'] pre = ch } return ans} 解法二: 动态规划java12345678910111213class Solution { public int addMinimum(String word) { int n = word.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 2; if (i &gt; 0 &amp;&amp; word.charAt(i) &gt; word.charAt(i - 1)) { dp[i + 1] = dp[i] - 1; } } return dp[n]; }} 解法三: 计数组数java123456789101112class Solution { public int addMinimum(String word) { int n = word.length(); int count = 1; for (int i = 1; i &lt; n; i++) { if (word.charAt(i) &lt;= word.charAt(i - 1)) { count++; } } return count * 3 - n; }}","link":"/leetcode/2024/01/minimum-additions-to-make-valid-string/index.html"},{"title":"2808. 使循环数组所有元素相等的最少秒数","text":"2808. 使循环数组所有元素相等的最少秒数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425262728293031func minimumSeconds(nums []int) int { listMap := make(map[int][]int) for i, num := range nums { listMap[num] = append(listMap[num], i) } n := len(nums) ans := n for _, list := range listMap { n2 := len(list) distance := list[0] + n - list[n2-1] for i := 1; i &lt; n2; i++ { distance = max(distance, list[i]-list[i-1]) } ans = min(ans, distance&gt;&gt;1) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/minimum-seconds-to-equalize-a-circular-array/index.html"},{"title":"2696. 删除子串后的字符串最小长度","text":"2696. 删除子串后的字符串最小长度 难度: easy 原始链接: https://leetcode.cn/problems/minimum-string-length-after-removing-substrings 标签: 栈 解法一: 栈go123456789101112func minLength(s string) int { stack := []byte{} n := len(s) for i := 0; i &lt; n; i++ { if len(stack) &gt; 0 &amp;&amp; (s[i] == 'B' &amp;&amp; stack[len(stack) - 1] == 'A' || s[i] == 'D' &amp;&amp; stack[len(stack) - 1] == 'C') { stack = stack[:len(stack) - 1] } else { stack = append(stack, s[i]) } } return len(stack)}","link":"/leetcode/2024/01/minimum-string-length-after-removing-substrings/index.html"},{"title":"447. 回旋镖的数量","text":"447. 回旋镖的数量 难度: medium 原始链接: https://leetcode.cn/problems/number-of-boomerangs 标签: 哈希 解法一: 哈希go123456789101112131415func numberOfBoomerangs(points [][]int) int { ans := 0 for _, point1 := range points { distanceHash := make(map[int]int) for _, point2 := range points { distanceHash[(point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1])]++ } for _, count := range distanceHash { if count &gt; 1 { ans += count * (count - 1) } } } return ans} java123456789101112131415161718class Solution { public int numberOfBoomerangs(int[][] points) { int ans = 0; Map&lt;Integer, Integer&gt; distanceHash = new HashMap&lt;&gt;(); for (int[] point1 : points) { distanceHash.clear(); for (int[] point2 : points) { int distance = (point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1]); distanceHash.put(distance, distanceHash.getOrDefault(distance, 0) + 1); } for (Map.Entry&lt;Integer, Integer&gt; entry : distanceHash.entrySet()) { int count = entry.getValue(); ans += (count - 1) * count; } } return ans; }}","link":"/leetcode/2024/01/number-of-boomerangs/index.html"},{"title":"383. 赎金信","text":"383. 赎金信 难度: easy 原始链接: https://leetcode.cn/problems/ransom-note 标签: 哈希 解法一: 哈希go12345678910111213func canConstruct(ransomNote string, magazine string) bool { countMap := make([]int, 26) for _, ch := range magazine { countMap[ch - 'a']++ } for _, ch := range ransomNote { if countMap[ch - 'a'] == 0 { return false } countMap[ch - 'a']-- } return true}","link":"/leetcode/2024/01/ransom-note/index.html"},{"title":"82. 删除排序链表中的重复元素 II","text":"82. 删除排序链表中的重复元素 II 难度: medium 原始链接: https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii 标签: 一次遍历, 递归 解法一: 一次遍历go12345678910111213141516171819202122232425/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1000, Next: head, } cur := p for cur != nil { if cur.Next != nil &amp;&amp; cur.Next.Next != nil &amp;&amp; cur.Next.Val == cur.Next.Next.Val { curVal := cur.Next.Val for cur.Next != nil &amp;&amp; curVal == cur.Next.Val { cur.Next = cur.Next.Next } } else { cur = cur.Next } } return p.Next} 解法二: 递归go123456789101112131415161718192021/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } if head.Val == head.Next.Val { next := head.Next for next != nil &amp;&amp; head.Val == next.Val { next = next.Next } return deleteDuplicates(next) } head.Next = deleteDuplicates(head.Next) return head}","link":"/leetcode/2024/01/remove-duplicates-from-sorted-list-ii/index.html"},{"title":"83. 删除排序链表中的重复元素","text":"83. 删除排序链表中的重复元素 难度: easy 原始链接: https://leetcode.cn/problems/remove-duplicates-from-sorted-list 标签: 模拟 解法一: 模拟go12345678910111213141516171819202122232425/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1000, Next: nil, } pre := p cur := head for cur != nil { if pre.Val != cur.Val { pre.Next = cur pre, cur = pre.Next, cur.Next pre.Next = nil } else { cur = cur.Next } } return p.Next}","link":"/leetcode/2024/01/remove-duplicates-from-sorted-list/index.html"},{"title":"2487. 从链表中移除节点","text":"2487. 从链表中移除节点 难度: medium 原始链接: https://leetcode.cn/problems/remove-nodes-from-linked-list 标签: 递归, 单调栈, 反转链表 解法一: 递归go123456789101112131415161718/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { if head == nil { return nil } next := removeNodes(head.Next) if next == nil || head.Val &gt;= next.Val { head.Next = next return head } return next} 解法二: 单调栈go12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { stack := []*ListNode{} node := head for node != nil { stack = append(stack, node) node = node.Next } pre := -1 p := &amp;ListNode{ Val: -1, Next: nil, } for len(stack) &gt; 0 { node = stack[len(stack) - 1] if node.Val &gt;= pre { pre = node.Val tmp := p.Next p.Next = node p.Next.Next = tmp } stack = stack[:len(stack) - 1] } return p.Next} 解法三: 反转链表go123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { revertHead := revertLinkNode(head) node := revertHead p := &amp;ListNode{ Val: -1, Next: nil, } pre := p for node != nil { if pre.Val &lt;= node.Val { pre.Next = node node = node.Next pre = pre.Next pre.Next = nil } else { node = node.Next } } return revertLinkNode(p.Next)}func revertLinkNode(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1, Next: nil, } node := head for node != nil { tmp := p.Next p.Next = node node = node.Next p.Next.Next = tmp } return p.Next}","link":"/leetcode/2024/01/remove-nodes-from-linked-list/index.html"},{"title":"2171. 拿出最少数目的魔法豆","text":"2171. 拿出最少数目的魔法豆 难度: medium 原始链接: https://leetcode.cn/problems/removing-minimum-number-of-magic-beans 标签: 排序, 前缀和 解法一: 排序, 前缀和go1234567891011func minimumRemoval(beans []int) int64 { sort.Ints(beans) var sum int64 = 0 var maxVal int64 = 0 n := len(beans) for i, bean := range beans { sum += int64(bean) maxVal = max(maxVal, int64(n - i) * int64(bean)) } return sum - maxVal}","link":"/leetcode/2024/01/removing-minimum-number-of-magic-beans/index.html"},{"title":"2788. 按分隔符拆分字符串","text":"2788. 按分隔符拆分字符串 难度: easy 原始链接: https://leetcode.cn/problems/split-strings-by-separator 标签: 模拟 解法一: 模拟java12345678910import java.util.regex.Pattern;class Solution { public List&lt;String&gt; splitWordsBySeparator(List&lt;String&gt; words, char separator) { return words.stream() .flatMap(word -&gt; Arrays.stream(word.split(Pattern.quote(String.valueOf(separator))))) .filter(word -&gt; !word.isEmpty()) .collect(Collectors.toList()); }}","link":"/leetcode/2024/01/split-strings-by-separator/index.html"},{"title":"2859. 计算 K 置位下标对应元素的和","text":"2859. 计算 K 置位下标对应元素的和 难度: easy 原始链接: https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits 标签: 位运算 解法一: 位运算go123456789101112131415161718func sumIndicesWithKSetBits(nums []int, k int) int { ans := 0 for i, num := range nums { if countBit(i) == k { ans += num } } return ans}func countBit(num int) int { count := 0 for num != 0 { count++ num &amp;= num - 1 } return count}","link":"/leetcode/2024/01/sum-of-values-at-indices-with-k-set-bits/index.html"},{"title":"365. 水壶问题","text":"365. 水壶问题 难度: medium 原始链接: https://leetcode.cn/problems/water-and-jug-problem 标签: 栈 解法一: 递归go1234567891011121314151617181920212223242526func canMeasureWater(jug1Capacity int, jug2Capacity int, targetCapacity int) bool { set := make(map[string]bool) var dfs func(x, y int) bool dfs = func(x, y int) bool { if x == targetCapacity || y == targetCapacity || x+y == targetCapacity { return true } numStr := strconv.Itoa(x) + &quot;,&quot; + strconv.Itoa(y) if set[numStr] { return false } set[numStr] = true return dfs(jug1Capacity, y) || dfs(0, y) || dfs(x, jug2Capacity) || dfs(x, 0) || dfs(x-min(x, jug2Capacity-y), y+min(x, jug2Capacity-y)) || dfs(x+min(y, jug1Capacity-x), y-min(y, jug1Capacity-x)) } return dfs(0, 0)}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/water-and-jug-problem/index.html"},{"title":"94. 二叉树的中序遍历","text":"二叉树的中序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-inorder-traversal 标签: 中序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func inorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) ans = append(ans, node.Val) dfs(node.Right) } dfs(root) return ans} 解法二: Morris 中序遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func inorderTraversal(root *TreeNode) []int { ans := []int{} node := root for node != nil { if node.Left != nil { predecessor := node.Left for predecessor.Right != nil &amp;&amp; predecessor.Right != node { predecessor = predecessor.Right } if predecessor.Right == nil { predecessor.Right = node node = node.Left } else { ans = append(ans, node.Val) node = node.Right predecessor.Right = nil } } else { ans = append(ans, node.Val) node = node.Right } } return ans}","link":"/leetcode/2024/02/binary-tree-inorder-traversal/index.html"},{"title":"107. 二叉树的层序遍历 II","text":"二叉树的层序遍历 II 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-level-order-traversal-ii 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrderBottom(root *TreeNode) [][]int { var ans [][]int var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) slices.Reverse(ans) return ans}","link":"/leetcode/2024/02/binary-tree-level-order-traversal-ii/index.html"},{"title":"102. 二叉树的层序遍历","text":"二叉树的层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-level-order-traversal 标签: 层序遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } queue := []*TreeNode{root} var ans [][]int for len(queue) &gt; 0 { size := len(queue) var list []int for i := 0; i &lt; size; i++ { node := queue[i] list = append(list, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] ans = append(ans, list) } return ans} 解法二: 深度优先遍历Go12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrder(root *TreeNode) [][]int { var ans [][]int var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans}","link":"/leetcode/2024/02/binary-tree-level-order-traversal/index.html"},{"title":"145. 二叉树的后序遍历","text":"二叉树的后序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-postorder-traversal 标签: 后序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func postorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) dfs(node.Right) ans = append(ans, node.Val) } dfs(root) return ans}","link":"/leetcode/2024/02/binary-tree-postorder-traversal/index.html"},{"title":"145. 二叉树的前序遍历","text":"二叉树的前序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-preorder-traversal 标签: 前序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func preorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } ans = append(ans, node.Val) dfs(node.Left) dfs(node.Right) } dfs(root) return ans} 解法二: Morris 遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func preorderTraversal(root *TreeNode) []int { ans := []int{} node := root for node != nil { if node.Left != nil { postNode := node.Left for postNode.Right != nil &amp;&amp; postNode.Right != node { postNode = postNode.Right } if postNode.Right == nil { ans = append(ans, node.Val) postNode.Right = node node = node.Left } else { node = node.Right postNode.Right = nil } } else { ans = append(ans, node.Val) node = node.Right } } return ans}","link":"/leetcode/2024/02/binary-tree-preorder-traversal/index.html"},{"title":"103. 二叉树的锯齿形层序遍历","text":"二叉树的锯齿形层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历go123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func zigzagLevelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := []*TreeNode{root} depth := 0 for len(queue) &gt; 0 { ans = append(ans, []int{}) size := len(queue) for i := 0; i &lt; size; i++ { if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } if (depth &amp; 1) == 0 { ans[depth] = append(ans[depth], queue[i].Val) } else { ans[depth] = append(ans[depth], queue[size-i-1].Val) } } queue = queue[size:] depth++ } return ans} 解法二: 深度优先遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func zigzagLevelOrder(root *TreeNode) [][]int { ans := [][]int{} var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } if (depth &amp; 1) == 0 { ans[depth] = append(ans[depth], node.Val) } else { // 往切片的头部插入一个元素 ans[depth] = append(ans[depth], -1) copy(ans[depth][1:], ans[depth]) ans[depth][0] = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans}","link":"/leetcode/2024/02/binary-tree-zigzag-level-order-traversal/index.html"},{"title":"2476. 二叉搜索树最近节点查询","text":"二叉搜索树最近节点查询 难度: medium 原始链接: https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree 标签: 中序遍历, 二分查找 解法一: 中序遍历，二分查找go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func closestNodes(root *TreeNode, queries []int) [][]int { list := []int{} dfs(root, &amp;list) ans := make([][]int, len(queries)) for i, query := range queries { ans[i] = []int{halfSearchMax(list, query), halfSearchMin(list, query)} } return ans}func dfs(node *TreeNode, list *[]int) { if node == nil { return } dfs(node.Left, list) *list = append(*list, node.Val) dfs(node.Right, list)}func halfSearchMax(list []int, target int) int { left := 0 right := len(list) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if list[mid] &lt;= target { left = mid + 1 } else { right = mid - 1 } } if right &lt; 0 { return -1 } return list[right]}func halfSearchMin(list []int, target int) int { left := 0 right := len(list) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if list[mid] &gt;= target { right = mid - 1 } else { left = mid + 1 } } if left &gt;= len(list) { return -1 } return list[left]}","link":"/leetcode/2024/02/closest-nodes-queries-in-a-binary-search-tree/index.html"},{"title":"106. 从中序与后序遍历序列构造二叉树","text":"从中序与后序遍历序列构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal 标签: 分治 解法一: 分治go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func buildTree(inorder []int, postorder []int) *TreeNode { n1 := len(postorder) n2 := len(inorder) inorderMap := make(map[int]int, n2) for i, num := range inorder { inorderMap[num] = i } return dfs(postorder, inorderMap, 0, n1-1, 0, n2-1)}func dfs(postorder []int, inorderMap map[int]int, postLeft, postRight, inLeft, inRight int) *TreeNode { if postLeft &gt; postRight { return nil } node := &amp;TreeNode{ Val: postorder[postRight], } inMid := inorderMap[postorder[postRight]] postMid := postRight - inRight + inMid node.Left = dfs(postorder, inorderMap, postLeft, postMid-1, inLeft, inMid-1) node.Right = dfs(postorder, inorderMap, postMid, postRight-1, inMid+1, inRight) return node} java1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { int n1 = inorder.length; int n2 = postorder.length; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(n1); for (int i = 0; i &lt; n1; i++) { inorderMap.put(inorder[i], i); } return this.dfs(postorder, inorderMap, 0, n2 - 1, 0, n1 - 1); } private TreeNode dfs(int[] postorder, Map&lt;Integer, Integer&gt; inorderMap, int postLeft, int postRight, int inLeft, int inRight) { if (postLeft &gt; postRight) { return null; } TreeNode node = new TreeNode(postorder[postRight]); int inMid = inorderMap.get(postorder[postRight]); int postMid = postRight - inRight + inMid; node.left = dfs(postorder, inorderMap, postLeft, postMid - 1, inLeft, inMid - 1); node.right = dfs(postorder, inorderMap, postMid, postRight - 1, inMid + 1, inRight); return node; }}","link":"/leetcode/2024/02/construct-binary-tree-from-inorder-and-postorder-traversal/index.html"},{"title":"105. 从前序与中序遍历序列构造二叉树","text":"从前序与中序遍历序列构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal 标签: 分治 解法一: 分治go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func buildTree(preorder []int, inorder []int) *TreeNode { n1 := len(preorder) n2 := len(inorder) inorderMap := make(map[int]int, n2) for i, num := range inorder { inorderMap[num] = i } return dfs(preorder, inorderMap, 0, n1-1, 0, n2-1)}func dfs(preorder []int, inorderMap map[int]int, preLeft, preRight, inLeft, inRight int) *TreeNode { if preLeft &gt; preRight { return nil } node := &amp;TreeNode{ Val: preorder[preLeft], } inMid := inorderMap[preorder[preLeft]] preMid := preLeft + inMid - inLeft node.Left = dfs(preorder, inorderMap, preLeft+1, preMid, inLeft, inMid-1) node.Right = dfs(preorder, inorderMap, preMid+1, preRight, inMid+1, inRight) return node} java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int n1 = preorder.length; int n2 = inorder.length; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;Integer, Integer&gt;(n2); for (int i = 0; i &lt; n2; i++) { inorderMap.put(inorder[i], i); } return this.dfs(preorder, inorderMap, 0, n1 - 1, 0, n2 - 1); } private TreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; inorderMap, int preLeft, int preRight, int inLeft, int inRight) { if (preLeft &gt; preRight) { return null; } TreeNode node = new TreeNode(preorder[preLeft]); int inMid = inorderMap.get(preorder[preLeft]); int preMid = preLeft + inMid - inLeft; node.left = this.dfs(preorder, inorderMap, preLeft + 1, preMid, inLeft, inMid - 1); node.right = this.dfs(preorder, inorderMap, preMid + 1, preRight, inMid + 1, inRight); return node; }}","link":"/leetcode/2024/02/construct-binary-tree-from-preorder-and-inorder-traversal/index.html"},{"title":"889. 根据前序和后序遍历构造二叉树","text":"根据前序和后序遍历构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal 标签: 分治 解法一: 分治go123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func constructFromPrePost(preorder []int, postorder []int) *TreeNode { n1 := len(preorder) n2 := len(postorder) postIndexMap := make(map[int]int, n2) for i, num := range postorder { postIndexMap[num] = i } return dfs(preorder, postIndexMap, 0, n1-1, 0, n2-1)}func dfs(preorder []int, postIndexMap map[int]int, preLeft, preRight, postLeft, postRight int) *TreeNode { if preLeft &gt; preRight { return nil } root := &amp;TreeNode{ Val: preorder[preLeft], } if preLeft &lt; preRight { postMid := postIndexMap[preorder[preLeft+1]] preMid := preLeft + postMid - postLeft + 1 root.Left = dfs(preorder, postIndexMap, preLeft+1, preMid, postLeft, postMid) root.Right = dfs(preorder, postIndexMap, preMid+1, preRight, postMid+1, postRight-1) } return root} java12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { int n1 = preorder.length; int n2 = postorder.length; Map&lt;Integer, Integer&gt; postIndexMap = new HashMap&lt;&gt;(n2); for (int i = 0; i &lt; n2; i++) { postIndexMap.put(postorder[i], i); } return this.dfs(preorder, postIndexMap, 0, n1 - 1, 0, n2 - 1); } private TreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; postIndexMap, int preLeft, int preRight, int postLeft, int postRight) { if (preLeft &gt; preRight) { return null; } TreeNode root = new TreeNode(preorder[preLeft]); if (preLeft &lt; preRight) { int postMid = postIndexMap.get(preorder[preLeft + 1]); int preMid = preLeft + postMid - postLeft + 1; root.left = this.dfs(preorder, postIndexMap, preLeft + 1, preMid, postLeft, preMid); root.right = this.dfs(preorder, postIndexMap, preMid + 1, preRight, postMid + 1, postRight - 1); } return root; }}","link":"/leetcode/2024/02/construct-binary-tree-from-preorder-and-postorder-traversal/index.html"},{"title":"2867. 统计树中的合法路径数目","text":"统计树中的合法路径数目 难度: hard 原始链接: https://leetcode.cn/problems/count-valid-paths-in-a-tree 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func countPaths(n int, edges [][]int) int64 { primes := prime(n) grip := [][]int{} for i := 0; i &lt;= n; i++ { grip = append(grip, []int{}) } for _, edge := range edges { grip[edge[0]] = append(grip[edge[0]], edge[1]) grip[edge[1]] = append(grip[edge[1]], edge[0]) } var dfs func(cur, parent int, nodes *[]int) dfs = func(cur, parent int, nodes *[]int) { *nodes = append(*nodes, cur) for _, edge := range grip[cur] { if primes[edge] &amp;&amp; edge != parent { dfs(edge, cur, nodes) } } } sumArr := make([]int, n+1) ans := int64(0) for i := 2; i &lt;= n; i++ { if primes[i] { continue } sum := 0 for _, edge := range grip[i] { if !primes[edge] { continue } else if sumArr[edge] == 0 { nodes := []int{} dfs(edge, -1, &amp;nodes) for _, node := range nodes { sumArr[node] = len(nodes) } } ans += int64(sum * sumArr[edge]) sum += sumArr[edge] } ans += int64(sum) } return ans}func prime(n int) []bool { primes := make([]bool, n+1) primes[1] = true for i := 2; i &lt;= n; i++ { if !primes[i] { for j := i * i; j &lt;= n; j += i { primes[j] = true } } } return primes}","link":"/leetcode/2024/02/count-valid-paths-in-a-tree/index.html"},{"title":"2641. 二叉树的堂兄弟节点 II","text":"2641. 二叉树的堂兄弟节点 II 难度: medium 原始链接: https://leetcode.cn/problems/cousins-in-binary-tree-ii 标签: 广度优先遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func replaceValueInTree(root *TreeNode) *TreeNode { root.Val = 0 queue := []*TreeNode{root} for len(queue) &gt; 0 { sonSum := 0 for _, node := range queue { if node.Left != nil { sonSum += node.Left.Val } if node.Right != nil { sonSum += node.Right.Val } } size := len(queue) for _, node := range queue[:size] { curSonSum := 0 if node.Left != nil { curSonSum += node.Left.Val } if node.Right != nil { curSonSum += node.Right.Val } curSonVal := sonSum - curSonSum if node.Left != nil { node.Left.Val = curSonVal queue = append(queue, node.Left) } if node.Right != nil { node.Right.Val = curSonVal queue = append(queue, node.Right) } } queue = queue[size:] } return root} java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode replaceValueInTree(TreeNode root) { root.val = 0; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { int sonSum = 0; for (TreeNode node : queue) { if (node.left != null) { sonSum += node.left.val; } if (node.right != null) { sonSum += node.right.val; } } int size = queue.size(); for (int i = 0; i &lt; size; i++) { int curSonSum = 0; TreeNode node = queue.poll(); if (node.left != null) { curSonSum += node.left.val; } if (node.right != null) { curSonSum += node.right.val; } int curSonVal = sonSum - curSonSum; if (node.left != null) { node.left.val = curSonVal; queue.offer(node.left); } if (node.right != null) { node.right.val = curSonVal; queue.offer(node.right); } } } return root; }}","link":"/leetcode/2024/02/cousins-in-binary-tree-ii/index.html"},{"title":"993. 二叉树的堂兄弟节点","text":"993. 二叉树的堂兄弟节点 难度: easy 原始链接: https://leetcode.cn/problems/cousins-in-binary-tree 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isCousins(root *TreeNode, x int, y int) bool { xParentNode, xDepth := dfs(root, nil, 0, x) yParentNode, yDepth := dfs(root, nil, 0, y) return xParentNode != yParentNode &amp;&amp; xDepth == yDepth}func dfs(curNode, parentNode *TreeNode, depth, target int) (int, int) { if curNode == nil { return -1, -1 } if curNode.Val == target { if parentNode == nil { return 0, depth } return parentNode.Val, depth } if leftParentNode, leftDepth := dfs(curNode.Left, curNode, depth+1, target); leftParentNode != -1 { return leftParentNode, leftDepth } return dfs(curNode.Right, curNode, depth+1, target)} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isCousins(root *TreeNode, x int, y int) bool { queue := []*TreeNode{root} for len(queue) &gt; 0 { size := len(queue) flag := 0 for _, node := range queue[:size] { preFlag := flag if node.Left != nil { curVal := node.Left.Val if curVal == x { flag |= 1 } if curVal == y { flag |= 2 } queue = append(queue, node.Left) } if node.Right != nil { curVal := node.Right.Val if curVal == x { flag |= 1 } if curVal == y { flag |= 2 } queue = append(queue, node.Right) } if flag == 3 { if preFlag == 0 { return false } return true } } queue = queue[size:] } return false}","link":"/leetcode/2024/02/cousins-in-binary-tree/index.html"},{"title":"1696. 跳跃游戏 VI","text":"1696. 跳跃游戏 VI 难度: medium 原始链接: https://leetcode.cn/problems/jump-game-vi 标签: 单调栈 解法一: 单调栈go1234567891011121314151617func maxResult(nums []int, k int) int { n := len(nums) dp := make([]int, n) dp[0] = nums[0] stack := []int{0} for i := 1; i &lt; n; i++ { if stack[0] &lt; i-k { stack = stack[1:] } dp[i] = nums[i] + dp[stack[0]] for len(stack) &gt; 0 &amp;&amp; dp[stack[len(stack)-1]] &lt;= dp[i] { stack = stack[:len(stack)-1] } stack = append(stack, i) } return dp[n-1]}","link":"/leetcode/2024/02/jump-game-vi/index.html"},{"title":"2583. 二叉树中的第 K 大层和","text":"二叉树中的第 K 大层和 难度: medium 原始链接: https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree 标签: 层序遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func kthLargestLevelSum(root *TreeNode, k int) int64 { queue := []*TreeNode{root} var sumArr []int64 for len(queue) &gt; 0 { size := len(queue) var sum int64 for i := 0; i &lt; size; i++ { node := queue[i] sum += int64(node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] sumArr = append(sumArr, sum) } if len(sumArr) &lt; k { return -1 } sort.Slice(sumArr, func(i, j int) bool { return sumArr[i] &gt;= sumArr[j] }) return sumArr[k-1]} 解法二: 深度优先遍历Go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func kthLargestLevelSum(root *TreeNode, k int) int64 { var sumArr []int64 var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(sumArr) &lt;= depth { sumArr = append(sumArr, 0) } sumArr[depth] += int64(node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) if len(sumArr) &lt; k { return -1 } sort.Slice(sumArr, func(i, j int) bool { return sumArr[i] &gt;= sumArr[j] }) return sumArr[k-1]}","link":"/leetcode/2024/02/kth-largest-sum-in-a-binary-tree/index.html"},{"title":"235. 二叉搜索树的最近公共祖先","text":"二叉搜索树的最近公共祖先 难度: medium 原始链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val &gt; q.Val { return lowestCommonAncestor(root, q, p) } if root.Val &lt; p.Val { return lowestCommonAncestor(root.Right, q, p) } else if root.Val &gt; q.Val { return lowestCommonAncestor(root.Left, q, p) } return root}","link":"/leetcode/2024/02/lowest-common-ancestor-of-a-binary-search-tree/index.html"},{"title":"236. 二叉树的最近公共祖先","text":"236. 二叉树的最近公共祖先 难度: medium 原始链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree 标签: 后序遍历 解法一: 后序遍历go123456789101112131415161718192021/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil || root == p || root == q { return root } leftNode := lowestCommonAncestor(root.Left, p, q) rightNode := lowestCommonAncestor(root.Right, p, q) if leftNode == nil { return rightNode } else if rightNode == nil { return leftNode } return root}","link":"/leetcode/2024/02/lowest-common-ancestor-of-a-binary-tree/index.html"},{"title":"2673. 使二叉树所有路径值相等的最小代价","text":"使二叉树所有路径值相等的最小代价 难度: medium 原始链接: https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree 标签: 贪心 解法一: 贪心go12345678910111213141516171819func minIncrements(n int, cost []int) int { ans := 0 for i := (n &gt;&gt; 1); i &gt; 0; i-- { left, right := cost[(i&lt;&lt;1)-1], cost[i&lt;&lt;1] if left &gt; right { left, right = right, left } cost[i-1] += right ans += right - left } return ans}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2024/02/make-costs-of-paths-equal-in-a-binary-tree/index.html"},{"title":"429. N 叉树的层序遍历","text":"N 叉树的层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/n-ary-tree-level-order-traversal 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go123456789101112131415161718192021222324252627/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func levelOrder(root *Node) [][]int { ans := [][]int{} var dfs func(node *Node, depth int) dfs = func(node *Node, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) depth++ for _, child := range node.Children { dfs(child, depth) } } dfs(root, 0) return ans} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func levelOrder(root *Node) [][]int { ans := [][]int{} if root == nil { return ans } queue := []*Node{root} for len(queue) &gt; 0 { size := len(queue) nodes := make([]int, size) for i := 0; i &lt; size; i++ { nodes[i] = queue[i].Val for _, child := range queue[i].Children { queue = append(queue, child) } } queue = queue[size:] ans = append(ans, nodes) } return ans}","link":"/leetcode/2024/02/n-ary-tree-level-order-traversal/index.html"},{"title":"590. N 叉树的后序遍历","text":"N 叉树的后序遍历 难度: easy 原始链接: https://leetcode.cn/problems/n-ary-tree-postorder-traversal 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func postorder(root *Node) []int { ans := []int{} var dfs func(node *Node) dfs = func(node *Node) { if node == nil { return } for _, child := range node.Children { dfs(child) } ans = append(ans, node.Val) } dfs(root) return ans} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728293031/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func postorder(root *Node) []int { ans := []int{} if root == nil { return ans } stack := []*Node{root} set := make(map[*Node]bool) for len(stack) &gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] n := len(node.Children) if n &gt; 0 &amp;&amp; !set[node] { stack = append(stack, node) set[node] = true for i := n - 1; i &gt;= 0; i-- { stack = append(stack, node.Children[i]) } } else { ans = append(ans, node.Val) } } return ans}","link":"/leetcode/2024/02/n-ary-tree-postorder-traversal/index.html"},{"title":"589. N 叉树的前序遍历","text":"N 叉树的前序遍历 难度: easy 原始链接: https://leetcode.cn/problems/n-ary-tree-preorder-traversal 标签: 前序遍历 解法一: 递归go1234567891011121314151617181920212223/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func preorder(root *Node) []int { ans := []int{} var dfs func(node *Node) dfs = func(node *Node) { if node == nil { return } ans = append(ans, node.Val) for _, child := range node.Children { dfs(child) } } dfs(root) return ans} 解法二: 迭代go123456789101112131415161718192021222324/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func preorder(root *Node) []int { ans := []int{} if root == nil { return ans } stack := []*Node{root} for len(stack) &gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] ans = append(ans, node.Val) for i := len(node.Children) - 1; i &gt;= 0; i-- { stack = append(stack, node.Children[i]) } } return ans}","link":"/leetcode/2024/02/n-ary-tree-preorder-traversal/index.html"},{"title":"292. Nim 游戏","text":"292. Nim 游戏 难度: easy 原始链接: https://leetcode.cn/problems/nim-game 标签: 数学 解法一: 数学go123func canWinNim(n int) bool { return (n % 4) != 0}","link":"/leetcode/2024/02/nim-game/index.html"},{"title":"LCP 30. 魔塔游戏","text":"LCP 30. 魔塔游戏 难度: medium 原始链接: https://leetcode.cn/problems/p0NxJO 标签: 贪心 解法一: 贪心java12345678910111213141516171819202122class Solution { public int magicTower(int[] nums) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); int ans = 0; long hp = 1; long last = 0; for (int num : nums) { hp += num; if (num &lt; 0) { priorityQueue.offer(num); if (hp &lt;= 0) { Integer moveNum = priorityQueue.poll(); last += moveNum; hp -= moveNum; ans++; } } } hp += last; return hp &lt;= 0 ? -1 : ans; }}","link":"/leetcode/2024/02/p0NxJO/index.html"},{"title":"938. 二叉搜索树的范围和","text":"二叉搜索树的范围和 难度: easy 原始链接: https://leetcode.cn/problems/range-sum-of-bst 标签: 递归 解法一: 递归go12345678910111213141516171819/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func rangeSumBST(root *TreeNode, low int, high int) int { if root == nil { return 0 } if root.Val &lt; low { return rangeSumBST(root.Right, low, high) } else if root.Val &gt; high { return rangeSumBST(root.Left, low, high) } return root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)}","link":"/leetcode/2024/02/range-sum-of-bst/index.html"},{"title":"1686. 石子游戏 VI","text":"1686. 石子游戏 VI 难度: medium 原始链接: https://leetcode.cn/problems/stone-game-vi 标签: 贪心 解法一: 贪心go12345678910111213141516171819202122232425func stoneGameVI(aliceValues []int, bobValues []int) int { n := len(aliceValues) prices := make([][]int, n) for i := 0; i &lt; n; i++ { prices[i] = []int{aliceValues[i] + bobValues[i], i} } sort.Slice(prices, func(i, j int) bool { return prices[i][0] &gt;= prices[j][0] }) alice := 0 bob := 0 for i := 0; i &lt; n; i++ { if (i &amp; 1) == 0 { alice += aliceValues[prices[i][1]] } else { bob += bobValues[prices[i][1]] } } if alice &gt; bob { return 1 } else if alice &lt; bob { return -1 } return 0}","link":"/leetcode/2024/02/stone-game-vi/index.html"},{"title":"987. 二叉树的垂序遍历","text":"二叉树的垂序遍历 难度: hard 原始链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree 标签: 排序 解法一: 排序go123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func verticalTraversal(root *TreeNode) [][]int { var lists [][]int var dfs func(*TreeNode, int, int) dfs = func(node *TreeNode, col, row int) { if node == nil { return } lists = append(lists, []int{col, row, node.Val}) dfs(node.Left, col-1, row+1) dfs(node.Right, col+1, row+1) } dfs(root, 0, 0) sort.Slice(lists, func(i, j int) bool { if lists[i][0] != lists[j][0] { return lists[i][0] &lt;= lists[j][0] } if lists[i][1] != lists[j][1] { return lists[i][1] &lt;= lists[j][1] } return lists[i][2] &lt;= lists[j][2] }) preCol := -1001 var ans [][]int for _, list := range lists { if preCol == list[0] { last := len(ans) - 1 ans[last] = append(ans[last], list[2]) } else { preCol = list[0] ans = append(ans, []int{list[2]}) } } return ans}","link":"/leetcode/2024/02/vertical-order-traversal-of-a-binary-tree/index.html"},{"title":"299. 猜数字游戏","text":"猜数字游戏 难度: medium 原始链接: https://leetcode.cn/problems/bulls-and-cows 标签: 哈希 解法一: 哈希go12345678910111213141516171819func getHint(secret string, guess string) string { bulls := 0 cows := 0 sCount := make([]int, 10) gCount := make([]int, 10) n := len(secret) for i := 0; i &lt; n; i++ { if secret[i] == guess[i] { bulls++ } else { sCount[secret[i]-'0']++ gCount[guess[i]-'0']++ } } for i := 0; i &lt; 10; i++ { cows += min(sCount[i], gCount[i]) } return strconv.Itoa(bulls) + &quot;A&quot; + strconv.Itoa(cows) + &quot;B&quot;}","link":"/leetcode/2024/03/bulls-and-cows/index.html"},{"title":"2129. 将标题首字母大写","text":"将标题首字母大写 难度: easy 原始链接: https://leetcode.cn/problems/capitalize-the-title 标签: 模拟 解法一: 模拟go1234567891011func capitalizeTitle(title string) string { fields := strings.Fields(title) for i, field := range fields { if len(field) &lt;= 2 { fields[i] = strings.ToLower(field) } else { fields[i] = strings.ToUpper(field[:1]) + strings.ToLower(field[1:]) } } return strings.Join(fields, &quot; &quot;)} java123456789101112class Solution { public String capitalizeTitle(String title) { return Arrays.stream(title.split(&quot; &quot;)) .map(str -&gt; { if (str.length() &lt;= 2) { return str.toLowerCase(); } return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase(); }) .collect(Collectors.joining(&quot; &quot;)); }}","link":"/leetcode/2024/03/capitalize-the-title/index.html"},{"title":"2369. 检查数组是否存在有效划分","text":"检查数组是否存在有效划分 难度: medium 原始链接: https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array 标签: 动态规划 解法一: 动态规划go1234567891011121314151617181920212223242526func validPartition(nums []int) bool { n := len(nums) dp := make([]bool, n) // 初始化 dp 的前三个状态 dp[0] = false dp[1] = nums[0] == nums[1] if n == 2 { return dp[1] } dp[2] = dp[1] &amp;&amp; nums[1] == nums[2] || nums[0] == nums[1]-1 &amp;&amp; nums[0] == nums[2]-2 // 从第四个元素元素开始递推 for i := 3; i &lt; n; i++ { if dp[i-2] &amp;&amp; nums[i] == nums[i-1] { // 1. 两个元素相等 dp[i] = true } else if dp[i-3] &amp;&amp; nums[i] == nums[i-1] &amp;&amp; nums[i] == nums[i-2] { // 2. 三个元素相同 dp[i] = true } else if dp[i-3] &amp;&amp; nums[i] == nums[i-1]+1 &amp;&amp; nums[i] == nums[i-2]+2 { // 3. 三个元素递增 dp[i] = true } } // 返回最后一个元素状态是否可达 return dp[n-1]}","link":"/leetcode/2024/03/check-if-there-is-a-valid-partition-for-the-array/index.html"},{"title":"2549. 统计桌面上的不同数字","text":"统计桌面上的不同数字 难度: easy 原始链接: https://leetcode.cn/problems/count-distinct-numbers-on-board 标签: 数学 解法一: 数学go123func distinctIntegers(n int) int { return max(n-1, 1)}","link":"/leetcode/2024/03/count-distinct-numbers-on-board/index.html"},{"title":"2580. 统计将重叠区间合并成组的方案数","text":"统计将重叠区间合并成组的方案数 难度: medium 原始链接: https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges 标签: 排序, 快速幂 解法一: 排序, 快速幂go12345678910111213141516171819202122232425262728293031const MOD = 1_000_000_007func countWays(ranges [][]int) int { sort.Slice(ranges, func(i, j int) bool { return ranges[i][0] &lt;= ranges[j][0] }) count := 0 pre := -1 for _, r := range ranges { if pre &lt; r[0] { count++ } pre = max(pre, r[1]) } return quickSort(2%MOD, count, MOD)}func quickSort(num, x, mod int) int { if x == 0 { return 1 } else if x == 1 { return num % mod } half := x &gt;&gt; 1 halfAns := quickSort(num, half, mod) ans := halfAns * halfAns % mod if (x &amp; 1) == 1 { ans = ans * num % mod } return ans}","link":"/leetcode/2024/03/count-ways-to-group-overlapping-ranges/index.html"},{"title":"1261. 在受污染的二叉树中查找元素","text":"在受污染的二叉树中查找元素 难度: medium 原始链接: https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree 标签: 哈希 解法一: 哈希go1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */type FindElements struct { set map[int]bool}func Constructor(root *TreeNode) FindElements { set := map[int]bool{} var dfs func(node *TreeNode, cur int) dfs = func(node *TreeNode, cur int) { if node == nil { return } set[cur] = true dfs(node.Left, (cur&lt;&lt;1)+1) dfs(node.Right, (cur&lt;&lt;1)+2) } dfs(root, 0) return FindElements{ set, }}func (this *FindElements) Find(target int) bool { return this.set[target]}/** * Your FindElements object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.Find(target); */","link":"/leetcode/2024/03/find-elements-in-a-contaminated-binary-tree/index.html"},{"title":"2575. 找出字符串的可整除数组","text":"找出字符串的可整除数组 难度: medium 原始链接: https://leetcode.cn/problems/find-the-divisibility-array-of-a-string 标签: 模运算 解法一: 模运算go123456789101112func divisibilityArray(word string, m int) []int { n := len(word) ans := make([]int, n) cur := 0 for i, ch := range word { cur = (cur*10 + int(ch-'0')) % m if cur == 0 { ans[i] = 1 } } return ans}","link":"/leetcode/2024/03/find-the-divisibility-array-of-a-string/index.html"},{"title":"2917. 找出数组中的 K-or 值","text":"找出数组中的 K-or 值 难度: easy 原始链接: https://leetcode.cn/problems/find-the-k-or-of-an-array 标签: 位运算 解法一: 位运算go12345678910111213141516func findKOr(nums []int, k int) int { ans := 0 for i := 0; i &lt; 31; i++ { count := 0 for _, num := range nums { if (num&gt;&gt;i)&amp;1 == 1 { count++ if count &gt;= k { ans += 1 &lt;&lt; i break } } } } return ans}","link":"/leetcode/2024/03/find-the-k-or-of-an-array/index.html"},{"title":"2834. 找出美丽数组的最小和","text":"找出美丽数组的最小和 难度: medium 原始链接: https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array 标签: 数学 解法一: 数学go12345678910111213const MOD = 1000000007func minimumPossibleSum(n int, target int) int { // 左边部分 left1 := 1 right1 := min(target&gt;&gt;1, n) leftSum := ((left1 + right1) * (right1 - left1 + 1)) &gt;&gt; 1 // 右边部分 left2 := target right2 := target + (n - (right1 - left1 + 1)) - 1 rightSum := ((left2 + right2) * (right2 - left2 + 1)) &gt;&gt; 1 return (leftSum + rightSum) % MOD}","link":"/leetcode/2024/03/find-the-minimum-possible-sum-of-a-beautiful-array/index.html"},{"title":"2671. 频率跟踪器","text":"频率跟踪器 难度: medium 原始链接: https://leetcode.cn/problems/frequency-tracker 标签: 哈希 解法一: 哈希go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type FrequencyTracker struct { hash1 map[int]int hash2 map[int]int}func Constructor() FrequencyTracker { return FrequencyTracker{ hash1: make(map[int]int), hash2: make(map[int]int), }}func (this *FrequencyTracker) Add(number int) { hash1 := this.hash1 hash2 := this.hash2 if count, exists := hash1[number]; exists { hash2[count]-- hash2[count+1]++ } else { hash2[1]++ } hash1[number]++}func (this *FrequencyTracker) DeleteOne(number int) { hash1 := this.hash1 hash2 := this.hash2 if count := hash1[number]; count != 0 { hash2[count]-- if count &gt; 1 { hash2[count-1]++ } hash1[number]-- }}func (this *FrequencyTracker) HasFrequency(frequency int) bool { hash2 := this.hash2 return hash2[frequency] &gt; 0}/** * Your FrequencyTracker object will be instantiated and called as such: * obj := Constructor(); * obj.Add(number); * obj.DeleteOne(number); * param_3 := obj.HasFrequency(frequency); */","link":"/leetcode/2024/03/frequency-tracker/index.html"},{"title":"232. 用栈实现队列","text":"用栈实现队列 难度: easy 原始链接: https://leetcode.cn/problems/implement-queue-using-stacks 标签: 堆栈, 队列 解法一: 双栈go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071type MyQueue struct { stack1 *[]int stack2 *[]int}func Constructor() MyQueue { return MyQueue{ stack1: &amp;[]int{}, stack2: &amp;[]int{}, }}func (this *MyQueue) Push(x int) { stack1 := *(this.stack1) stack1 = append(stack1, x) this.stack1 = &amp;stack1}func (this *MyQueue) Pop() int { stack2 := *(this.stack2) if len(stack2) &gt; 0 { ans := stack2[len(stack2)-1] stack2 = stack2[:len(stack2)-1] this.stack2 = &amp;stack2 return ans } this.stack12Stack2() return this.Pop()}func (this *MyQueue) Peek() int { stack2 := *(this.stack2) if len(stack2) &gt; 0 { return stack2[len(stack2)-1] } this.stack12Stack2() return this.Peek()}func (this *MyQueue) Empty() bool { stack2 := *(this.stack2) if len(stack2) &gt; 0 { return len(stack2) == 0 } this.stack12Stack2() stack2 = *(this.stack2) return len(stack2) == 0}func (this *MyQueue) stack12Stack2() { stack1 := *(this.stack1) stack2 := *(this.stack2) if len(stack2) &gt; 0 { return } for len(stack1) &gt; 0 { stack2 = append(stack2, stack1[len(stack1)-1]) stack1 = stack1[:len(stack1)-1] } this.stack1 = &amp;stack1 this.stack2 = &amp;stack2}/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */","link":"/leetcode/2024/03/implement-queue-using-stacks/index.html"},{"title":"225. 用队列实现栈","text":"用队列实现栈 难度: easy 原始链接: https://leetcode.cn/problems/implement-stack-using-queues 标签: 队列, 堆栈 解法一: 双队列go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type MyStack struct { queue1 *[]int queue2 *[]int}func Constructor() MyStack { return MyStack{ queue1: &amp;[]int{}, queue2: &amp;[]int{}, }}func (this *MyStack) Push(x int) { queue1 := this.queue1 queue2 := this.queue2 *queue2 = append(*queue2, x) if len(*queue1) &gt; 0 { *queue2 = append(*queue2, *queue1...) *queue1 = []int{} } this.queue1, this.queue2 = this.queue2, this.queue1}func (this *MyStack) Pop() int { queue1 := this.queue1 ans := (*queue1)[0] (*queue1) = (*queue1)[1:] return ans}func (this *MyStack) Top() int { queue1 := this.queue1 return (*queue1)[0]}func (this *MyStack) Empty() bool { queue1 := this.queue1 return len(*queue1) == 0}/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 解法二: 一个队列go123456789101112131415161718192021222324252627282930313233343536373839404142434445type MyStack struct { queue *[]int}func Constructor() MyStack { return MyStack{ queue: &amp;[]int{}, }}func (this *MyStack) Push(x int) { queue := this.queue n := len(*queue) *queue = append(*queue, x) for i := 0; i &lt; n; i++ { *queue = append(*queue, (*queue)[i]) } *queue = (*queue)[n:]}func (this *MyStack) Pop() int { queue := this.queue ans := (*queue)[0] (*queue) = (*queue)[1:] return ans}func (this *MyStack) Top() int { queue := this.queue return (*queue)[0]}func (this *MyStack) Empty() bool { queue := this.queue return len(*queue) == 0}/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */","link":"/leetcode/2024/03/implement-stack-using-queues/index.html"},{"title":"2789. 合并后数组中的最大元素","text":"合并后数组中的最大元素 难度: medium 原始链接: https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations 标签: 贪心 解法一: 贪心go123456789101112131415func maxArrayValue(nums []int) int64 { n := len(nums) cur := int64(nums[n-1]) ans := int64(cur) for i := n - 1; i &gt; 0; i-- { pre := int64(nums[i-1]) if cur &gt;= pre { cur += pre } else { cur = pre } ans = max(ans, cur) } return ans}","link":"/leetcode/2024/03/largest-element-in-an-array-after-merge-operations/index.html"},{"title":"2684. 矩阵中移动的最大次数","text":"矩阵中移动的最大次数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go123456789101112131415161718192021222324252627282930313233func maxMoves(grid [][]int) int { m := len(grid) n := len(grid[0]) shift := []int{ -1, 0, 1, } ansMap := make(map[int]int) var dfs func(r, c int) int dfs = func(r, c int) int { if ans, exists := ansMap[r*n+c]; exists { return ans } ans := c - 1 if c &gt;= n { return ans } for i := 0; i &lt; 3; i++ { newR := r + shift[i] if newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; grid[newR][c] &gt; grid[r][c-1] { ans = max(ans, dfs(newR, c+1)) } } ansMap[r*n+c] = ans return ans } ans := 0 for i := 0; i &lt; m; i++ { ans = max(ans, dfs(i, 1)) } return ans} 解法二: 广度优先遍历go123456789101112131415161718192021222324252627282930313233func maxMoves(grid [][]int) int { m := len(grid) n := len(grid[0]) for i := 0; i &lt; m; i++ { grid[i][0] *= -1 } width := 1 shift := []int{ -1, 0, 1, } for width &lt; n { isNext := false for i := 0; i &lt; m; i++ { if grid[i][width-1] &gt; 0 { continue } for j := 0; j &lt; 3; j++ { r := i + shift[j] if r &gt;= 0 &amp;&amp; r &lt; m &amp;&amp; grid[r][width] &gt; 0 &amp;&amp; grid[r][width] &gt; -grid[i][width-1] { isNext = true grid[r][width] *= -1 } } } if !isNext { break } width++ } return width - 1}","link":"/leetcode/2024/03/maximum-number-of-moves-in-a-grid/index.html"},{"title":"2864. 最大二进制奇数","text":"最大二进制奇数 难度: easy 原始链接: https://leetcode.cn/problems/maximum-odd-binary-number 标签: 模拟 解法一: 模拟go1234567891011121314func maximumOddBinaryNumber(s string) string { one := countOne(s) return strings.Repeat(&quot;1&quot;, one-1) + strings.Repeat(&quot;0&quot;, len(s)-one) + &quot;1&quot;}func countOne(str string) int { count := 0 for _, ch := range str { if ch == '1' { count++ } } return count}","link":"/leetcode/2024/03/maximum-odd-binary-number/index.html"},{"title":"310. 最小高度树","text":"最小高度树 难度: medium 原始链接: https://leetcode.cn/problems/minimum-height-trees 标签: 广度优先遍历 解法一: 广度优先遍历go12345678910111213141516171819202122232425262728293031323334func findMinHeightTrees(n int, edges [][]int) []int { if n == 1 { return []int{0} } relations := make([][]int, n) inCount := make([]int, n) for _, edge := range edges { relations[edge[0]] = append(relations[edge[0]], edge[1]) relations[edge[1]] = append(relations[edge[1]], edge[0]) inCount[edge[0]]++ inCount[edge[1]]++ } queue := []int{} for i, count := range inCount { if count == 1 { queue = append(queue, i) } } ans := queue for len(queue) &gt; 0 { ans = queue size := len(queue) for i := 0; i &lt; size; i++ { for _, node := range relations[queue[i]] { inCount[node]-- if inCount[node] == 1 { queue = append(queue, node) } } } queue = queue[size:] } return ans}","link":"/leetcode/2024/03/minimum-height-trees/index.html"},{"title":"1969. 数组元素的最小非零乘积","text":"数组元素的最小非零乘积 难度: medium 原始链接: https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements 标签: 数学 解法一: 数学go1234567891011121314151617181920const MOD = 1000000007func minNonZeroProduct(p int) int { // (2 ^ p - 1) * (2 ^ p - 2) ^ (2 ^ (p - 1) - 1) base := 1 &lt;&lt; p return (base - 1) % MOD * pow((base-2)%MOD, (base&gt;&gt;1)-1) % MOD}func pow(x, n int) int { if n == 0 { return 1 } half := n &gt;&gt; 1 halfAns := pow(x, half) ans := halfAns * halfAns % MOD if (n &amp; 1) == 1 { ans = ans * x % MOD } return ans}","link":"/leetcode/2024/03/minimum-non-zero-product-of-the-array-elements/index.html"},{"title":"2952. 需要添加的硬币的最小数量","text":"需要添加的硬币的最小数量 难度: medium 原始链接: https://leetcode.cn/problems/minimum-number-of-coins-to-be-added 标签: 数学, 贪心 解法一: 数学, 贪心go1234567891011121314151617func minimumAddedCoins(coins []int, target int) int { sort.Ints(coins) n := len(coins) ans := 0 s := 1 i := 0 for s &lt;= target { if i &lt; n &amp;&amp; coins[i] &lt;= s { s += coins[i] i++ } else { ans++ s &lt;&lt;= 1 } } return ans}","link":"/leetcode/2024/03/minimum-number-of-coins-to-be-added/index.html"},{"title":"2908. 元素和最小的山形三元组 I","text":"元素和最小的山形三元组 I 难度: easy 原始链接: https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i 标签: 预处理 解法一: 预处理go1234567891011121314151617181920func minimumSum(nums []int) int { n := len(nums) minArr := make([]int, n) minArr[0] = nums[0] for i := 1; i &lt; n; i++ { minArr[i] = min(minArr[i-1], nums[i-1]) } pre := nums[n-1] ans := math.MaxInt for i := n - 2; i &gt; 0; i-- { if nums[i] &gt; pre &amp;&amp; nums[i] &gt; minArr[i] { ans = min(ans, pre+nums[i]+minArr[i]) } pre = min(pre, nums[i]) } if ans == math.MaxInt { return -1 } return ans}","link":"/leetcode/2024/03/minimum-sum-of-mountain-triplets-i/index.html"},{"title":"303. 区域和检索 - 数组不可变","text":"区域和检索 - 数组不可变 难度: easy 原始链接: https://leetcode.cn/problems/range-sum-query-immutable 标签: 前缀和 解法一: 前缀和go1234567891011121314151617181920212223242526type NumArray struct { preSum []int}func Constructor(nums []int) NumArray { sum := 0 preSum := make([]int, len(nums)+1) for i, num := range nums { sum += num preSum[i+1] = sum } return NumArray{ preSum, }}func (this *NumArray) SumRange(left int, right int) int { preSum := this.preSum return preSum[right+1] - preSum[left]}/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */","link":"/leetcode/2024/03/range-sum-query-immutable/index.html"},{"title":"2368. 受限条件下可到达节点的数目","text":"2368. 受限条件下可到达节点的数目 难度: medium 原始链接: https://leetcode.cn/problems/reachable-nodes-with-restrictions 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122func reachableNodes(n int, edges [][]int, restricted []int) int { tree := make(map[int][]int) for _, edge := range edges { tree[edge[0]] = append(tree[edge[0]], edge[1]) tree[edge[1]] = append(tree[edge[1]], edge[0]) } set := make(map[int]bool, len(restricted)) for _, num := range restricted { set[num] = true } return dfs(0, -1, tree, set)}func dfs(cur, parent int, tree map[int][]int, set map[int]bool) int { ans := 1 for _, next := range tree[cur] { if next != parent &amp;&amp; !set[next] { ans += dfs(next, cur, tree, set) } } return ans}","link":"/leetcode/2024/03/reachable-nodes-with-restrictions/index.html"},{"title":"2192. 有向无环图中一个节点的所有祖先","text":"有向无环图中一个节点的所有祖先 难度: medium 原始链接: https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546func getAncestors(n int, edges [][]int) [][]int { relations := make([][]int, n) // 反方向建立联系 for _, edge := range edges { relations[edge[1]] = append(relations[edge[1]], edge[0]) } // 标记已经计算完成的节点 visit := make([]bool, n) // 结果 ans := make([][]int, n) // 计算指定节点的所有父节点，排序并去重 var dfs func(cur int) []int dfs = func(cur int) []int { if visit[cur] { return ans[cur] } // 标记当前节点已计算完毕 visit[cur] = true // 记录当前节点的所有父节点，可能会有节点重复 parent := []int{} for _, relation := range relations[cur] { parent = append(parent, dfs(relation)...) parent = append(parent, relation) } // 排序 sort.Ints(parent) n := len(parent) // 双指针去重 if n &gt; 0 { i := 0 for j := 1; j &lt; n; j++ { if parent[j] != parent[i] { i++ parent[i] = parent[j] } } ans[cur] = parent[:i+1] } return parent } // 循环计算每个节点 for i := 0; i &lt; n; i++ { dfs(i) } return ans} java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { public List&lt;List&lt;Integer&gt;&gt; getAncestors(int n, int[][] edges) { // 标记已经计算完成的节点 boolean[] visit = new boolean[n]; // 反方向建立联系 Map&lt;Integer, List&lt;Integer&gt;&gt; relations = new HashMap&lt;&gt;(n); for (int[] edge : edges) { relations.merge(edge[1], Collections.singletonList(edge[0]), (origin, target) -&gt; { if (origin.size() == 1) { origin = new ArrayList&lt;&gt;(origin); } origin.addAll(target); return origin; }); } List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(n); for (int i = 0; i &lt; n; i++) { ans.add(new ArrayList&lt;&gt;()); } // 循环计算每个节点 for (int i = 0; i &lt; n; i++) { this.dfs(i, visit, relations, ans); } return ans; } private List&lt;Integer&gt; dfs(int cur, boolean[] visit, Map&lt;Integer, List&lt;Integer&gt;&gt; relations, List&lt;List&lt;Integer&gt;&gt; ans) { if (visit[cur]) { return ans.get(cur); } // 标记当前节点已计算完毕 visit[cur] = true; // 记录当前节点的所有父节点，可能会有节点重复 List&lt;Integer&gt; parent = new ArrayList&lt;&gt;(); for (Integer relation : relations.getOrDefault(cur, Collections.emptyList())) { parent.addAll(this.dfs(relation, visit, relations, ans)); parent.add(relation); } if (parent.isEmpty()) { return parent; } // 排序 Collections.sort(parent); // 双指针去重 int i = 0; int n = parent.size(); for (int j = 1; j &lt; n; j++) { if (!Objects.equals(parent.get(j), parent.get(i))) { parent.set(++i, parent.get(j)); } } ans.set(cur, parent.subList(0, i + 1)); return parent; }}","link":"/leetcode/2024/04/all-ancestors-of-a-node-in-a-directed-acyclic-graph/index.html"},{"title":"2385. 感染二叉树需要的总时间","text":"感染二叉树需要的总时间 难度: medium 原始链接: https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历, 深度优先遍历go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func amountOfTime(root *TreeNode, start int) int { relations := make(map[int][]int) var searchParent func(cur, pre *TreeNode) searchParent = func(cur, pre *TreeNode) { list := []int{} if pre != nil { list = append(list, pre.Val) } if cur.Left != nil { list = append(list, cur.Left.Val) searchParent(cur.Left, cur) } if cur.Right != nil { list = append(list, cur.Right.Val) searchParent(cur.Right, cur) } relations[cur.Val] = list } searchParent(root, nil) queue := []int{start} visit := map[int]bool{start: true} ans := 0 for { size := len(queue) for i := 0; i &lt; size; i++ { for _, nodeVal := range relations[queue[i]] { if !visit[nodeVal] { visit[nodeVal] = true queue = append(queue, nodeVal) } } } queue = queue[size:] if len(queue) == 0 { break } ans++ } return ans}","link":"/leetcode/2024/04/amount-of-time-for-binary-tree-to-be-infected/index.html"},{"title":"1379. 找出克隆二叉树中的相同节点","text":"找出克隆二叉树中的相同节点 难度: easy 原始链接: https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree 标签: 前序遍历 解法一: 前序遍历java123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) { if (original == null) { return null; } else if (original == target) { return cloned; } TreeNode ans = this.getTargetCopy(original.left, cloned.left, target); if (ans != null) { return ans; } return this.getTargetCopy(original.right, cloned.right, target); }}","link":"/leetcode/2024/04/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/index.html"},{"title":"2923. 找到冠军 I","text":"找到冠军 I 难度: easy 原始链接: https://leetcode.cn/problems/find-champion-i 标签: 数组 解法一: O(n ^ 2) 时间复杂度go12345678910111213141516func findChampion(grid [][]int) int { n := len(grid) for i := 0; i &lt; n; i++ { isSuccess := true for j := 0; j &lt; n; j++ { if i != j &amp;&amp; grid[i][j] == 0 { isSuccess = false break } } if isSuccess { return i } } return -1} 解法二: O(n) 时间复杂度go12345678910func findChampion(grid [][]int) int { ans := 0 n := len(grid) for i := 1; i &lt; n; i++ { if grid[i][ans] == 1 { ans = i } } return ans}","link":"/leetcode/2024/04/find-champion-i/index.html"},{"title":"2924. 找到冠军 II","text":"找到冠军 II 难度: medium 原始链接: https://leetcode.cn/problems/find-champion-ii 标签: 图 解法一: 直接遍历go1234567891011121314151617func findChampion(n int, edges [][]int) int { state := make([]bool, n) for _, edge := range edges { state[edge[1]] = true } ans := -1 for i := 0; i &lt; n; i++ { if !state[i] { if ans == -1 { ans = i } else { return -1 } } } return ans}","link":"/leetcode/2024/04/find-champion-ii/index.html"},{"title":"2007. 从双倍数组中还原原数组","text":"从双倍数组中还原原数组 难度: medium 原始链接: https://leetcode.cn/problems/find-original-array-from-doubled-array 标签: 排序, 贪心 解法一: 排序, 贪心go1234567891011121314151617181920func findOriginalArray(changed []int) []int { n := len(changed) sort.Ints(changed) queue := []int{} ans := make([]int, n&gt;&gt;1) i := 0 for _, num := range changed { if len(queue) &gt; 0 &amp;&amp; num == queue[0] { queue = queue[1:] } else { if i == len(ans) { return []int{} } ans[i] = num i++ queue = append(queue, num&lt;&lt;1) } } return ans}","link":"/leetcode/2024/04/find-original-array-from-doubled-array/index.html"},{"title":"2639. 查询网格图中每一列的宽度","text":"查询网格图中每一列的宽度 难度: easy 原始链接: https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid 标签: 数学 解法一: 数学go12345678910111213141516171819202122func findColumnWidth(grid [][]int) []int { m := len(grid) n := len(grid[0]) ans := make([]int, n) for i := 0; i &lt; n; i++ { num := 0 for j := 0; j &lt; m; j++ { num = max(num, max(grid[j][i]/10, -grid[j][i])) } ans[i] = calcWidth(num) + 1 } return ans}func calcWidth(num int) int { count := 0 for num != 0 { count++ num /= 10 } return count}","link":"/leetcode/2024/04/find-the-width-of-columns-of-a-grid/index.html"},{"title":"1052. 爱生气的书店老板","text":"爱生气的书店老板 难度: medium 原始链接: https://leetcode.cn/problems/grumpy-bookstore-owner 标签: 滑动窗口 解法一: 滑动窗口go12345678910111213141516171819202122232425func maxSatisfied(customers []int, grumpy []int, minutes int) int { n := len(customers) sum := 0 saveCustomer := 0 for i := 0; i &lt; minutes; i++ { if grumpy[i] == 1 { saveCustomer += customers[i] } else { sum += customers[i] } } ans := saveCustomer for i := minutes; i &lt; n; i++ { if grumpy[i-minutes] == 1 { saveCustomer -= customers[i-minutes] } if grumpy[i] == 1 { saveCustomer += customers[i] } else { sum += customers[i] } ans = max(ans, saveCustomer) } return ans + sum}","link":"/leetcode/2024/04/grumpy-bookstore-owner/index.html"},{"title":"1702. 修改后的最大二进制字符串","text":"故障键盘 难度: medium 原始链接: https://leetcode.cn/problems/maximum-binary-string-after-change 标签: 贪心 解法一: 贪心go1234567891011121314151617181920func maximumBinaryString(binary string) string { n := len(binary) first := 0 for first &lt; n { if binary[first] != '1' { break } first++ } if first &gt;= n { return binary } oneCount := 0 for i := first; i &lt; n; i++ { if binary[i] == '1' { oneCount++ } } return strings.Repeat(&quot;1&quot;, n-oneCount-1) + &quot;0&quot; + strings.Repeat(&quot;1&quot;, oneCount)}","link":"/leetcode/2024/04/maximum-binary-string-after-change/index.html"},{"title":"2529. 正整数和负整数的最大计数","text":"正整数和负整数的最大计数 难度: easy 原始链接: https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920func maximumCount(nums []int) int { return max(targetMin(nums, 0)+1, len(nums)-targetMin(nums, 1)-1)}func targetMin(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if nums[mid] &gt;= target { right = mid - 1 } else { left = mid } } if nums[left] &gt;= target { return -1 } return left}","link":"/leetcode/2024/04/maximum-count-of-positive-integer-and-negative-integer/index.html"},{"title":"1026. 节点与其祖先之间的最大差值","text":"节点与其祖先之间的最大差值 难度: medium 原始链接: https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func maxAncestorDiff(root *TreeNode) int { var dfs func(node *TreeNode, minVal, maxVal int) int dfs = func(node *TreeNode, minVal, maxVal int) int { if node == nil { return maxVal - minVal } minVal = min(minVal, node.Val) maxVal = max(maxVal, node.Val) return max(dfs(node.Left, minVal, maxVal), dfs(node.Right, minVal, maxVal)) } return dfs(root, root.Val, root.Val)}","link":"/leetcode/2024/04/maximum-difference-between-node-and-ancestor/index.html"},{"title":"2798. 满足目标工作时长的员工数目","text":"满足目标工作时长的员工数目 难度: easy 原始链接: https://leetcode.cn/problems/number-of-employees-who-met-the-target 标签: 一次遍历 解法一: 一次遍历go123456789func numberOfEmployeesWhoMetTarget(hours []int, target int) int { ans := 0 for _, hour := range hours { if hour &gt;= target { ans++ } } return ans} java1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { return (int) Arrays.stream(hours) .filter(hour -&gt; hour &gt;= target) .count(); }}","link":"/leetcode/2024/04/number-of-employees-who-met-the-target/index.html"},{"title":"1146. 快照数组","text":"快照数组 难度: medium 原始链接: https://leetcode.cn/problems/snapshot-array 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type SnapshotArray struct { version int data [][][]int}func Constructor(length int) SnapshotArray { return SnapshotArray{ version: 0, data: make([][][]int, length), }}func (this *SnapshotArray) Set(index int, val int) { this.data[index] = append(this.data[index], []int{this.version, val})}func (this *SnapshotArray) Snap() int { oldVersion := this.version this.version++ return oldVersion}func (this *SnapshotArray) Get(index int, snap_id int) int { return binarySearch(this.data[index], snap_id)}func binarySearch(arr [][]int, version int) int { if len(arr) == 0 { return 0 } left := 0 right := len(arr) - 1 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if arr[mid][0] &gt; version { right = mid - 1 } else { left = mid } } if arr[left][0] &lt;= version { return arr[left][1] } return 0}/** * Your SnapshotArray object will be instantiated and called as such: * obj := Constructor(length); * obj.Set(index,val); * param_2 := obj.Snap(); * param_3 := obj.Get(index,snap_id); */","link":"/leetcode/2024/04/snapshot-array/index.html"},{"title":"1329. 将矩阵按对角线排序","text":"将矩阵按对角线排序 难度: medium 原始链接: https://leetcode.cn/problems/sort-the-matrix-diagonally 标签: 模拟 解法一: 模拟go1234567891011121314151617181920func diagonalSort(mat [][]int) [][]int { m := len(mat) n := len(mat[0]) lists := make([][]int, m+n) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { lists[i-j+n] = append(lists[i-j+n], mat[i][j]) } } for i := m + n - 1; i &gt; 0; i-- { sort.Ints(lists[i]) } for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { mat[i][j] = lists[i-j+n][0] lists[i-j+n] = lists[i-j+n][1:] } } return mat}","link":"/leetcode/2024/04/sort-the-matrix-diagonally/index.html"},{"title":"1600. 王位继承顺序","text":"王位继承顺序 难度: medium 原始链接: https://leetcode.cn/problems/throne-inheritance 标签: 前序遍历 解法一: 前序遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455type ThroneInheritance struct { Root *Node Deads map[string]*Node}type Node struct { Name string IsDead bool Children *[]*Node}func Constructor(kingName string) ThroneInheritance { root := &amp;Node{ Name: kingName, Children: &amp;[]*Node{}, } return ThroneInheritance{ Root: root, Deads: map[string]*Node{ kingName: root, }, }}func (this *ThroneInheritance) Birth(parentName string, childName string) { node := &amp;Node{ Name: childName, Children: &amp;[]*Node{}, } children := this.Deads[parentName].Children *children = append(*children, node) this.Deads[childName] = node}func (this *ThroneInheritance) Death(name string) { this.Deads[name].IsDead = true}func (this *ThroneInheritance) GetInheritanceOrder() []string { ans := []string{} var dfs func(root *Node) dfs = func(root *Node) { if root == nil { return } if !root.IsDead { ans = append(ans, root.Name) } for _, child := range *root.Children { dfs(child) } } dfs(this.Root) return ans} java123456789101112131415161718192021222324252627282930313233343536373839404142434445class ThroneInheritance { private String kingName; private Map&lt;String, List&lt;String&gt;&gt; nodes; private Set&lt;String&gt; deads; public ThroneInheritance(String kingName) { this.kingName = kingName; nodes = new HashMap&lt;&gt;(); deads = new HashSet&lt;&gt;(); } public void birth(String parentName, String childName) { nodes.merge(parentName, Collections.singletonList(childName), (children, newChildren) -&gt; { if (children.size() == 1) { children = new ArrayList&lt;&gt;(children); } children.addAll(newChildren); return children; }); } public void death(String name) { deads.add(name); } public List&lt;String&gt; getInheritanceOrder() { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); this.dfs(kingName, ans); return ans; } private void dfs(String nodeName, List&lt;String&gt; ans) { if (!deads.contains(nodeName)) { ans.add(nodeName); } List&lt;String&gt; nodeNames = nodes.getOrDefault(nodeName, Collections.emptyList()); for (String childName : nodeNames) { this.dfs(childName, ans); } }}","link":"/leetcode/2024/04/throne-inheritance/index.html"},{"title":"2739. 总行驶距离","text":"总行驶距离 难度: easy 原始链接: https://leetcode.cn/problems/total-distance-traveled 标签: 数学 解法一: 数学go123func distanceTraveled(mainTank int, additionalTank int) int { return (mainTank + min((mainTank-1)/4, additionalTank)) * 10}","link":"/leetcode/2024/04/total-distance-traveled/index.html"},{"title":"1491. 去掉最低工资和最高工资后的工资平均值","text":"去掉最低工资和最高工资后的工资平均值 难度: easy 原始链接: https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary 标签: 循环 解法一: 循环go1234567891011func average(salary []int) float64 { minSalary := math.MaxInt maxSalary := math.MinInt sum := 0 for _, num := range salary { sum += num minSalary = min(minSalary, num) maxSalary = max(maxSalary, num) } return float64(sum-minSalary-maxSalary) / float64(len(salary)-2)}","link":"/leetcode/2024/05/average-salary-excluding-the-minimum-and-maximum-salary/index.html"},{"title":"2960. 统计已测试设备","text":"统计已测试设备 难度: easy 原始链接: https://leetcode.cn/problems/count-tested-devices-after-test-operations 标签: 一次遍历 解法一: 一次遍历go123456789func countTestedDevices(batteryPercentages []int) int { ans := 0 for _, batteryPercentage := range batteryPercentages { if batteryPercentage-ans &gt; 0 { ans++ } } return ans}","link":"/leetcode/2024/05/count-tested-devices-after-test-operations/index.html"},{"title":"2903. 找出满足差值条件的下标 I","text":"找出满足差值条件的下标 I 难度: medium 原始链接: https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i 标签: 双层循环 解法一: 双层循环go123456789101112131415161718func findIndices(nums []int, indexDifference int, valueDifference int) []int { n := len(nums) for i := 0; i &lt; n; i++ { for j := i + indexDifference; j &lt; n; j++ { if abs(nums[i]-nums[j]) &gt;= valueDifference { return []int{i, j} } } } return []int{-1, -1}}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2024/05/find-indices-with-index-and-value-difference-i/index.html"},{"title":"2981. 找出出现至少三次的最长特殊子字符串 I","text":"找出出现至少三次的最长特殊子字符串 I 难度: medium 原始链接: https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718192021222324252627func maximumLength(s string) int { numList := make([][]int, 26) n := len(s) count := 0 for i := 0; i &lt; n; i++ { count++ if i == n-1 || s[i] != s[i+1] { numList[s[i]-'a'] = append(numList[s[i]-'a'], count) count = 0 } } ans := 0 for _, list := range numList { if len(list) == 0 { continue } sort.Slice(list, func(i, j int) bool { return list[i] &gt;= list[j] }) list = append(list, 0, 0) ans = max(ans, max(list[0]-2, max(min(list[0]-1, list[1]), list[2]))) } if ans == 0 { return -1 } return ans}","link":"/leetcode/2024/05/find-longest-special-substring-that-occurs-thrice-i/index.html"},{"title":"2982. 找出出现至少三次的最长特殊子字符串 II","text":"找出出现至少三次的最长特殊子字符串 II 难度: medium 原始链接: https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718192021222324252627func maximumLength(s string) int { numList := make([][]int, 26) n := len(s) count := 0 for i := 0; i &lt; n; i++ { count++ if i == n-1 || s[i] != s[i+1] { numList[s[i]-'a'] = append(numList[s[i]-'a'], count) count = 0 } } ans := 0 for _, list := range numList { if len(list) == 0 { continue } sort.Slice(list, func(i, j int) bool { return list[i] &gt;= list[j] }) list = append(list, 0, 0) ans = max(ans, max(list[0]-2, max(min(list[0]-1, list[1]), list[2]))) } if ans == 0 { return -1 } return ans}","link":"/leetcode/2024/05/find-longest-special-substring-that-occurs-thrice-ii/index.html"},{"title":"2965. 找出缺失和重复的数字","text":"找出缺失和重复的数字 难度: easy 原始链接: https://leetcode.cn/problems/find-missing-and-repeated-values 标签: 哈希 解法一: 哈希go12345678910111213141516171819func findMissingAndRepeatedValues(grid [][]int) []int { n := len(grid) countMap := make([]int, n*n+1) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { countMap[grid[i][j]]++ } } zero := 0 two := 0 for i := 1; i &lt;= n*n; i++ { if countMap[i] == 0 { zero = i } else if countMap[i] == 2 { two = i } } return []int{two, zero}}","link":"/leetcode/2024/05/find-missing-and-repeated-values/index.html"},{"title":"2028. 找出缺失的观测数据","text":"找出缺失的观测数据 难度: medium 原始链接: https://leetcode.cn/problems/find-missing-observations 标签: 数学 解法一: 数学go1234567891011121314151617181920func missingRolls(rolls []int, mean int, n int) []int { m := len(rolls) sum := mean * (m + n) curSum := 0 for _, roll := range rolls { curSum += roll } subSum := sum - curSum if subSum &lt; n || subSum &gt; 6*n { return []int{} } ans := make([]int, n) per := subSum / n div := subSum - per*n for i := 0; i &lt; n; i++ { ans[i] = per + min(1, div) div = max(0, div-1) } return ans}","link":"/leetcode/2024/05/find-missing-observations/index.html"},{"title":"2225. 找出输掉零场或一场比赛的玩家","text":"找出输掉零场或一场比赛的玩家 难度: medium 原始链接: https://leetcode.cn/problems/find-players-with-zero-or-one-losses 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718func findWinners(matches [][]int) [][]int { loseCount := make(map[int]int) for _, match := range matches { if loseCount[match[0]] == 0 { loseCount[match[0]] = 0 } loseCount[match[1]]++ } ans := make([][]int, 2) for key, val := range loseCount { if val &lt;= 1 { ans[val] = append(ans[val], key) } } sort.Ints(ans[0]) sort.Ints(ans[1]) return ans}","link":"/leetcode/2024/05/find-players-with-zero-or-one-losses/index.html"},{"title":"2831. 找出最长等值子数组","text":"找出最长等值子数组 难度: medium 原始链接: https://leetcode.cn/problems/find-the-longest-equal-subarray 标签: 滑动窗口 解法一: 滑动窗口go1234567891011121314151617181920func longestEqualSubarray(nums []int, k int) int { numListMap := make(map[int][]int) for i, num := range nums { numListMap[num] = append(numListMap[num], i) } ans := 0 for _, list := range numListMap { n := len(list) left := 0 right := 0 for right &lt; n { for list[right]-list[left]-right+left &gt; k { left++ } ans = max(ans, right-left+1) right++ } } return ans}","link":"/leetcode/2024/05/find-the-longest-equal-subarray/index.html"},{"title":"2769. 找出最大的可达成数字","text":"找出最大的可达成数字 难度: easy 原始链接: https://leetcode.cn/problems/find-the-maximum-achievable-number 标签: 直接计算 解法一: 直接计算go123func theMaximumAchievableX(num int, t int) int { return num + (t &lt;&lt; 1)}","link":"/leetcode/2024/05/find-the-maximum-achievable-number/index.html"},{"title":"2644. 找出可整除性得分最大的整数","text":"找出可整除性得分最大的整数 难度: easy 原始链接: https://leetcode.cn/problems/find-the-maximum-divisibility-score 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617func maxDivScore(nums []int, divisors []int) int { ans := divisors[0] maxCount := 0 for _, divisor := range divisors { curCount := 0 for _, num := range nums { if num%divisor == 0 { curCount++ } } if curCount &gt; maxCount || curCount == maxCount &amp;&amp; ans &gt; divisor { maxCount = curCount ans = divisor } } return ans}","link":"/leetcode/2024/05/find-the-maximum-divisibility-score/index.html"},{"title":"1673. 找出最具竞争力的子序列","text":"找出最具竞争力的子序列 难度: medium 原始链接: https://leetcode.cn/problems/find-the-most-competitive-subsequence 标签: 单调栈 解法一: 单调栈go12345678910111213func mostCompetitive(nums []int, k int) []int { stack := []int{} n := len(nums) for i, num := range nums { for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] &gt; num &amp;&amp; (len(stack)-1+n-i) &gt;= k { stack = stack[:len(stack)-1] } if len(stack) &lt; k { stack = append(stack, num) } } return stack}","link":"/leetcode/2024/05/find-the-most-competitive-subsequence/index.html"},{"title":"2951. 找出峰值","text":"找出峰值 难度: easy 原始链接: https://leetcode.cn/problems/find-the-peaks 标签: 循环 解法一: 循环go1234567891011func findPeaks(mountain []int) []int { ans := []int{} n := len(mountain) for i := 1; i &lt; n-1; i++ { if mountain[i] &gt; mountain[i-1] &amp;&amp; mountain[i] &gt; mountain[i+1] { ans = append(ans, i) i++ } } return ans}","link":"/leetcode/2024/05/find-the-peaks/index.html"},{"title":"1535. 找出数组游戏的赢家","text":"找出数组游戏的赢家 难度: medium 原始链接: https://leetcode.cn/problems/find-the-winner-of-an-array-game 标签: 模拟 解法一: 模拟go12345678910111213func getWinner(arr []int, k int) int { n := len(arr) countMap := make(map[int]int, n) cur := arr[0] for i := 1; i &lt; n; i++ { cur = max(cur, arr[i]) countMap[cur]++ if countMap[cur] &gt;= k { return cur } } return cur}","link":"/leetcode/2024/05/find-the-winner-of-an-array-game/index.html"},{"title":"1953. 你可以工作的最大周数","text":"你可以工作的最大周数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work 标签: 数学 解法一: 数学go12345678910111213func numberOfWeeks(milestones []int) int64 { maxVal := int64(0) sum := int64(0) for _, milestone := range milestones { maxVal = max(maxVal, int64(milestone)) sum += int64(milestone) } sum -= maxVal if sum+1 &gt;= maxVal { return sum + maxVal } return (sum &lt;&lt; 1) + 1}","link":"/leetcode/2024/05/maximum-number-of-weeks-for-which-you-can-work/index.html"},{"title":"2391. 收集垃圾的最少总时间","text":"收集垃圾的最少总时间 难度: medium 原始链接: https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617181920func garbageCollection(garbage []string, travel []int) int { n := len(garbage) ans := 0 cur := 0 countMap := map[byte]int{ 'M': 0, 'P': 0, 'G': 0, } travel = append(travel, 0) for i := 0; i &lt; n; i++ { m := len(garbage[i]) ans += m for j := 0; j &lt; m; j++ { countMap[garbage[i][j]] = cur } cur += travel[i] } return ans + countMap['M'] + countMap['P'] + countMap['G']}","link":"/leetcode/2024/05/minimum-amount-of-time-to-collect-garbage/index.html"},{"title":"2244. 完成所有任务需要的最少轮数","text":"完成所有任务需要的最少轮数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks 标签: 贪心 解法一: 贪心go1234567891011121314func minimumRounds(tasks []int) int { countMap := make(map[int]int, len(tasks)) for _, task := range tasks { countMap[task]++ } ans := 0 for _, count := range countMap { if count == 1 { return -1 } ans += (count + 2) / 3 } return ans}","link":"/leetcode/2024/05/minimum-rounds-to-complete-all-tasks/index.html"},{"title":"826. 安排工作以达到最大收益","text":"安排工作以达到最大收益 难度: medium 原始链接: https://leetcode.cn/problems/most-profit-assigning-work 标签: 排序 解法一: 排序go1234567891011121314151617181920212223242526272829func maxProfitAssignment(difficulty []int, profit []int, worker []int) int { type work struct { d int p int } n := len(difficulty) arr := make([]work, n) for i := 0; i &lt; n; i++ { arr[i] = work{ d: difficulty[i], p: profit[i], } } sort.Slice(arr, func(i, j int) bool { return arr[i].d &lt;= arr[j].d }) sort.Ints(worker) ans := 0 i := 0 maxVal := 0 for _, w := range worker { for i &lt; n &amp;&amp; w &gt;= arr[i].d { maxVal = max(maxVal, arr[i].p) i++ } ans += maxVal } return ans}","link":"/leetcode/2024/05/most-profit-assigning-work/index.html"},{"title":"994. 腐烂的橘子","text":"腐烂的橘子 难度: medium 原始链接: https://leetcode.cn/problems/rotting-oranges 标签: 广度优先遍历 解法一: 广度优先遍历go123456789101112131415161718192021222324252627282930313233343536373839404142434445func orangesRotting(grid [][]int) int { m := len(grid) n := len(grid[0]) queue := []int{} fresh := 0 for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { if grid[i][j] == 1 { fresh++ } else if grid[i][j] == 2 { queue = append(queue, i*n+j) } } } directions := [][]int{ {-1, 0}, {0, 1}, {1, 0}, {0, -1}, } ans := 0 for len(queue) &gt; 0 &amp;&amp; fresh &gt; 0 { size := len(queue) for i := 0; i &lt; size; i++ { sum := queue[i] row := sum / n col := sum - row*n for _, direction := range directions { newRow := row + direction[0] newCol := col + direction[1] if newRow &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; n &amp;&amp; grid[newRow][newCol] == 1 { fresh-- grid[newRow][newCol] = 2 queue = append(queue, newRow*n+newCol) } } } queue = queue[size:] ans++ } if fresh &gt; 0 { return -1 } return ans}","link":"/leetcode/2024/05/rotting-oranges/index.html"},{"title":"2462. 雇佣 K 位工人的总代价","text":"雇佣 K 位工人的总代价 难度: medium 原始链接: https://leetcode.cn/problems/total-cost-to-hire-k-workers 标签: 优先级队列 解法一: 优先级队列java123456789101112131415161718192021222324252627282930class Solution { public long totalCost(int[] costs, int k, int candidates) { PriorityQueue&lt;Integer&gt; leftQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); PriorityQueue&lt;Integer&gt; rightQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); int n = costs.length; int left = 0; int right = n - 1; for (int i = 0; i &lt; candidates &amp;&amp; left &lt;= right; i++) { leftQueue.offer(costs[left++]); if (left &lt;= right) { rightQueue.offer(costs[right--]); } } long ans = 0L; while (k-- &gt; 0) { if (leftQueue.isEmpty() || !rightQueue.isEmpty() &amp;&amp; leftQueue.peek() &gt; rightQueue.peek()) { ans += rightQueue.poll(); while (left &lt;= right &amp;&amp; rightQueue.size() &lt; candidates) { rightQueue.offer(costs[right--]); } } else { ans += leftQueue.poll(); while (left &lt;= right &amp;&amp; leftQueue.size() &lt; candidates) { leftQueue.offer(costs[left++]); } } } return ans; }}","link":"/leetcode/2024/05/total-cost-to-hire-k-workers/index.html"},{"title":"LeetCode 竞赛分 1800","text":"LeetCode 竞赛分 1800 纪念","link":"/leetcode/2024/05/version1.0.0/index.html"},{"title":"2105. 给植物浇水 II","text":"给植物浇水 II 难度: medium 原始链接: https://leetcode.cn/problems/watering-plants-ii 标签: 贪心 解法一: 贪心go12345678910111213141516171819202122232425262728func minimumRefill(plants []int, capacityA int, capacityB int) int { a := capacityA b := capacityB ans := 0 left := 0 right := len(plants) - 1 for left &lt;= right { if left == right { if a &lt; plants[left] &amp;&amp; b &lt; plants[left] { ans++ } break } if a &lt; plants[left] { ans++ a = capacityA } a -= plants[left] if b &lt; plants[right] { ans++ b = capacityB } b -= plants[right] left++ right-- } return ans}","link":"/leetcode/2024/05/watering-plants-ii/index.html"},{"title":"2079. 给植物浇水","text":"给植物浇水 难度: medium 原始链接: https://leetcode.cn/problems/watering-plants 标签: 贪心 解法一: 贪心go12345678910111213func wateringPlants(plants []int, capacity int) int { cur := capacity ans := 0 for i, plant := range plants { if plant &gt; cur { ans += i &lt;&lt; 1 cur = capacity } ans++ cur -= plant } return ans}","link":"/leetcode/2024/05/watering-plants/index.html"},{"title":"LCP 61. 气温变化趋势","text":"气温变化趋势 难度: easy 原始链接: https://leetcode.cn/problems/6CE719 标签: 循环 解法一: 循环go1234567891011121314151617181920212223func temperatureTrend(temperatureA []int, temperatureB []int) int { ans := 0 cur := 0 n := len(temperatureA) for i := 1; i &lt; n; i++ { if compare(temperatureA[i], temperatureA[i-1]) == compare(temperatureB[i], temperatureB[i-1]) { cur++ ans = max(ans, cur) } else { cur = 0 } } return ans}func compare(num1, num2 int) int { if num1 == num2 { return 0 } else if num1 &gt; num2 { return 1 } return -1}","link":"/leetcode/2024/06/6CE719/index.html"},{"title":"2806. 取整购买后的账户余额","text":"取整购买后的账户余额 难度: easy 原始链接: https://leetcode.cn/problems/account-balance-after-rounded-purchase 标签: 四舍五入 解法一: 四舍五入go123func accountBalanceAfterPurchase(purchaseAmount int) int { return 100 - ((purchaseAmount+5)/10)*10}","link":"/leetcode/2024/06/account-balance-after-rounded-purchase/index.html"},{"title":"2288. 价格减免","text":"价格减免 难度: medium 原始链接: https://leetcode.cn/problems/apply-discount-to-prices 标签: 模拟 解法一: 模拟go123456789101112131415161718192021222324func discountPrices(sentence string, discount int) string { strArr := strings.Split(sentence, &quot; &quot;) n := len(strArr) for i := 0; i &lt; n; i++ { if checkMoney(strArr[i]) { num, _ := strconv.Atoi(strArr[i][1:]) strArr[i] = fmt.Sprintf(&quot;$%.2f&quot;, float64(num*100-num*discount)/100.0) } } return strings.Join(strArr, &quot; &quot;)}func checkMoney(str string) bool { n := len(str) if n &lt; 2 || str[0] != '$' { return false } for i := 1; i &lt; n; i++ { if str[i] &lt; '0' || str[i] &gt; '9' { return false } } return true}","link":"/leetcode/2024/06/apply-discount-to-prices/index.html"},{"title":"419. 甲板上的战舰","text":"甲板上的战舰 难度: medium 原始链接: https://leetcode.cn/problems/battleships-in-a-board 标签: 脑筋急转弯 解法一: 脑筋急转弯go123456789101112131415func countBattleships(board [][]byte) int { ans := 0 rLen := len(board) cLen := len(board[0]) for r := 0; r &lt; rLen; r++ { for c := 0; c &lt; cLen; c++ { if board[r][c] == 'X' &amp;&amp; (r == 0 || r &gt; 0 &amp;&amp; board[r-1][c] == '.') &amp;&amp; (c == 0 || c &gt; 0 &amp;&amp; board[r][c-1] == '.') { ans++ } } } return ans}","link":"/leetcode/2024/06/battleships-in-a-board/index.html"},{"title":"881. 救生艇","text":"救生艇 难度: medium 原始链接: https://leetcode.cn/problems/boats-to-save-people 标签: 贪心 解法一: 完全贪心java1234567891011121314151617class Solution { public int numRescueBoats(int[] people, int limit) { Arrays.sort(people); int n = people.length; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); int ans = 0; for (int i = n - 1; i &gt;= 0; i--) { if (!priorityQueue.isEmpty() &amp;&amp; people[i] &lt;= priorityQueue.peek()) { priorityQueue.poll(); } else { ans++; priorityQueue.offer(limit - people[i]); } } return ans; }} 解法二: 贪心go123456789101112131415func numRescueBoats(people []int, limit int) int { sort.Ints(people) n := len(people) left := 0 right := n - 1 ans := 0 for left &lt;= right { if people[left]+people[right] &lt;= limit { left++ } right-- ans++ } return ans}","link":"/leetcode/2024/06/boats-to-save-people/index.html"},{"title":"3067. 在带权树网络中统计可连接服务器对数目","text":"分糖果 难度: medium 原始链接: https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334func countPairsOfConnectableServers(edges [][]int, signalSpeed int) []int { n := len(edges) + 1 grid := make([][][]int, n) for _, edge := range edges { grid[edge[0]] = append(grid[edge[0]], []int{edge[1], edge[2]}) grid[edge[1]] = append(grid[edge[1]], []int{edge[0], edge[2]}) } var dfs func(int, int, int) int dfs = func(cur, parent, sum int) int { count := 0 if sum%signalSpeed == 0 { count++ } for _, node := range grid[cur] { if node[0] != parent { count += dfs(node[0], cur, sum+node[1]) } } return count } ans := make([]int, n) for i := 0; i &lt; n; i++ { if len(grid[i]) &lt;= 1 { continue } sum := 0 for _, node := range grid[i] { count := dfs(node[0], i, node[1]) ans[i] += count * sum sum += count } } return ans}","link":"/leetcode/2024/06/count-pairs-of-connectable-servers-in-a-weighted-tree-network/index.html"},{"title":"520. 检测大写字母","text":"检测大写字母 难度: easy 原始链接: https://leetcode.cn/problems/detect-capital 标签: 模拟 解法一: 模拟go12345678910111213141516func detectCapitalUse(word string) bool { n := len(word) // true：大写；false：小写 fisrtUpper := word[0] &lt;= 'Z' pre := false for i := 1; i &lt; n; i++ { if i == 1 { pre = word[i] &lt;= 'Z' continue } if pre != (word[i] &lt;= 'Z') { return false } } return fisrtUpper || !fisrtUpper &amp;&amp; !pre}","link":"/leetcode/2024/06/detect-capital/index.html"},{"title":"2928. 给小朋友们分糖果 I","text":"给小朋友们分糖果 I 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies-among-children-i 标签: 数学 解法一: 数学go12345678910111213func distributeCandies(n int, limit int) int { ans := 0 for i := 0; i &lt;= n &amp;&amp; i &lt;= limit; i++ { rest := n - i if rest &gt; (limit &lt;&lt; 1) { continue } maxVal := min(limit, rest) minVal := max(0, rest-limit) ans += maxVal - minVal + 1 } return ans}","link":"/leetcode/2024/06/distribute-candies-among-children-i/index.html"},{"title":"1103. 分糖果 II","text":"分糖果 II 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies-to-people 标签: 模拟 解法一: 哈希go12345678func distributeCandies(candies int, num_people int) []int { ans := make([]int, num_people) for i := 0; candies &gt; 0; i++ { ans[i%num_people] += min(i+1, candies) candies -= i + 1 } return ans}","link":"/leetcode/2024/06/distribute-candies-to-people/index.html"},{"title":"575. 分糖果","text":"分糖果 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies 标签: 哈希 解法一: 哈希go12345678func distributeCandies(candyType []int) int { n := len(candyType) typeHash := make(map[int]bool) for i := 0; i &lt; n; i++ { typeHash[candyType[i]] = true } return min(n&gt;&gt;1, len(typeHash))}","link":"/leetcode/2024/06/distribute-candies/index.html"},{"title":"2734. 执行子串操作后的字典序最小字符串","text":"执行子串操作后的字典序最小字符串 难度: medium 原始链接: https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation 标签: 贪心 解法一: 贪心go123456789101112131415func smallestString(s string) string { ans := []byte(s) n := len(s) for i := 0; i &lt; n; i++ { if ans[i] != 'a' { for i &lt; n &amp;&amp; ans[i] != 'a' { ans[i]-- i++ } return string(ans) } } ans[n-1] = 'z' return string(ans)}","link":"/leetcode/2024/06/lexicographically-smallest-string-after-substring-operation/index.html"},{"title":"522. 最长特殊序列 II","text":"最长特殊序列 II 难度: medium 原始链接: https://leetcode.cn/problems/longest-uncommon-subsequence-ii 标签: 枚举 解法一: 枚举go12345678910111213141516171819202122232425262728293031323334353637383940func findLUSlength(strs []string) int { ans := -1 for i, str1 := range strs { n := len(str1) if ans &gt;= n { continue } isUnique := true for j, str2 := range strs { if i != j &amp;&amp; check(str1, str2) { isUnique = false break } } if isUnique { ans = max(ans, n) } } return ans}func check(str1, str2 string) bool { n1 := len(str1) n2 := len(str2) if n1 &gt; n2 { return false } i1 := 0 i2 := 0 for i1 &lt; n1 { if i2 &gt;= n2 { return false } if str1[i1] == str2[i2] { i1++ } i2++ } return true}","link":"/leetcode/2024/06/longest-uncommon-subsequence-ii/index.html"},{"title":"2779. 数组的最大美丽值","text":"数组的最大美丽值 难度: medium 原始链接: https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation 标签: 滑动窗口 解法一: 滑动窗口go123456789101112131415func maximumBeauty(nums []int, k int) int { sort.Ints(nums) left := 0 right := 0 n := len(nums) ans := 0 for right &lt; n { for left &lt;= right &amp;&amp; nums[right]-nums[left] &gt; (k&lt;&lt;1) { left++ } ans = max(ans, right-left+1) right++ } return ans}","link":"/leetcode/2024/06/maximum-beauty-of-an-array-after-applying-operation/index.html"},{"title":"3038. 相同分数的最大操作数目 I","text":"相同分数的最大操作数目 I 难度: easy 原始链接: https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i 标签: 模拟 解法一: 模拟go123456789101112func maxOperations(nums []int) int { n := len(nums) ans := 1 sum := nums[0] + nums[1] for i := 3; i &lt; n; i += 2 { if nums[i]+nums[i-1] != sum { break } ans++ } return ans}","link":"/leetcode/2024/06/maximum-number-of-operations-with-the-same-score-i/index.html"},{"title":"3040. 相同分数的最大操作数目 II","text":"相同分数的最大操作数目 II 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii 标签: 递归 解法一: 递归go12345678910111213141516171819202122232425262728293031323334353637func maxOperations(nums []int) int { n := len(nums) cache := make([][]int, n) for i := range cache { cache[i] = make([]int, n) for j := range cache[i] { cache[i][j] = -1 } } return max(dfs(nums, nums[0]+nums[1], 0, 2, n-1, cache), max(dfs(nums, nums[n-2]+nums[n-1], 0, 0, n-3, cache), dfs(nums, nums[0]+nums[n-1], 0, 1, n-2, cache))) + 1}func dfs(nums []int, sum, count, left, right int, cache [][]int) int { if left &gt;= right { return 0 } if cache[left][right] != -1 { return cache[left][right] } curCount := 0 // 前两个元素 if sum == nums[left]+nums[left+1] { curCount = max(curCount, 1+dfs(nums, sum, count, left+2, right, cache)) } // 最后两个元素 if sum == nums[right]+nums[right-1] { curCount = max(curCount, 1+dfs(nums, sum, count, left, right-2, cache)) } // 前后两个元素 if sum == nums[left]+nums[right] { curCount = max(curCount, 1+dfs(nums, sum, count, left+1, right-1, cache)) } cache[left][right] = count + curCount return cache[left][right]}","link":"/leetcode/2024/06/maximum-number-of-operations-with-the-same-score-ii/index.html"},{"title":"2713. 矩阵中严格递增的单元格数","text":"矩阵中严格递增的单元格数 难度: hard 原始链接: https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix 标签: 动态规划 解法一: 动态规划go1234567891011121314151617181920212223242526272829303132333435func maxIncreasingCells(mat [][]int) int { type point struct { x int y int } m := len(mat) n := len(mat[0]) points := make(map[int][]point) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { points[mat[i][j]] = append(points[mat[i][j]], point{ x: i, y: j, }) } } pointKeys := make([]int, 0, len(points)) for key := range points { pointKeys = append(pointKeys, key) } slices.Sort(pointKeys) maxRows := make([]int, m) maxCols := make([]int, n) for _, key := range pointKeys { maxNums := make([]int, len(points[key])) for i, point := range points[key] { maxNums[i] = max(maxRows[point.x], maxCols[point.y]) + 1 } for i, point := range points[key] { maxRows[point.x] = max(maxRows[point.x], maxNums[i]) maxCols[point.y] = max(maxCols[point.y], maxNums[i]) } } return slices.Max(maxRows)}","link":"/leetcode/2024/06/maximum-strictly-increasing-cells-in-a-matrix/index.html"},{"title":"503. 下一个更大元素 II","text":"下一个更大元素 II 难度: medium 原始链接: https://leetcode.cn/problems/next-greater-element-ii 标签: 单调栈 解法一: 单调栈go12345678910111213141516func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) for i := 0; i &lt; n; i++ { ans[i] = -1 } stack := []int{} for i := 0; i &lt; (n &lt;&lt; 1); i++ { for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack)-1]%n] &lt; nums[i%n] { ans[stack[len(stack)-1]%n] = nums[i%n] stack = stack[:len(stack)-1] } stack = append(stack, i) } return ans}","link":"/leetcode/2024/06/next-greater-element-ii/index.html"},{"title":"2748. 美丽下标对的数目","text":"最长特殊序列 II 难度: easy 原始链接: https://leetcode.cn/problems/number-of-beautiful-pairs 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425func countBeautifulPairs(nums []int) int { ans := 0 countArr := make([]int, 10) for _, num := range nums { num1 := num % 10 for j := 1; j &lt; 10; j++ { if countArr[j] &gt; 0 &amp;&amp; gcd(j, num1) == 1 { ans += countArr[j] } } num2 := num for num2 &gt;= 10 { num2 /= 10 } countArr[num2]++ } return ans}func gcd(num1, num2 int) int { if num2 == 0 { return num1 } return gcd(num2, num1%num2)}","link":"/leetcode/2024/06/number-of-beautiful-pairs/index.html"},{"title":"2710. 移除字符串中的尾随零","text":"最长特殊序列 II 难度: easy 原始链接: https://leetcode.cn/problems/remove-trailing-zeros-from-a-string 标签: 模拟 解法一: 模拟go1234567func removeTrailingZeros(num string) string { i := len(num) - 1 for i &gt; 0 &amp;&amp; num[i] == '0' { i-- } return num[:i+1]}","link":"/leetcode/2024/06/remove-trailing-zeros-from-a-string/index.html"},{"title":"2938. 区分黑球与白球","text":"区分黑球与白球 难度: medium 原始链接: https://leetcode.cn/problems/separate-black-and-white-balls 标签: 双指针 解法一: 双指针go12345678910111213141516171819202122func minimumSteps(s string) int64 { n := len(s) bytes := []byte(s) left := n - 1 right := n - 1 ans := int64(0) for { for right &gt;= 0 &amp;&amp; bytes[right] == '1' { right-- } left = min(left, right-1) for left &gt;= 0 &amp;&amp; bytes[left] == '0' { left-- } if left &lt; 0 { break } bytes[left], bytes[right] = bytes[right], bytes[left] ans += int64(right - left) } return ans} 解法二: 逆向思维go123456789101112func minimumSteps(s string) int64 { ans := int64(0) sum := 0 for _, ch := range s { if ch == '1' { sum++ } else { ans += int64(sum) } } return ans}","link":"/leetcode/2024/06/separate-black-and-white-balls/index.html"},{"title":"494. 目标和","text":"目标和 难度: medium 原始链接: https://leetcode.cn/problems/target-sum 标签: 深度优先遍历 解法一: 深度优先遍历go123456789101112131415161718func findTargetSumWays(nums []int, target int) int { // f(i) = nums[i] + f(i - 1) // f(i) = -nums[i] + f(i - 1) ans := 0 var dfs func(int, int) dfs = func(i, cur int) { if i &lt; 0 { if cur == 0 { ans++ } return } dfs(i-1, cur+nums[i]) dfs(i-1, cur-nums[i]) } dfs(len(nums)-1, target) return ans}","link":"/leetcode/2024/06/target-sum/index.html"},{"title":"1958. 检查操作是否合法","text":"检查操作是否合法 难度: medium 原始链接: https://leetcode.cn/problems/check-if-move-is-legal 标签: 枚举 解法一: 枚举go1234567891011121314151617181920212223242526272829303132333435func calcClean(board [][]byte, rMove int, cMove int, color byte) int { m, n := len(board), len(board[0]) directions := []struct { x int y int }{ {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, } ans := 0 for _, direction := range directions { x := rMove + direction.x y := cMove + direction.y if x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] == '.' || board[x][y] == color { continue } cur := 1 for x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; board[x][y] != '.' { if board[x][y] == color { ans += cur break } cur++ x += direction.x y += direction.y } } return ans}","link":"/leetcode/2024/07/check-if-move-is-legal/index.html"},{"title":"3101. 交替子数组计数","text":"交替子数组计数 难度: medium 原始链接: https://leetcode.cn/problems/count-alternating-subarrays 标签: 双指针 解法一: 双指针go123456789101112131415func countAlternatingSubarrays(nums []int) int64 { n := len(nums) ans := int64(n) i := 0 j := 1 for j &lt; n { if nums[j] != nums[j-1] { ans += int64(j - i) } else { i = j } j++ } return ans}","link":"/leetcode/2024/07/count-alternating-subarrays/index.html"},{"title":"2970. 统计移除递增子数组的数目 I","text":"统计移除递增子数组的数目 I 难度: easy 原始链接: https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i 标签: 双指针 解法一: 双指针go12345678910111213141516171819202122232425262728func incremovableSubarrayCount(nums []int) int { n := len(nums) ans := 0 for i := 0; i &lt; n; i++ { for j := i; j &lt; n; j++ { isSucess := true preNum := -1 for k := 0; k &lt; i; k++ { if nums[k] &lt;= preNum { isSucess = false break } preNum = nums[k] } for k := j + 1; k &lt; n; k++ { if nums[k] &lt;= preNum { isSucess = false break } preNum = nums[k] } if isSucess { ans++ } } } return ans}","link":"/leetcode/2024/07/count-the-number-of-incremovable-subarrays-i/index.html"},{"title":"724. 寻找数组的中心下标","text":"寻找数组的中心下标 难度: easy 原始链接: https://leetcode.cn/problems/find-pivot-index 标签: 前缀和 解法一: 前缀和go123456789101112131415func pivotIndex(nums []int) int { sum := 0 for _, num := range nums { sum += num } leftSum := 0 for i, num := range nums { sum -= num if leftSum == sum { return i } leftSum += num } return -1}","link":"/leetcode/2024/07/find-pivot-index/index.html"},{"title":"3099. 哈沙德数","text":"哈沙德数 难度: easy 原始链接: https://leetcode.cn/problems/harshad-number 标签: 数学 解法一: 数学go12345678910111213141516func sumOfTheDigitsOfHarshadNumber(x int) int { sum := perSum(x) if x%sum == 0 { return sum } return -1}func perSum(num int) int { ans := 0 for num != 0 { ans += num % 10 num /= 10 } return ans}","link":"/leetcode/2024/07/harshad-number/index.html"},{"title":"3115. 质数的最大距离","text":"质数的最大距离 难度: medium 原始链接: https://leetcode.cn/problems/maximum-prime-difference 标签: 循环 解法一: 循环go1234567891011121314151617181920212223242526func maximumPrimeDifference(nums []int) int { left := 0 right := len(nums) - 1 for left &lt;= right { if isPrime(nums[left]) { break } left++ } for right &gt;= left { if isPrime(nums[right]) { break } right-- } return right - left}func isPrime(num int) bool { for i := 2; i*i &lt;= num; i++ { if num%i == 0 { return false } } return num &gt;= 2}","link":"/leetcode/2024/07/maximum-prime-difference/index.html"},{"title":"2974. 最小数字游戏","text":"最小数字游戏 难度: easy 原始链接: https://leetcode.cn/problems/minimum-number-game 标签: 排序 解法一: 排序go12345678func numberGame(nums []int) []int { sort.Ints(nums) n := len(nums) for i := 0; i &lt; n; i += 2 { nums[i], nums[i+1] = nums[i+1], nums[i] } return nums}","link":"/leetcode/2024/07/minimum-number-game/index.html"},{"title":"3033. 修改矩阵","text":"修改矩阵 难度: easy 原始链接: https://leetcode.cn/problems/modify-the-matrix 标签: 循环 解法一: 循环go12345678910111213141516func modifiedMatrix(matrix [][]int) [][]int { m := len(matrix) n := len(matrix[0]) for c := 0; c &lt; n; c++ { curMax := -1 for r := 0; r &lt; m; r++ { curMax = max(curMax, matrix[r][c]) } for r := 0; r &lt; m; r++ { if matrix[r][c] == -1 { matrix[r][c] = curMax } } } return matrix}","link":"/leetcode/2024/07/modify-the-matrix/index.html"},{"title":"面经 - 赣州市浩网科技有限公司","text":"赣州市浩网科技有限公司 2007年3月22日，赣南师范大学数学与计算机科学学院在校学生于2006年创立的”浩网工作室”正式注册为”赣州市浩网科技有限公司（简称：浩网科技）”，成为当年赣南师范大学在校学生创业成立的第一家公司。浩网科技是一家依托移动互联网、云计算、大数据、人工智能、物联网等技术创新，构建以“睿”系列SaaS云平台、APP、小程序为主的产品生态，为教育、房产、旅游、民生服务等领域智慧化升级提供自主创新的整体解决方案，集软件开发、手机App开发、微信/支付宝第三方平台及小程序开发、SaaS云平台、云服务器、IT咨询等多方面服务为一体的互联网技术公司。 目前可以提供的情报 听 hr 说 浩网科技 已经和 睿警信 合并了 公司的项目都是政务相关，主要是和警务相关，江西的许多市区都有使用他们的产品 公司正在扩张，开发团队将会扩张一倍。旧团队的后端开发貌似是主 php，不过面试我的面试官是 Javaer 貌似缴纳的是六险，转正之后才给缴纳一金，不过一金公司的那一边也需要个人承担(差不多就是不缴纳一金) 提供免费的中餐 公司月底会搬迁到赣州沙河区，可能会提供住宿，费用不知 单休，但每个月月底的那一周双休 试用期两个月，每个月有考核，大于80(还是85来着)拿全额绩效 公司的厕所真不咋滴，貌似也没有提供吸烟场所(走的时候看见技术面的面试官出来吸烟，虽然我不抽烟) 技术面 给你一条 sql 语句，你会怎么优化 表a left join 表b，有一个查询条件，这个查询条件加在 on 后面和加在 where 后面的区别 mysql 执行计划有哪些字段 redis 如何实现分布式锁 有没有做过 jvm 优化 jvm 监控呢 java8 特性 给你一个对象集合，对象所属的类有一个 BigDecimal 的属性，怎么通过 stream 流计算这个 BigDecimal 属性的总和 你使用过 juc 的哪些工具 项目中的线程池怎么管理 Linux 移动一个文件的命令，创建一个文件夹的命令 了解怎么写 shell 脚本吗 什么是 java 的多态 碎碎念纯八股就是这些，还问了一些项目上的东西，就不写出来了 最后问我 java 多态的时候我还回答错了，这个是最基本的东西。最后在面试官的提醒下也应该算回答出来了吧 问我 jvm 监控的时候，我差点答用过 Arthas，不过怕他多问，答的不知道 结果通知了复试，不过领导不在，需要另外安排时间再去一趟","link":"/mianjing/2023/10/haowang/index.html"},{"title":"面经 - 赣州网联科技有限公司","text":"赣州网联科技有限公司 赣州网联科技有限公司是一直致力于电子政务、软件开发、电子商务、系统集成等信息化解决方案专业提供商。在电子政务方面，2010年曾成功实施赣州党务公开平台网站群的建设，并在此领域更是积累了丰富的行业经验，逐步确立了在赣州本土化公司网站建设领域的领先地位。 赣州网联科技有限公司十分重视员工队伍建设。充分认识到高科技企业的竞争，归根结底是人才的竞争。公司旗下聚集了一大批技术、管理、工程实施等方面人才，形成了良好的人才结构，为公司的可持续发展提供了有力保障。“卓越的人才队伍+现代化的管理机制+优质的服务体系”使得赣州网联科技有限公司可以持之以恒地创立高品质、高性能和优质服务的本地化企业。公司将随同用户需求层次的提高而不断改进、调整以及扩大现有产品体系。 目前可以提供的情报 双休，加班不多 加班费用按薪资比例来计算 不包吃住 听面试官描述应该还在维护很老的项目(jsp那种) 公司的客户都是政务机关，主要是在做信创 维基百科的解释是：信创是中国大陆对于“信息技术应用创新”相关产业的简称，旨在推进用国产替代技术替换美国和其他外国技术，以期实现中国信息技术领域的自主可控，保障国家信息安全。 开发根据需要会外派去市政府驻场开发，需要有和客户当面沟通的能力 技术面面试我的面试官应该是 cpp 出身，提出的问题大多和 Java 本身关联性没那么强 除了 Java，还会 C++，Python 吗 C，C++，C# 和 Java 的区别 多态是什么 数据结构了解吗 堆是什么 哈希了解吗，数据结构是什么 哈希函数是什么 jvm 是什么 垃圾回收机制 C++ 和 Java 这种自带垃圾回收机制的语言的区别，为什么 C++ 的性能更高 有没有通过反编译看过源码，就是不带注释的那种源码 碎碎念聊的东西实际不止这么点，有些问题因为问的比较泛，导致一个问题用的时间也比较久 面试期间没有经过开发的办公场所，所以实际上并不清楚办公环境和实际人数 感觉在赣州的其他公司应该都不会问这些，本来没打算写面经的 说个好笑的事情。问到 堆是什么 的时候，我觉得我能回答出来，毕竟也是看过优先级队列源码的，它的底层数据结构就是堆，可结果我发现自己实际上描述不清楚堆是什么，说了半天之后，只好最后回答说不了解 维基百科解释是：堆（Heap）是计算机科学中的一种特别的完全二叉树。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。 结果 2023-10-19 14:48:00 暂无结果","link":"/mianjing/2023/10/wanglian/index.html"},{"title":"面经 - 一叶智能一面技术面","text":"一叶智能 – 一面面经公司简介听面试官说，以前本部是在北京，然后在江苏也有分布，现在在深圳的发展挺好的，总部正在往深圳这边迁移 面试官问空窗期 saas服务发布是怎么做的 项目中的redis主要用来做什么 项目中的gateway主要用来做什么 表a有一个复合索引 (a, b, c)，假设查询语句是 select b from a where a = ? and c = ? group by b，索引使用情况 大表的冷数据要通过什么方式迁移 大表索引变更要怎么做 threadlocal在多线程中如何使用 mybatis的拦截器有没有用过 myabtis中如果想要把一个对象保存为json格式要怎么做 项目中遇到的难点 上一份工作除了技术上，你觉得还给你了什么提升 未来的发展方向 反问贵公司目前的项目上使用到了哪些技术 贵公司的关系型数据库为什么选择了 postgresql，而不是 mysql","link":"/mianjing/2024/02/yishuyiye/index.html"},{"title":"面经 - 江西燃点","text":"江西燃点 – 面经情报面试是混面，技术面，主管面(一般针对个人经历，发展提问的面试我称之为主管面) 公司运营的项目目前趋于稳定，期望开发者拥有大数据方面的技能，可以给一定的时间给开发者来转这个方向 技术面面试官问二分法适用的场景 分布式事务中，有八个 rpc 修改类接口需要同步调用，现在发现整个事务执行效率较低，该如何优化 spring 中的循环依赖是如何解决的 有没有在网关层做过鉴权 ThreadLocal 使用场景，以及可能遇到的问题 有没有做过 sql 调优类的实践工作 有没有做过数据权限，要怎么实现 其他面试结果在本周内会给回复 这算是第一个打开了我个人博客的面试官，虽然我的个人博客并没有很么干货，感动ing，呜呜呜～～","link":"/mianjing/2024/03/jiang-xi-ran-dian/index.html"},{"title":"面经 - 深圳同行者","text":"深圳同行者 – 技术面面经情报 约的面试是下午 3 点，签到的时候就发现有好些人都是去面试这家公司的，有 Java，有测试，有实习。 到了之后公司门口的会客室一堆人在做笔试题，面试 Java 的人比较多，我笔试的时候对面坐的人也是面试 Java的 面试有两轮，第一轮问八股多一些，第二轮会结合场景问实际应用 笔试 三道算法题，一道sql题 算法题没有给出方法签名 有 1000 个数，取值取值范围是 [0, 999]，其中有两个数出现了两次，要求找出这个重复的数 sql 题，题目比较长，题目就不写了，需要用到 group by，having 以及 聚合函数 设计一个程序，可以让两个线程交替打印从0到n的数字 应该是 LeetCode 原题，这会儿没找到是哪个原题，但印象中我做过 打印26个小写字母的所有不重复排列组合，每个字母只能使用一次，类似于a，ab，abc这种都算是一个合法的组合 一轮技术面面试官问数据冷热分离是怎么做的 开源项目的 star 是多少 笔试第四题的结果数量有多少 二轮技术面 二轮面试的面试官就在面试的等待区面试，其他人是可以听见面试的过程 不过二轮面试的面试官对每个人问的问题不尽相同，我面试之前这个面试官对另一位面试者问了笔试的第 3 题，也稍微深入问了下 gc 对于公司批量通知十多个面试者同一时间段来笔试的行为我心里有点不爽，对于二轮技术面的面试官直接在面试等待区面试的行为我表示贵公司没有对面试者给到基本的尊重 面试官问谈谈你对 CAS 的理解 这里我回答，基于 CAS 的轻量级锁比重锁更节省系统资源。然后被面试官打脸了，后面面试官一步步引导我玩正确的方向回答 你是如何分析 jvm 的 dump 文件的 笔试第一题我使用数组计数的方式来做的，也可以换成使用 map 来计数，面试官要求使用 O(1) 空间复杂度求解，需要现场写，面试官就在旁边看着 有没有自己搞过一些开源的工具类 开源项目中使用的 netty 是做什么用的 有没有在 gateway 中进行限流 是否有独立负责的微服务项目 最近一个项目的架构图，需要现场画出来 有一个接口需要做限流，每天每个用户有额定的调用次数，然后随后系统还有一个总的调用次数，调用次数达到这个用户的调用次数或者达到总的调用次数上限都要做限流，你的方案是什么 进度二面的面试官说，差不多两天会给通知","link":"/mianjing/2024/03/tongxingzhe/index.html"},{"title":"面经 - 行云绽放","text":"行云绽放 – 技术面面经情报 公司有三个产品，按我的理解，是比较偏向安全类的产品。比如，数据库操作层面的安全，服务器操作层面的安全 对开发而言，要求会网络编程 面试流程上分为笔试 + 一面（技术面）+ 二面（偏向主管面，偶尔也问点技术问题） 笔试主要说说最后的三个大题 写一个延迟加载的单例 给一个byte数组，要求写入指定文件，如果文件已经存在，则采用追加写，否则创建该文件并写入字节数组 有一个程序运行有一些问题，具体的问题如下，分别写出排查和定位的过程 CPU占用过高 出现了OOM异常 出现了open too many files异常 其他笔试还有两个填写关键代码的算法，分别是冒泡排序和二分查找 笔试中除了第二题考了字节流，选择题中也有考字节流 一轮技术面Java 常用的数据结构，说说你对 List，Queue 的看法 线程池的参数 创建线程的方法 如果有一批任务被提交给线程池，线程池是怎么分排线程的 Linux 常用命令 查询指定时间范围内的日志的 Linux 命令 jvm 内存结构 对于这种文件最好和面试官说明是想要问 java内存模型 还是 jvm运行时内存区域 分布式锁是使用redis来实现的吗 jdk 原生自带了 nio 的一套 api，为什么还要用 netty 呢，好处是什么 二轮主管面如果和其他同事发生了冲突，不一定是字面意义上的冲突，也可能是观念上的不认同，具体的场景比如，测试反馈了一个bug，但你不认为这是一个bug，你会怎么做 工作中有没有遇到什么难题，又是怎么解决的 你觉得自己有什么优点 你觉得自己有什么缺点 你期望一个怎么样的工作环境","link":"/mianjing/2024/03/xingyunzhangfang/index.html"},{"title":"面经 - 一临云科技","text":"一临云科技 – 一面面经公司简介一家医疗行业的公司，在深圳和成都有分布，深圳这边的开发大概二十多人，测试都在成都，有交流通过线上会议的方式进行 面试官问自我介绍 数据冷热分离是怎么做的 对线程池的理解 redis 在项目的用处 redis 分布锁的实现 gateway 在项目中的用处 要怎么保证 mq 消息不丢失 sql 优化 索引失效的情况有哪些 仔细谈谈最左匹配原则 回表是什么 反问深圳这边的开发规模 开发团队 20 人左右 面试的流程，是否还有二面 线上一面，最好线下二面","link":"/mianjing/2024/03/yilinyun/index.html"},{"title":"面经 - 易世通达(跨境电商)技术面","text":"易世通达(跨境电商) – 技术面面经前言不知道其他人是怎么理解电商的，我以前一直以为电商这一行的互联网是自己搞购物平台，但这家公司和我说，公司主要做海外的电商业务，对商品的上下架，机器人客服啥的，这才是电商 公司简介强调了加班，周末有事情也要加班，不过公司提供住宿来着，就是不知道住宿的环境如何 一面面试官问线程池的参数有哪些 如果要实现核心线程也能被回收，要怎么做 es 是否了解 HashMap的put流程 链表变红黑树的条件 线程安全的map 简单说说ConcurrentHashMap是怎么保证线程安全的 你对b+树的了解 一道需要分组聚合查询的sql题，比较简单，面试官现场出题需要现场写查询sql 二面面试官问有没有遇到过tomcat线程阻塞的场景 gateway使用的是容器是什么，tomcat还是netty 举一个mysql死锁的例子 nacos一致性协议有哪些 gRPC是否了解 http2是否了解 quartz框架是否可以通过手动修改cron的方式不停机更新cron xxl-job是否有了解","link":"/mianjing/2024/03/yishitongda/index.html"},{"title":"面经 - 卓讯信息技术","text":"卓讯信息技术 – 技术面面经公司简介公司简介上写的时候双休，每天工作7小时，但hr给我的表态是还是得一周工作至少40小时，估计多的5小时是不算加班费的 技术面的面试官给我的信息是，工作会很忙，周六也要加班，大概可以理解为 996 吧，hr给我的反馈是周末加班算调休，但我猜测有概率是不给任何薪水或者调休补偿的 面试前公司需要收集的信息有点越界了，除了要写每家公司的证明人和联系电话，还要求填写自己的优缺点，工作过公司的一些对标企业 公司目前做的项目是一个低代码平台，面向的客户也是政府机关 笔试 笔试题整体偏简单（除了问 Session 失效的 api 以外），题量也不大，主要考 sql 查询 如何使 Servlet 中的 Session 对象失效，然后有四个选项。笔试后我查询了一下，应该选第3个 session.clear() session.remove() session.invalidate() session.stop() 最后有一个编程题，大概的意思是一个对象，有三个属性（id，name，children），然后它是一个树状结构，给一个id给你，要你返回目标对象，题目给出了方法签名，需要补充方法体 123public Map test(List&lt;Map&gt; list, String id) { // TODO 需要面试者填充方法体} 这题我使用广度优先遍历来做的，面试官疑惑怎么还用上队列了，我解释了一番之后，他还是表示没这么复杂 事后我才想总不会是直接循环这个List，然后比较id，而不需要去遍历children来做的吧 技术面面试官问 问了一下我的开源项目以及工作项目，没啥干货 反问我脑海中的低代码平台还是停留在非开发者也能快速上手，但后期维护难的印象。如果客户有需要导入旧数据到低代码平台的需要，要怎么做 面试官的大概意思他们的低代码平台用户还是需要一点代码水平的，针对我说的数据迁移，他说这个业务不在考虑范围内 hr 面主要谈了谈薪水和工作时间，薪水压了我1k，现场给了意向 offer 总结自我感觉这家公司的业务可能并没有涉及分布式微服务之类的，给offer倒是挺快的，算是我来深圳的第一个offer","link":"/mianjing/2024/03/zhuoxun/index.html"}],"tags":[{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"双端队列","slug":"双端队列","link":"/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"入门教程","slug":"入门教程","link":"/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"JetBrains 全家桶","slug":"JetBrains-全家桶","link":"/tags/JetBrains-%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","link":"/tags/IntelliJ-IDEA/"},{"name":"WebStorm","slug":"WebStorm","link":"/tags/WebStorm/"},{"name":"GoLand","slug":"GoLand","link":"/tags/GoLand/"},{"name":"DataGrip","slug":"DataGrip","link":"/tags/DataGrip/"},{"name":"VisualVM","slug":"VisualVM","link":"/tags/VisualVM/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"深度优先遍历","slug":"深度优先遍历","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"哈希计数","slug":"哈希计数","link":"/tags/%E5%93%88%E5%B8%8C%E8%AE%A1%E6%95%B0/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"大根堆","slug":"大根堆","link":"/tags/%E5%A4%A7%E6%A0%B9%E5%A0%86/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"分治法","slug":"分治法","link":"/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序哈希","slug":"有序哈希","link":"/tags/%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"name":"优先级队列","slug":"优先级队列","link":"/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"中序遍历","slug":"中序遍历","link":"/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"一次遍历","slug":"一次遍历","link":"/tags/%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"差分数组","slug":"差分数组","link":"/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"name":"直接计算","slug":"直接计算","link":"/tags/%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"广度优先遍历","slug":"广度优先遍历","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"},{"name":"前缀树","slug":"前缀树","link":"/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"辗转相除法","slug":"辗转相除法","link":"/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"},{"name":"双重循环","slug":"双重循环","link":"/tags/%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"反转链表","slug":"反转链表","link":"/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"层序遍历","slug":"层序遍历","link":"/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","link":"/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"前序遍历","slug":"前序遍历","link":"/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"模运算","slug":"模运算","link":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/"},{"name":"堆栈","slug":"堆栈","link":"/tags/%E5%A0%86%E6%A0%88/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"循环","slug":"循环","link":"/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"双层循环","slug":"双层循环","link":"/tags/%E5%8F%8C%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"name":"LeetCode 里程碑","slug":"LeetCode-里程碑","link":"/tags/LeetCode-%E9%87%8C%E7%A8%8B%E7%A2%91/"},{"name":"四舍五入","slug":"四舍五入","link":"/tags/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","link":"/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"Java开发工程师","slug":"Java开发工程师","link":"/tags/Java%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"},{"name":"浩网科技","slug":"浩网科技","link":"/tags/%E6%B5%A9%E7%BD%91%E7%A7%91%E6%8A%80/"},{"name":"网联科技","slug":"网联科技","link":"/tags/%E7%BD%91%E8%81%94%E7%A7%91%E6%8A%80/"},{"name":"一叶智能","slug":"一叶智能","link":"/tags/%E4%B8%80%E5%8F%B6%E6%99%BA%E8%83%BD/"},{"name":"技术面","slug":"技术面","link":"/tags/%E6%8A%80%E6%9C%AF%E9%9D%A2/"},{"name":"一面","slug":"一面","link":"/tags/%E4%B8%80%E9%9D%A2/"},{"name":"江西燃点","slug":"江西燃点","link":"/tags/%E6%B1%9F%E8%A5%BF%E7%87%83%E7%82%B9/"},{"name":"深圳同行者","slug":"深圳同行者","link":"/tags/%E6%B7%B1%E5%9C%B3%E5%90%8C%E8%A1%8C%E8%80%85/"},{"name":"行云绽放","slug":"行云绽放","link":"/tags/%E8%A1%8C%E4%BA%91%E7%BB%BD%E6%94%BE/"},{"name":"一临云科技","slug":"一临云科技","link":"/tags/%E4%B8%80%E4%B8%B4%E4%BA%91%E7%A7%91%E6%8A%80/"},{"name":"易世通达(跨境电商)","slug":"易世通达-跨境电商","link":"/tags/%E6%98%93%E4%B8%96%E9%80%9A%E8%BE%BE-%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86/"},{"name":"卓讯信息技术","slug":"卓讯信息技术","link":"/tags/%E5%8D%93%E8%AE%AF%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"}],"categories":[{"name":"LeetCode每日一题","slug":"LeetCode每日一题","link":"/categories/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"mongodb","slug":"mongodb","link":"/categories/mongodb/"},{"name":"MyBatis","slug":"MyBatis","link":"/categories/MyBatis/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/categories/GitHub-Actions/"},{"name":"破解","slug":"破解","link":"/categories/%E7%A0%B4%E8%A7%A3/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"}],"pages":[{"title":"wuhunyuの个人简历","text":"联系方式 手机：15687225042 (归属地为云南大理) Email：wuhunyu@gmail.com 微信号：wuhunyu3312 个人信息 龚志强 / 男 / 26岁 / 1997年12月出生 全日制统招本科 / 大理大学(2016.9 ~ 2020.7) / 计算机科学与技术 实际工作年限：4 年 期望职位：Java 工程师 力扣：https://leetcode.cn/u/wuhunyu 个人博客：https://wuhunyu.top 技能清单 熟练使用 MySQL，了解 sql 优化，开发过程中善于分析并优化 sql 熟练使用 Redis，了解 Redis 各个数据结构和持久化策略，并能根据不同的应用场景选择合适的数据结构 熟练使用 RocketMQ，善于使用 MQ 用于服务异步通信，延时队列等 熟练使用 Linux，Nginx，Docker 常用命令，能够编写简单的脚本并部署项目 熟练使用 Netty 框架，能够独立开发 RPC 框架 能够整合 SpringCloud Alibaba 微服务全家桶，能够独立开发微服务项目 阅读过 Java 常用集合的源码，在开发中会注意根据源码优化代码 了解 JUC 并发工具的使用，阅读过 CAS，AQS 源码 了解 JVM 运行原理，能够简单分析 dump 文件 工作经历江西绿萌科技控股有限公司（2022.10 ~ 2023.10） 绿萌云（2022.10 ~ 2023.10）Java 中级开发项目简介绿萌云是一个水果分选加工管理平台，涵盖了水果种植数据监控，采购入库，分选加工，仓储管理，销售出库，水果溯源等一整套水果管理流程 担任职责我在项目中主要负责水果种植期的数据监控模块和采购入库模块的开发工作 主要成果 水果的数据采集设备上报数据的频率大约为每 5 秒一次，我采用数据冷热分离的方式，保留最近一个月的实时数据以及最近三年的统计结果，过期的实时数据保存在冷库中，保证了监控数据的实时查询效率 监控数据异常或者采购入库成功时，需要在云平台实时通知管理者。由于平台是微服务架构集群的部署方式，我是通过 RocketMQ 广播的方式来解决WebSocket 分布式 Session 的问题 技术架构SpringCloudAlibaba MyBatis-Plus Redis Gateway Nacos Dubbo Quartz RocketMQ WebSocket 江西憶源多媒体科技有限公司（2021.2 ~ 2022.8） 校园资产管理平台（2022.2 ~ 2022.8）Java 初级开发项目简介对校园内的贵重资产进行管理记录，包含资产数字化管理，资产报表以及资产数据分析等模块 担任职责我负责该管理平台后端开发的领导人角色，主要负责的模块有资产数字化管理，资产报表 主要成果开发了一些方便的工具帮助快速开发，如：代码生成，Excel 导出工具，Cron 表达式转换工具，Java Bean 转 Map 工具等，得到了项目组其他同事的认可 技术架构SpringCloud MyBatis-Plus Redis Gateway Eureka OpenFeign Quartz 智慧警务管理平台（2021.8 ~ 2022.1）Java 初级开发项目简介统一管理派出所内部有所有装备柜设备，包括装备状态监控，装备数据报表，警员管理等模块 担任职责我主要负责装备状态监控模块的开发 主要成果每个装备的状态信息不会主动上报，需要系统主动去获取。我采用定时更新+增量更新的方式来获取每个装备的状态信息，每 5 分钟轮询一次，以及在用主动查询主动更新。保证了装备状态数据的最终一致性 技术架构SpringCloud MyBatis-Plus Redis Gateway Eureka OpenFeign 随手拍（2021.2 ~ 2021.7）Java 初级开发项目简介居民不文明或隐患行为拍照上传的微信小程序 担任职责我主要负责微信小程序后台的授权登录以及举报奖励模块的开发 主要成果举报奖励模块对接了微信的公众服务 企业付款到零钱，加入了幂等，重试等机制保证可靠性，支付失败会有告警提示。小程序交付运行一年以来，除了部分未实名认证无法收款的微信用户外，未出现异常 技术架构SpringBoot MyBatis-Plus Redis 宇信鸿泰科技有限公司（2020.3 ~ 2020.12） 中国进出口网上银行（2020.7 ~ 2020.12）Java 初级开发项目简介 &amp; 担任职责我在此项目中负责了电子对账业务，用户电子账号管理，账单提交以及账单复核等模块的开发 主要成果最后在同事的帮助下成功通过线上测试并发布到线上 技术框架SSM 手机银行（2020.3 ~ 2020.6）Java 实习项目简介 &amp; 担任职责在此项目中我使用 MUI 框架开发网上银行移动端页面，包含用户登录与注册和网上银行转账业务两个模块 主要成果通过这两个模块的开发，快速学习了移动端 H5 的开发过程，为今后接手简单的前端开发任务打下了基础 技术框架MUI VUE 个人开源项目rpc 框架 简介项目分为服务端和客户端两个模块，服务端在项目启动时将自己注册到 Nacos 服务中，客户端读取配置在 Nacos 中的配置后读取 Nacos 注册中心中服务端各个实例的访问地址和端口等配置信息，从而远程调用服务端的实例 解决问题了解 Dubbo，gRPC 底层通信原理，拥有独立开发 rpc 框架的能力 技术栈Nacos Netty 分布式序列ID 源码地址本体项目地址：https://github.com/wuhunyu/rpc.git demo项目地址：https://github.com/wuhunyu/rpc-demo.git 代码生成 简介这是一个在线代码生成器，核心使用 druid 框架和 freemarker 模板引擎。其中使用 druid 解析 MySQL 的 DDL 语句，使用 freemarker 生成模板，也就是在线解析 DDL 语句，并根据解析结果生成 Java 模板代码的一款 web 应用 解决问题通过 DDL 语句快速生成可用的 Java 后端模板代码 技术栈SpringBoot druid FreeMarker 源码地址https://github.com/wuhunyu/code-gen-by-ddl.git 演示地址https://wuhunyu.top/code-gen 证书软考中级软件设计师 云南省蓝桥杯C/C++程序设计大赛大学B组三等奖 英语(CET-4) 计算机等级考试四级-数据库工程师 个人总结擅长 Java 开发，对算法有浓厚兴趣，能够独立解决力扣简单，中等难度的算法题 乐于学习新技术，并应用到实际的开发中来 闲暇之余，有阅读源码的习惯 喜欢和同事讨论各种技术问题 致谢感谢您花时间阅读我的简历，期待能有机会和您共事","link":"/resume.html"}]}