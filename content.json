{"posts":[{"title":"MongoDB 入门","text":"MongoDB 入门数据库shell12345678910111213# 查询所有数据库show databases; | show dsb;# 创建/切换到指定的数据库。如果数据库不存在任何集合，使用 `show dbs` 将不会展示该数据库 use [database]; # 创建(如果不存在)/切换到 test 数据库 use test;# 查询当前所在的数据库db# 删除当前数据库db.dropDatabase(); 集合shell1234567891011121314# 查询数据库中的所有集合show collections; | show tables;# 显式创建集合db.createCollection(&quot;[集合名称]&quot;); # 创建一个集合名称为 user 的集合 db.createCollection(&quot;user&quot;); # 通过新增一条文档记录，隐式创建一个集合。比如：往 user 集合中插入一条 name 为 wuhunyu 的文档，将会隐式地创建 user 集合 db.user.insert({name: &quot;wuhunyu&quot;});# 删除一个集合db.[集合].drop(); # 删除一个名称为 user 的集合 db.user.drop(); 文档插入shell12345678910111213141516# 单行插入db.[集合名称].insert([文档]) # 往 user 集合中插入一条 name 为 wuhunyu 的文档 db.user.insert({name: &quot;wuhunyu&quot;});# 批量插入db.[集合名称].insertMany([文档1, 文档2...]); # 批量插入 db.user.insertMany([{_id: 1, name: &quot;1号&quot;}, {name: &quot;2号&quot;, age: 25}, {name: &quot;3号&quot;, bir: &quot;2023-12-16&quot;}]); # 使用 insert 也可以批量插入 db.user.insert([{_id: 1, name: &quot;1号&quot;}, {name: &quot;2号&quot;, age: 25}, {name: &quot;3号&quot;, bir: &quot;2023-12-16&quot;}]); # js 脚本插入for (let i = 0; i &lt; 10; i++) { db.user.insert({_id: i, name: i + &quot;号&quot;, age: i + 20});} 删除shell123456789101112131415# 删除集合全部的文档记录db.[集合].remove({}); # 删除 user 集合中的全部数据 db.user.remove({}); # 删除 user 集合中的 _id 为 1 的文档记录 db.user.remove({_id: 1}); # 如果是 mongo 自动生成的 id，需要使用 ObjectId(&quot;[id]&quot;) 的方式指定 _id db.user.remove({_id: ObjectId(&quot;657d08e9cb5c0571e33ee6b4&quot;)}); # 删除 user 集合中的 name 为 &quot;1号&quot; 的文档记录 db.user.remove({name: &quot;1号&quot;}); # 删除一条记录db.[集合].remove({}, {justOne: true}); # 删除 user 集合中 age 字段为 20 的第一条记录 db.user.remove({age: 20}, {justOne: true}); 修改shell12345678910111213141516171819# 修改# 查询条件 可以类比成 where 条件# 修改值 可以类比成 set# multi 表示是否批量更新，默认为 false，即为只更新找到的第一条记录# upsert 表示查询条件查询不存在记录时，是否新增，默认为 falsedb.[集合].update( {[查询条件]}, {[修改值]}, { multi: &lt;boolean&gt;, upsert: &lt;boolean&gt;, }); # 修改 user 集合中第一条 age 为 20 的文档记录。这种修改方式类似于删除之后再新增，修改之后的字段只会保留 _id 和 age 字段 db.user.update({age: 20}, {age: 25}); # 修改 user 集合中第一条 age 为 20 的文档记录。这种修改方式类似于部分修改，只修改指定的字段 db.user.update({age: 20}, {$set: {age: 25}}); # 修改 user 集合中的所有 age 为 20 的文档记录 db.user.update({age: 20}, {$set: {age: 25}}, {multi: true}); 查询shell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 查询全部db.[集合].find(); # 查询 user 集合中的全部文档记录 db.user.find(); # 格式化显示，对于较长的文档记录，可以使用 .pretty() 来格式化展示 db.user.find().pretty(); # 操作符$gt &gt;$lt &lt;$gte &gt;=$lte &lt;=$ne !=# 条件查询db.[集合].find({[查询条件]}); # and 条件查询 # 查询 user 集合中，age 等于 25 的记录 db.user.find({age: 25}); # 查询 user 集合中，age 大于等于 25 的记录 db.user.find({age: {$gte: 25}}); # 查询 user 集合中，age 大于等于 25 且 小于等于 30 的记录 db.user.find({age: {$gte: 25, $lte: 30}}); # 错误写法：后一个 age 条件会覆盖掉前一个查询条件，等价于 `db.user.find({age: 30})` db.user.find({age: 25, age: 30}); # or 条件查询 # 查询 user 集合中，age 大于等于 25 或者 name 为 &quot;1号&quot; 的记录 db.user.find({$or: [{age: {$gte: 25}}, {name: &quot;1号&quot;}]}); # and 和 or 的联合查询 # 查询 user 集合中，age大于等于 25 或者 name 为 &quot;1号&quot; 且 age 等于 20 的记录 db.user.find({$or: [{age: {$gte: 25}}, {name: &quot;1号&quot;, age: 20}]});# 数组结构。在 mongo 中，数组结构的查询和和普通的查询也是一样的# 比如，user 集合中一条文档记录有一个字段是 likes# { &quot;_id&quot; : ObjectId(&quot;657d1dfacb5c0571e33ee6c3&quot;), &quot;name&quot; : &quot;test&quot;, &quot;likes&quot; : [ &quot;看电视&quot;, &quot;看书&quot;, &quot;打篮球&quot; ] }# 如果要查询，likes 中包含了 &quot;看书&quot; 的记录db.user.find({likes: &quot;看书&quot;});# 模糊查询。mongo 中并没有像是 `%`, `_` 的标识符，需要通过正则表达式的方式来实现模糊查询# 查询 user 集合中，name 包含 &quot;号&quot; 的记录db.user.find({name: /号/}).pretty();# 排序db.[集合].find().sort({[排序条件]}); # 1: 升序; -1: 降序 # 查询 user 集合中全部的记录，按 age 倒序，name 顺序 排序 db.user.find().sort({age: -1, name: 1}); # 分页# skip 偏移量，从 0 开始# limit 最大条数db.[集合].find().skip([skip]).limit([limit]); # 查询 user 集合全部的记录，只保留前 5 条记录，如果 skip 为 0，可以省略 skip，等价于 `db.user.find()limit(5);` db.user.find().skip(0).limit(5); # 统计数据量db.[集合].count(); # 统计 user 集合的中数据量 db.user.count(); # 统计 user 集合中，age 小于等于 25 的记录数量 db.user.find({age: {$lte: 25}}).count();# 返回指定的字段db.[集合].find([查询条件], [映射字段]); # 查询 user 集合中的 name 字段。其中，1 表示显示，0 表示不显示 db.user.find({}, {name: 1}); $type$type 操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 shell123# 查询 user 集合中，name 为字符串类型的文档记录，等价于 `db.user.find({name: {$type: 2}});`db.user.find({name: {$type: &quot;string&quot;}});# 值得一提的是，mongo 中的整形的默认类型是 Double 索引shell12345678910111213141516171819# 查询集合下的所有索引db.[集合].getIndexes(); # 查询 user 集合下的所有索引 db.user.getIndexes(); # 创建一个缩影db.[索引].craeteIndex([索引字段], [索引配置]); # 创建一个名称为 idx_name_age 的索引，索引字段为 (name, age), 都为升序排列 db.user.createIndex({name: 1, age: 1}, {name: &quot;idx_name_age&quot;}); # 删除集合下的全部索引db.[集合].dropIndexes(); # 删除 user 集合下的所有索引(除了 id 索引) db.user.dropIndexes();# 删除指定索引db.[集合].dropIndex([索引名称]); # 删除 user 集合的 idx_name_age 索引 db.user.dropIndex(&quot;idx_name_age&quot;); 聚合管道 $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 聚合函数 表达式 描述 $sum 计算总和。 $avg 计算平均值 $min 获取集合中所有文档对应值得最小值。 $max 获取集合中所有文档对应值得最大值。 $push 将值加入一个数组中，不会判断是否有重复的值。 $addToSet 将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入。 $first 根据资源文档的排序获取第一个文档数据。 $last 根据资源文档的排序获取最后一个文档数据 测试数据shell1234567891011121314151617181920212223242526db.mycol.insert([ { title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100 }, { title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'runoob.com', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 10 }, { title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750 }]); 示例操作shell123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# 管道操作# $project 映射 title 和 by_user 字段db.mycol.aggregate([ { $project: { _id: 0, title: 1, by_user: 1 } }]);# $match 过滤 likes &gt;= 100, tags 包含 mongo 的记录db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $project: { _id: 0, title: 1, by_user: 1 } }]);# 分页db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $project: { _id: 0, title: 1, by_user: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $unwind 数组拆分db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $unwind: &quot;$tags&quot; }, { $project: { _id: 0, title: 1, by_user: 1, tags: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $sort 排序db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;mongodb&quot; } }, { $unwind: &quot;$tags&quot; }, { $project: { _id: 0, title: 1, by_user: 1, tags: 1 } }, { $sort: { title: 1, tags: 1 } }, { $skip: 0 }, { $limit: 10 }]);# $group 分组db.mycol.aggregate([ { $match: { likes: { $gte: 100 }, tags: &quot;database&quot; } }, { $group: { _id: { author: &quot;$by_user&quot;, url: &quot;$url&quot; }, minLikes: { $min: &quot;$likes&quot; }, maxLikes: { $max: &quot;$likes&quot; }, avgLikes: { $avg: &quot;$likes&quot; }, count: { $sum: 1 }, sum: { $sum: &quot;$likes&quot; } } }]).pretty();","link":"/mongodb/MongoDB%20%E5%85%A5%E9%97%A8/index.html"},{"title":"MyBatis 缓存","text":"MyBatis 缓存MyBatis 有两级缓存，其中一级缓存默认开启，二级缓存需要手动开启。不过 MyBatis 的缓存很容易失效，所以建议保持默认配置只开启一级缓存即可。本文将以案例的形式来介绍 MyBatis 的缓存 本文所使用的例子完整示例存放在 GitHub 中 MyBatis 的缓存分为 一级缓存 和 二级缓存一级缓存一级缓存 默认开启，同一个 SqlSession 对象共享一个缓存 失效场景 没有使用同一个 SqlSession 发生了任意修改类操作 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 localCacheScope 属性配置为 STATEMENT 二级缓存二级缓存需要手动开启，同一个 namespace 共享一个缓存，也可以使用配置的方法使得多个 namespace 共享一个缓存 失效场景 发生了任意修改类操作，会清空所有的二级缓存。当然，一级缓存也会被清空 如果使用 MyBatisPlus 默认提供的查询语句，没有在 Mapper 接口上配置 @CacheNamespaceRef 也会导致二级缓存不生效 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 mapper 映射文件没有配置 cache 标签 一级缓存示例项目工程 MyBatis 核心配置 xml12345678910&lt;settings&gt; &lt;!-- 二级缓存关闭 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt; &lt;!-- 一级缓存配置为 session 级别，简单理解就是开启一级缓存 --&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;!-- 开启下划线转驼峰 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 日志实现 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; logback 日志配置 xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration scan=&quot;false&quot;&gt; &lt;contextName&gt;mybatis&lt;/contextName&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%logger{50}] - %msg%n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;!-- mapper 层开启 debug 日志 --&gt; &lt;logger name=&quot;top.wuhunyu.mybatis.cache.mapper&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt; User 实体 Java1234567891011121314151617181920212223@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable { private static final long serialVersionUID = -2716722547404828511L; /** * 用户id */ private Long id; /** * 用户名称 */ private String userName; /** * 年龄 */ private Integer age;} UserMapper Java12345678910111213141516171819public interface UserMapper { /** * 根据用户id查询用户信息 * * @param id 用户id 非空 * @return 用户实体对象 */ User findUserById(@Param(&quot;id&quot;) Long id); /** * 根据用户id修改用户信息 * * @param user 用户实体对象 */ void updateUserById(@Param(&quot;user&quot;) User user); } UserMapper.xml 映射文件 xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;top.wuhunyu.mybatis.cache.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findUserById&quot; resultType=&quot;top.wuhunyu.mybatis.cache.domain.User&quot;&gt; select u.id, u.user_name, u.age from `user` u where u.id = #{id} &lt;/select&gt; &lt;update id=&quot;updateUserById&quot;&gt; update `user` set user_name = #{user.userName}, age = #{user.age} where id = #{user.id} &lt;/update&gt;&lt;/mapper&gt; 一级缓存生效演示同一个 SqlSession 同一个 Mapper 对象分别查询同一条 sql 时 Java123456789101112try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertSame(user1, user2);} 日志打印情况如下 图中只打印了一次 sql，表示第二次查询并没有真的发起 sql 查询，而是从一级缓存中直接获取。由于一级缓存可以理解为一个 Map，并不存在序列化操作，因此直接比较 user1 和 user2 的内存地址也是相同的 同一个 SqlSession 不同 Mapper 对象分别查询同一条 sql 时 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class); UserMapper userMapper2 = sqlSession.getMapper(UserMapper.class); User user1 = userMapper1.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper2.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertSame(user1, user2);} 日志打印情况如下 图中只打印了一次 sql，表示一级缓存生效 一级缓存失效演示没有使用同一个 SqlSession Java123456789101112131415try ( // 关闭自动提交事务 SqlSession sqlSession1 = sqlSessionFactory.openSession(false); SqlSession sqlSession2 = sqlSessionFactory.openSession(false);) { UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = userMapper1.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); sqlSession1.commit(); User user2 = userMapper2.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession2.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 图中分别打印了两次 sql，user1 和 user2 的内存地址也不一样了，表示一级缓存失效了 发生了任意修改类操作 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); userMapper.updateUserById(new User(2L, &quot;李四-2&quot;, 21)); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 同样打印了两次查询 sql，这是由于 updateUserById 发生了修改操作导致的缓存失效 SqlSession commit 或者手动调用了 SqlSession 的 clearCache() 方法 Java12345678910111213try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); sqlSession.clearCache(); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 由于手动触发了 clearCache，导致一级缓存失效了 localCacheScope 属性配置为 STATEMENT 修改 localCacheScope 的值为 STATEMENT 拿之前一级缓存生效的例子 Java123456789101112try ( // 关闭自动提交事务 SqlSession sqlSession = sqlSessionFactory.openSession(false);) { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user1 = userMapper.findUserById(1L); log.info(&quot;user1: {}&quot;, user1); User user2 = userMapper.findUserById(1L); log.info(&quot;user2: {}&quot;, user2); sqlSession.commit(); Assert.assertNotSame(user1, user2);} 日志打印情况如下 localCacheScope 为 STATEMENT 时，表示缓存作用于 STATEMENT，而一个 STATEMENT 就是一条 sql，也就表示一级缓存失效了 二级缓存示例项目工程 application.yml 配置 yaml1234567891011121314151617181920212223242526spring: application: name: mybatis-plus datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test username: root password: 123456server: port: 10000# mybatis-plus 配置mybatis-plus: configuration: # 开启下划线转驼峰 map-underscore-to-camel-case: true # 日志实现 log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl # 二级缓存开启 cache-enabled: true # 一级缓存配置为 session 级别，简单理解就是开启一级缓存 local-cache-scope: session # mapper.xml 位置 mapper-locations: classpath*:/top/wuhunyu.mybatis/plus/cache/mapper/**/*Mapper.xml 主启动类配置 mapper 扫描路径 切换成了 MybatisPlus 之后，先看看一级缓存是否还生效 一级缓存生效演示 同一个 SqlSession，使用 Mybatis 原生 sql 写法 Java1234User user1 = userMapper.findUserById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.findUserById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 可以看到，查询的 sql 语句只被执行了一次，日志还打印了缓存被击中的概率为 0.5，说明第二次查询确实从缓存中获取成功了 另外，日志有一条 WARN。这是由于二级缓存的结果会序列化保存的缘故 通过 debug 可以观察到两个 user 对象的 hash 值并不相同，表示不是同一个对象，但确实走了二级缓存，这是由于二级缓存反序列导致的 这条 WARN 日志就是针对序列化可能产生 bug 而打印的警告，详情可以通过日志给出的链接自行了解 此处以及之后的例子都不对这个 WARN 日志进行处理 同一个 SqlSession，使用 MybatisPlus api 的写法在 UserMapper 上加上 @CacheNamespaceRef(UserMapper.class) 注解 Java12345678910111213141516171819@CacheNamespaceRef(UserMapper.class)public interface UserMapper extends BaseMapper&lt;User&gt; { /** * 根据用户id查询用户信息 * * @param id 用户id 非空 * @return 用户实体对象 */ User findUserById(@Param(&quot;id&quot;) Long id); /** * 根据用户id修改用户信息 * * @param user 用户实体对象 */ void updateUserById(@Param(&quot;user&quot;) User user);} 测试用例如下 Java1234User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.selectById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 能够观察到走了二级缓存 不同 SqlSession，使用 MybatisPlus api 的写法 Java12345678910User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);ExecutorService executor = Executors.newSingleThreadExecutor();CountDownLatch countDownLatch = new CountDownLatch(1);executor.execute(() -&gt; { User user2 = userMapper.selectById(1L); log.info(&quot;user2: {}&quot;, user2); countDownLatch.countDown();});countDownLatch.await(); 日志打印情况如下 也是没有问题的 二级缓存失效演示 发生了任意修改类操作 Java12345678910111213User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);userMapper.updateUserById(new User(2L, &quot;张三&quot;, 21));ExecutorService executor = Executors.newSingleThreadExecutor();CountDownLatch countDownLatch = new CountDownLatch(1);AtomicReference&lt;User&gt; userAtomicReference = new AtomicReference&lt;&gt;();executor.execute(() -&gt; { User user2 = userMapper.selectById(1L); log.info(&quot;user2: {}&quot;, user2); userAtomicReference.set(user2); countDownLatch.countDown();});countDownLatch.await(); 日志打印情况如下 可以看到二级缓存的集中率都是 0.0，表示二级缓存没有被击中 如果使用 MyBatisPlus 默认提供的查询语句，没有在 Mapper 接口上配置 @CacheNamespaceRef Java1234User user1 = userMapper.selectById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.selectById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下 发生了两次 sql 查询，说明缓存失效 mapper 映射文件没有配置 cache 标签 Java1234User user1 = userMapper.findUserById(1L);log.info(&quot;user1: {}&quot;, user1);User user2 = userMapper.findUserById(1L);log.info(&quot;user2: {}&quot;, user2); 日志打印情况如下","link":"/mybatis/mybatis-cache/index.html"},{"title":"GitHub Actions 简单使用","text":"GitHub Actions 是什么官方文档 是这么介绍的 在 GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程。 您可以发现、创建和共享操作以执行您喜欢的任何作业（包括 CI/CD），并将操作合并到完全自定义的工作流程中。 我的理解可以理解为一个有条件（比如push事件，也可以是 cron 表达式定义的一个定时任务）触发的工作流任务。而这个工作流任务是可以由我们开发者自定义的，执行这些任务的环境由 GitHub 提供，一般是 ubuntu 环境。通过这个环境，我们可以执行一些自定义脚本，亦或是调用其他开发者发布的插件来实现一些开发者想要的功能 GitHub Actions 可以做什么传统 CI/CD 能做的编译，打包，发布，使用 GitHub Actions 肯定也是能实现的 这里，我想使用两个我自己的案例来演示说明，我使用 GitHub Actions 做了些什么 个人博客编译，打包，发布 作为拉取 docker-hub 官方镜像的中转工具 前置准备工作如何自定义工作流任务 只需要在仓库存在 .github/workflows/*.yml，在满足触发条件之后，就会被自动执行 这个配置文件可以有多个，执行的时候是并行的，但也可以定义工作流的依赖关系实现串行化 关于执行环境 可以自定义选择 Linux，Windows 和 macOS，具体的版本可以访问这里查看 Linux 环境已经自带了 Docker 环境，无需重复安装 关于插件 GitHub Actions 的插件分为官方和非官方的，其中官方的插件地址都是 https://github.com/actions 开头的 比如检出仓库代码的插件 checkout 比如第三方部署到 GitHub Pages 的插件 peaceiris/actions-gh-pages 可以在 GitHub 市场 中寻找符合自己需求的插件 个人博客编译，打包，发布.github/workflows/deploy.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172name: Deploy My Hexo Blogon: push: branches: - mainjobs: build: runs-on: ubuntu-latest # 权限控制 permissions: contents: read pages: write id-token: write steps: # 检出仓库代码 - name: Checkout Repository uses: actions/checkout@v4 # 设置 Node.js 版本 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: '20.9.0' # 缓存 npm 依赖 - name: Cache npm dependencies uses: actions/cache@v2 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-v2 restore-keys: | ${{ runner.os }}-node- # 安装 Hexo CLI - name: Install Hexo CLI run: npm install hexo-cli -g # 安装 npm 依赖 - name: Install npm dependencies run: | npm install --prefix themes/icarus npm install # 生成静态文件 - name: Generate static files run: | hexo clean hexo g # 部署到云服务器 - name: Deploy to Cloud Server uses: easingthemes/ssh-deploy@main with: SSH_PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }} ARGS: &quot;-avz --delete&quot; SOURCE: ${{ secrets.SOURCE }} REMOTE_HOST: ${{ secrets.HOST }} REMOTE_PORT: ${{ secrets.PORT }} REMOTE_USER: ${{ secrets.USER }} TARGET: ${{ secrets.TARGET }} # 部署到 wuhunyu.github.io - name: Deploy to Github Pages uses: peaceiris/actions-gh-pages@v4 with: personal_token: ${{ secrets.ACCESS_TOKEN }} external_repository: ${{ secrets.PAGE_REPO }} publish_branch: ${{ secrets.PAGE_BRAN }} publish_dir: ${{ secrets.SOURCE }} commit_message: ${{ github.event.head_commit.message }} 简单说明一下这个 actions 的内容 actions 的名称是 Deploy My Hexo Blog 当仓库的 main 分支有 push 事件发生时自动触发 工作流的执行环境是 ubuntu-latest 其次是关于权限控制的说明 最后按 steps 的声明顺序，任务会被依次执行，如果中途出现了错误，则会直接中断后续的任务。每个任务的作用在注释中已经写了，就不再多说明了。值得注意的是，其中有 ${{ }} 的符号，这是从当前上下文取值的占位符，其中 secrets 是由开发者自定义的环境变量，具体可以在每个仓库的 settings/secrets/actions 进行设置 action 运行的控制台像这样，按执行顺序列出了每个任务的日志 作为拉取 docker-hub 官方镜像的中转工具 前些天在掘金上看到了有人已经实现了，功能要比我这个更加健壮，地址如下 docker_image_pusher 下面展示的这个工具是我个人使用，每次拉取镜像也不会太大，像是磁盘不够的情况暂时还不需要考虑 .github/workflows/docker-hub.yml 123456789101112131415161718192021222324252627282930313233name: Pull and Push Docker Imageson: push: branches: - mainjobs: deploy: runs-on: ubuntu-latest steps: # 检出仓库代码 - name: Checkout Repository uses: actions/checkout@v4 # 安装 jq 以处理 JSON 文件 - name: Install jq run: sudo apt-get install -y jq # 登录到阿里云容器镜像服务 - name: Log in to Alibaba Cloud Registry run: echo &quot;${{ secrets.ALIYUN_REGISTRY_PASSWORD }}&quot; | docker login -u &quot;${{ secrets.ALIYUN_REGISTRY_USERNAME }}&quot; registry.cn-guangzhou.aliyuncs.com --password-stdin # 拉取和推送 Docker 镜像 - name: Pull and Push Docker images env: ALIYUN_NAMESPACE: ${{ secrets.ALIYUN_REGISTRY_NAMESPACE }} run: | for image in $(jq -r '.[]' images.json); do echo &quot;Processing image: ${image}&quot; docker pull ${image} aliyun_image=&quot;registry.cn-guangzhou.aliyuncs.com/${{ env.ALIYUN_NAMESPACE }}/${image##*/}&quot; docker tag ${image} $aliyun_image docker push ${aliyun_image} done 同样也是当仓库的 main 分支有 push 事件发生时自动触发 之后登陆阿里云的 docker hub 镜像 读取仓库中的 images.json 配置文件，形如 1234[ &quot;redis&quot;, &quot;nginx:latest&quot;] 在容器内 pull 镜像之后再 push 给阿里云的 docker hub 这里利用 actions 的容器可访问外网的能力将 docker 镜像中转到内网可访问的镜像站 其他除了以上两个案例，GitHub 有一个叫 Releases 的概念，也可以借由 GitHub Actions 来打包 .github/workflows/buildAndRelease.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344name: Build And Releaseon: push: tags: - 'v*.*.*'jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Code uses: actions/checkout@v4 - name: Set Up JDK 21 uses: actions/setup-java@v4 with: java-version: '21' distribution: 'adopt' - name: Build with Maven run: mvn clean package -DskipTests - name: Create Release id: create_release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false - name: Upload JAR to Release uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.create_release.outputs.upload_url }} asset_path: ${{ secrets.ASSET_PATH }} asset_name: ${{ secrets.ASSET_NAME }} asset_content_type: application/java-archive Releases 基于 tag，所以需要 actions 的触发条件可以设置为 tag 被 push 时 效果如下 总结 GitHub Actions 是 GitHub 免费开放给开发者的自动化工作流 基于 GitHub Actions，可以解放部分项目本地编译，部署的服务器资源。我借用这个功能实现了几个小功能，包括个人博客的编译部署，docker hub 镜像中转工具 最后如果借用 GitHub Actions 的容器资源来做爬虫节点是不是也挺好，官方给的服务器资源配置也还不错，可以查看这个 引用资源 GitHub Actions 文档 用于公共存储库的 GitHub 托管的标准运行器 checkout peaceiris/actions-gh-pages GitHub 市场 docker-hub docker_image_pusher starter","link":"/tools/github-actions-example/index.html"},{"title":"JetBrains 全家桶破解","text":"前排说明 破解原理基于 Gitee 上的一个开源插件 ja-netfilter，博主写这篇文章的目的并非倡导破解，该插件博主并未参与开发，仅仅作为一个使用者 截止到 2024年04月06日，博主目前使用的版本如下，实测有效可用，但并非是最新版本，至于其他版本是否支持，博主并未测试 ide 使用版本 IntelliJ IDEA 2023.3.6 WebStorm 2023.2.6 GoLand 2023.2.6 DataGrip 2023.2.3 破解需要 ja-netfilter 插件，以及当前还可用的激活码(需要激活第一次，以后便不需要了) 插件作者的使用教程可以参考这篇文章，本篇文章是基于插件作者的文章以及实际安装过程写给博主自己用的 文中仅仅介绍如何破解 JetBrains 家族的软件 演示环境基于博主的 MacOS 操作步骤 下载破解插件 ja-netfilter，文件的名称是 ja-netfilter-2022.2.0.zip 解压后的文件结构如下，ja-netfilter.jar所在的磁盘路径需要记下来（比如在我的电脑上是 /Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar） 123456789101112131415.├── README.pdf├── config│ ├── dns.conf│ ├── native.conf│ ├── power.conf│ └── url.conf├── ja-netfilter.jar├── plugins│ ├── dns.jar│ ├── hideme.jar│ ├── native.jar│ ├── power.jar│ └── url.jar└── sha1sum.txt 修改 config/dns.conf 配置文件，替换成以下内容即可 12[DNS]EQUAL,jetbrains.com 修改 config/url.conf 配置文件，替换成以下内容即可 12[URL]PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action 修改 JetBrains 各个 ide 的配置文件，配置文件的后缀都是 .vmoptions ide 对应的 vmoptions 配置文件名称 可能存在的路径 IntelliJ IDEA idea.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/IntelliJIdea[具体版本号]/idea.vmoptions WebStorm webstorm.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/WebStorm[具体版本号]/webstorm.vmoptions GoLand goland.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/GoLand[具体版本号]/goland.vmoptions DataGrip datagrip.vmoptions /Users/[用户名]/Library/Application Support/JetBrains/DataGrip[具体版本号]/datagrip.vmoptions 其他方式：又或者此刻你还能打开 ide 正常使用，通过在 ide 中找到 Help -&gt; Edit Custom VM Options 也能在 ide 中打开此配置文件 在 .vmoptions 中加入以下配置 1234# 激活-javaagent:[ja-netfilter.jar 所在的绝对路径]--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 以我的电脑上ja-netfilter.jar 所在的绝对路径是 /Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar 为例，最后需要添加的配置如下 1234# 激活-javaagent:/Users/wuhunyu/plugins/ja-netfilter/ja-netfilter.jar--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 启动 ide，输入 Activation code 激活，后续即便现在所使用的激活码失效，也不需要再次激活 关于激活码，ja-netfilter 插件作者的文章中提到了热心大佬的key。博主自己试过好几个倒是都无效 博主目前的解决方案是在taobao购买了一个激活码用于第一次激活","link":"/tools/jetbrains-active/index.html"},{"title":"搭建自己的 docker-hub 仓库","text":"前言之前写了一篇通过 GitHub Actions 的容器作为中转拉取 docker-hub 博客，不过使用的还是阿里云的镜像仓库 GitHub 上有推荐自建仓库的开源项目，比如 registry-mirror 网上虽然有不少活雷锋把自己的仓库开源出来，不过不少是限速的，拉取小镜像还好，一旦需要拉取像是 elasticsearch 这样大的镜像，又可能会因为拉取速度太慢导致多次重试，最后失败 这次，我也来试试自建仓库。自建的 docker 仓库，都是基于官方的一个镜像 registry 下面简单说说自建仓库的过程 资源准备 域名和证书 这个倒不是必须的，但 Docker 默认不允许非 HTTPS 方式推送镜像的 镜像 httpd 这里选择的是 httpd:alpine，这个镜像主要用来生成 http 认证文件 镜像 registry 这里选择的是 registry:latest，搭建自己 docker 仓库就靠它了 编写配置http 认证文件12345# 把命令中的 username 和 password 换成自己的用户名称和密码即可，后续 docker login 时需要通过这个凭证来登陆自己搭建好的 docker 仓库&gt; docker run --rm \\ --entrypoint htpasswd \\ httpd:alpine \\ -Bbn username password &gt; auth/nginx.htpasswd config.yml这个配置文件是 registry 的配置文件，默认位置在 /etc/docker/registry/config.yml 另外，值得注意的是，保存在仓库中的镜像默认存放在 /var/lib/registry 目录下 此外，http.tls 还配置了公私钥，比如我的域名是 docker.wuhunyu.top 以下是示例配置 1234567891011121314151617181920212223242526272829303132333435version: 0.1log: accesslog: disabled: true level: warn formatter: text fields: service: registry environment: stagingstorage: delete: enabled: true cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registryauth: htpasswd: realm: basic-realm path: /etc/docker/registry/auth/nginx.htpasswdhttp: addr: :443 host: https://docker.wuhunyu.top headers: X-Content-Type-Options: [nosniff] http2: disabled: false tls: certificate: /etc/docker/registry/ssl/docker.wuhunyu.top.pem key: /etc/docker/registry/ssl/docker.wuhunyu.top.keyhealth: storagedriver: enabled: true interval: 10sthreshold: 3 docker-compose 配置脚本123456789101112131415161718version: '3'services: registry: container_name: docker-registry image: registry:latest restart: always ports: - &quot;443:443&quot; volumes: - /home/wuhunyu/registry/config.yml:/etc/docker/registry/config.yml:ro - /home/wuhunyu/registry/repository:/var/lib/registry - /home/wuhunyu/registry/auth/nginx.htpasswd:/etc/docker/registry/auth/nginx.htpasswd:ro - /home/wuhunyu/cert/docker.wuhunyu.top.pem:/etc/docker/registry/ssl/docker.wuhunyu.top.pem:ro - /home/wuhunyu/cert/docker.wuhunyu.top.key:/etc/docker/registry/ssl/docker.wuhunyu.top.key:rovolumes: docker-registry: 分别指定了 registry 的配置文件，暴露仓库镜像数据卷，指定 http 认证文件以及公私钥文件 配置完毕之后，我的目录结构如下 123456registry├── auth│ └── nginx.htpasswd├── config.yml├── docker-registry.yml└── repository 启动通过 docker-compose -f docker-registry.yml up -d 完成自建仓库的部署 1234[+] Building 0.0s (0/0) docker:default[+] Running 2/2 ✔ Network registry_default Created 0.1s ✔ Container docker-registry Started 0.0s 通过 docker ps | grep docker-registry 可以观察到容器是否正常运行 13e3d14457946 registry:latest &quot;/entrypoint.sh /etc…&quot; 2 minutes ago Up 2 minutes 5000/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp docker-registry 登录仓库1&gt; docker login docker.wuhunyu.top 对需要上传的镜像打标签12# 这里以 openjdk:21-jdk-slim 为例&gt; docker tag openjdk:21-jdk-slim docker.wuhunyu.top/openjdk:21-jdk-slim 推送镜像到自建仓库12# 这里以 openjdk:21-jdk-slim 为例&gt; docker push docker.wuhunyu.top/openjdk:21-jdk-slim 退出登录1&gt; docker logout docker.wuhunyu.top 最后自建的仓库服务我放在自己的云服务器上，最所周知，带宽资源才是最昂贵的，阿里云对流入的流量我在上传镜像的时候感觉还行，上传近 1G 的镜像，能在一分钟内跑完，到了拉取镜像就开始不好了，1G 的镜像拉取了 5 分钟都还没结束，这个和我的带宽有关，我的带宽只有 3 Mbps 最后总结为自建的 docker 仓库还不好用，主要是我不想为网络资源额外付费 引用资源 registry-mirror 私有仓库 私有仓库高级配置","link":"/tools/make-self-docker-hub/index.html"},{"title":"庐山旅游规划（待完善）","text":"简介庐山，又称匡山、匡庐，位于中国江西省九江市南郊，是联合国教科文组织评定的文化遗产和世界地质公园，同时还是中国国家5A级旅游景区和文明旅游风景区、世界名山大会的发起者。庐山形成于第四纪冰川时期，是一座地垒式断块山脉，是中国自古以来重要的游览目的地 数据来源于维基百科 入口 从庐山智慧旅游微信公众号给的数据来看，庐山一共有三个入口，分别是 庐山北门 庐山索道 庐山南门 路线 九江站 -&gt; 庐山北门 路线 运营时间 交通类型 时长 费用 86路公交直达 07:55 - 16:25 公交 50 min ¥ 1 打车 - 打车 30 min - 九江站 -&gt; 庐山索道 路线 运营时间 交通类型 时长 费用 57路公交直达 06:40 - 17:30 公交 60 min（百度地图提示路线有临时取消，无法直达终点站，实际时长 1 h 50 min） ¥ 3 打车 - 打车 40 min - 庐山站 -&gt; 庐山索道 路线 交通类型 时长 费用 高铁客运专线（首末班车：7:00-16:20，班次约80分钟一班，车程约30分钟） 公交 30 min - 打车 打车 30 min - 庐山站 -&gt; 庐山南门 路线 公交 30 min 费用 打车 打车 40 min - 庐山 -&gt; 庐山南门没有直达的公交，需要换乘，部分方案需要多次换乘 搜索了百度地图和高德地图推荐的路线也有偏差 九江庐山机场 -&gt; 庐山索道 / 庐山南门 路线 公交 30 min 费用 九江庐山机场 -&gt; 庐山索道 打车 30 min - 九江庐山机场 -&gt; 庐山南门 打车 19 min - 庐山 -&gt; 庐山索道 / 庐山南门没有直达的公交，需要换乘 小结公交路线比较稳妥的方案是 九江站 -&gt; 庐山北门，其他路线都建议打车，或者到站后有明确的路线指引可以考虑选择 以上数据来源于 庐山智慧旅游微信公众号，百度地图，高德地图 数据具有时效性，平台给出的数据可能由于过期或者虚假等问题，实际出行请预留时间以应对突发问题 观景路线官方推荐一日游早上到达山顶的牯岭镇，游玩西线： 建议路线：如琴湖、花径 -&gt; 锦绣谷 -&gt; 仙人洞 下午游玩东线： 建议路线：含鄱口 -&gt; 芦林湖 -&gt; 会议旧址 -&gt; 美庐 一日游地图标记如下","link":"/travel/guide/lushan-mountain/index.html"},{"title":"2024年年中消费简述","text":"简述简单总结一个自从三月来深圳的大体消费支出情况 基本情况 2024 年 3 月到 4 月中旬前，处于求职状态，这个时候暂无收入 2024 年 4 月下旬至今，由于有了工作，每月的开销都相对固定 消费类别个人的支出情况主要分为几大类 住宿 饮食 交通 零食 生活用品 其它购物 在求职阶段，主要消费类别集中在前三项 消费细项求职阶段住宿住宿是消费的大头，求职阶段我的住宿是先住酒店落脚，后面找民宿 / 公寓缓解住宿费用高的压力 如果是初来深圳没有工作，且没有熟人帮衬的情况，先住酒店，后面换民宿 / 公寓我认为是很好解决住宿问题的方案 如果确实没资金，还可以考虑青旅。青旅即便在南山区 / 福田区的繁华地段，也能找到 30 / 日的青旅。但我不推荐的青旅，因为青旅多是多人一间，这很考验人的睡眠质量。曾经我住过一次两天的青旅，较为常住的下铺室友貌似是跑外卖的，但他这个外卖员不是天天做的（我有天出去面试，正常人工作时间回来发现他还在床上）。无论你是想要正常休息，还是准备面试，青旅的环境都绝不是一个好地方 我记得我第一次来深圳，选在了深圳市宝安区的翻身地铁站附近（后来了解到这个站算是宝安区比较繁华的一个地方），因为有酒店信任优惠，大概 160 / 日，连续住宿了两三天 一方面，因为出来深圳，不清楚面试地点主要集中在那一个区域，所以这个时候我的住宿地点一方面受近期面试的公司地点影响；另一方面，也受到酒店 / 民宿 / 公寓的日租价格影响 我比较常用的住宿订购软件是美团，简单说说遇到的两个糟心事 前一天定好的民宿，到了之后被告知没空房了。所以一定要先在美团上提前和房东打招呼，询问好是否在入住的那天有空房 共享电动车有地区范围限制。扫码开锁之后没走一百米就提示超出了服务区域，被强制停电了。这个属于是我没注意看软件说明导致的 选择比较偏远的地方酒店 / 民宿，可以把短租的住宿费用降低到 100 / 日左右 这个价位的酒店环境可能就比较一般了，你住宿的酒店可能会有以下问题 酒店位置偏远。可能距离地铁比较远 酒店卫生一般 入住时房间的烟味甚至也没有散去 sex 方面的小广告，小玩具等 民宿的话 费用较低，比如 90 / 日，房东可能不会提供空调服务。如果有电风扇，看当天的天气是否能接受 蟑螂多。这个生物在广州，深圳都是很常见的，如果非常害怕这个的话，要么多花钱去卫生条件好的地段，要么就不要来广州深圳（认真脸） 饮食饮食消费主要看住宿的地方 早餐 早操因为深圳的地摊很多，如果你能接受炒面炒粉做早餐，我想早餐完全可以控制在 5 / 日以内，即便是在福田区，南山区这些地方 午餐，由于午餐有时候会处于两段面试中间，所以午餐需要在相对繁华的地段解决，这个时候我偏向于面食类午餐 午餐我一般吃面，一方面面食相对较为便宜，消费一般都能在 20 / 顿以内 或者能找到快餐店，消费也不会高出太多。大概在 (10 , 30) 这个范围浮动吧 晚餐，一般回到住处附近吃 一天三顿最好有一顿是大米饭的。如果硬是要给一个范围的话，30 / 顿我是可以保证的。如果去一些快餐店（比如什么木桶饭），一般能够保持在 20 / 顿以内 其他 一天如果上下午都有面试，我是不回住宿的地方。中午解决完毕午餐之后，还需要找个地方能让我等到面试时间。这个地点一般是各种奶茶店 我以前比较少喝什么喜茶，瑞幸。来了深圳之后这些奶茶和家里的三线小城市相比物价方面也还差不多吧（当然，不要选购贵的） 交通在深圳交通费用基本是地铁。我的消费主要是地铁 + 共享单车，以及几次来回深圳的高铁费用 关于交通，我可以很认真地说，住宿的地点一定要选择离地铁近的。这样无论的工作地点在哪里，至少你能到达（中间可能需要多次转路线） 关于地铁，如果是 iPhone 手机用户，建议开启深圳通（打95折），而且开卡不需要手续费；如果是安卓用户，开卡需要手续费，不打算长期或者暂时无法遇见是否能长期呆在深圳的话，建议使用微信小程序付费（没有优惠） 深圳地铁的费用我个人觉得不低，但确实很方便出行 然后就是，深圳地铁 11 号线真的多人，每天都要挤这条线的人感觉绝望又无奈 零食– 生活用品生活用品我大部分都是随行李箱自带，除了洗衣粉 其他购物这个阶段除了必须的物品，一律一毛不拔 有部分费用，比如简历的打印费用，在深圳无论是繁华地段还是偏远地段，都是 1 / 张，在广州的一家打印店我倒是遇到一次几毛钱一张的。简历的打印我一般推荐一次不要打印过多份，一方面可能有修改的需求；另一方面A4纸在身上很容易被弄出折痕 工作阶段住宿在深圳宝安区 11 号线附近找了一处 1000 / 月的一室一卫，每月加上水电网费，大概在 1200 / 月 关于住宿，如果可以离公司很近，那无所谓，如果离公司很远，那必须选择离地铁站 1 公里以内的 饮食早餐 一般 3 / 顿，两个包子。周末 5 / 顿，肠粉 中餐 工作提供了 500 / 月的餐补，勉强够工作日中餐的消费。大概 25 / 顿，不够的是否需要自己补上一部分 晚餐 如果当晚跑步，一般吃面食。住宿附近的面食比较便宜，可以控制在 13 / 顿以内 如果没有跑步，可能会选择米饭，各种快餐店（比如木桶饭），大概能控制在 15 / 顿左右 其他 周末可能和朋友一起在外面搓一顿，消费一般在 300 / 次以内 交通地铁 每个工作日的早晨都是在挤深圳 11 号线的路上，固定消费 7 / 次，一天一个来回，一共 14 / 天，会有一点点打折（95折） 如果不幸中途出站上厕所，可能会把当天的地铁消费提高 1 - 2 元 共享单车 有时候周末去图书馆骑共享单车，一个月下来共享单车的消费应该不到 20 / 月 零食 每个星期大概都会有 50 左右的消费在零食上面 生活用品 T恤，我比较喜欢纯白纯棉的，然后在深圳的几个月里，因为多雨的天气坏了三件 裤子，鞋子，洗衣粉，电风扇，电热锅，洗洁精等等 其他购物 我的衣服都是晚上购物的 近期购买了一个 小米平板（3200）送妹妹生日 建议 初来深圳先住酒店落脚，后面换成靠近地铁的民宿 / 公寓 只要没有住在繁华的地段，饮食的消费一般不会太过分，一般能在住宿附近解决就在住宿附近解决 地铁是绝大多数深圳打工人的出行方式，可以在线办理深圳通，有一点点优惠 碎碎念深圳虽然确实也没啥可玩的，但来了深圳。可以在面试或者工作之余去爬爬山，逛逛商场。生活不只有工作，一旦工作起来，下一次连续的工作日长假就要等离职了","link":"/chat/2024/09/cost/index.html"},{"title":"自建音乐流媒体的碎碎念","text":"前言首先谈谈我对音乐，以及流媒体的理解 我对音乐的狭义理解是：由乐器弹奏，或者人哼唱出来的歌。对于流媒体，我认为在网络上传播的影像记录就是流媒体 现在我们来看看维基百科给它们的定义 音乐，广义而言，就是指任何以声音组成的艺术。英文Music一词源于古希腊语的μουσική（mousike），意即缪斯（muse）女神的艺术。而中文的音乐二字，东汉许慎《说文解字》解释为“音，声也。生于心，有节于外，谓之音。”认为音乐和声音的区别，在于音乐需要透过人心去想像和创造。 流媒体（英语：Streaming media），指将一连串的多媒体资料压缩后，经过互联网分段发送资料，在互联网上即时传输影音以供观赏的一种技术与过程，此技术使得资料数据包得以像流水一样发送，如果不使用此技术，就必须在使用前下载整个媒体文件。 除此之外，我在 音流 这款软件的文档上，看到了一段这样的说明 网络附接存储（英语：Network Attached Storage，缩写：NAS）是一种文件级（与块级存储相对）的计算机数据存储服务器，它连接到计算机网络，并提供对异构网络用户的数据访问。它专门用于通过其硬件、软件或配置来提供文件服务。它通常作为专门制造的专用计算机设备制造。 NAS系统是包含一个或多个通常排列成逻辑存储器、冗余存储器或RAID存储驱动器的网络设备。NAS消除了从网络上的其他服务器提供文件服务的负担，它们通常使用网络文件共享协议（如NFS、SMB或AFP）提供对文件的访问。作为一种在多台计算机之间共享文件的便捷方法，NAS设备从1990年代中期开始开始流行起来。与同样提供文件服务的通用服务器相比，专用网络附加存储的潜在优势包括更快的数据访问、更简单的管理和简单的配置。 我知道自建音乐流媒体是一个小众的需求，不过搭建一个音乐流媒体平台不需要借助 NAS 也是可行的，因为我观察到较为主流的开源流媒体服务都是支持 Docker 部署的 需求起初我是没有想要自建流媒体服务的，那时我对一款音乐播放器的需求是这样的 功能单一，只需要有基本的播放，收藏，查看歌词，歌手封面 有云盘功能，支持移动客户端上传音乐 没有广告（不充会员的情况） 我还在用的两款音乐软件，酷狗，网易云音乐都是无法满足第一点和第三点的，而且我以前根本不敢想的弹窗广告和摇一摇广告竟然都出现了。以至于很长一段时间内，我都是使用Bilibili来听视频，反正我这个木耳朵也听不出来区别 24 年阮一峰的博客推荐了一个音乐流媒体服务，现在尝试找了找，没找到当时的那篇博客。当时我尝试安装了试用了一下，原本以为它能像是一个只拥有播放，网盘功能的酷狗音乐。结果登录Web页面之后，什么都没有。现在想起来，是需要我先把音乐文件喂给它，它只负责读取然后播放。当时觉得这个东西根本没法用，就放弃了 最近刷到了一篇文章，问大家都用的什么音乐播放器。里面有人回答，Apple Music，Spotify，网易云音乐。使用 Apple Music 的用户觉得没广告音质好，推荐Spotify的用户说曲库全还免费，还在用网易云音乐的用户说自己是永久会员 就我个人而言，Apple Music 我也用过，周杰伦的歌也有，但我搜索进击的巨人时，给出的列表没有网易云音乐那样丰富 Spotify 我记得是有广告的，它是在听歌的间隙插入音频广告。也因为是国外设计的软件，用起来不习惯就放弃了。因为我听歌一般只认歌名和歌手，什么专辑对我而言是多余的东西 至于网易云音乐，广告以及功能太杂了，我觉得音乐播放器不应该这么臃肿 在众多的评论中，我看到有些人回复了一些我没听过的名字，这个 音流 就是其中之一 搜索了一下 音流，提供四端应用（Mac，Windows，Android，iOS）。看官网给出的截图也挺纯净简洁，勾起了我自建音乐流媒体的兴趣 说明需要说明的是，我们经常说的网易云音乐，Apple Music它们只是一个音频播放器客户端，真正大量保存音乐资源的都是在服务器上，网易云音乐有网易云音乐的服务器，Apple Music也有Apple Music的服务器，这样做才能让我们在移动终端上不需要下载也能听到音乐传作者们发布的歌曲 那么需要自建音乐平台，至少也要有一个服务端和一个终端。如果把这个服务端类比成网易云音乐的服务器，终端类比成网易云音乐的手机 app 或者电脑端的 app，应该会更形象一些 对比先确定了终端使用 音流 这款软件，那么就要看看音流这款移动终端它适配了哪些服务。这是 音流 官网给的适配功能对比 第一行是各个流媒体服务的名称 功能 Subsonic Navidrome Audio Station Emby Jellyfin Plex 内嵌歌词 - √ √ √ 外置歌词 - √ √ √ √ 在线歌词 - √ √ √ √ 歌手简介 - √ √ √ √ 歌手头像 - √ √ √ 多艺术家 - - √ √ 回放增益 - √ √ √ 评分功能 √ √ √ √ 收藏功能 √ √ √ √ 文件夹 - √ √ √ 删除接口 - √ √ √ 这是各个流媒体服务的特性对比 特性/平台 Subsonic Navidrome Audio Station Emby Jellyfin Plex 定位 音乐流媒体服务器 轻量级音乐服务器 Synology 专属音频服务 多媒体服务器 多媒体服务器 多媒体服务器 开源 部分开源 开源（GPL-3.0） 闭源 部分开源 开源（GPL-2.0） 闭源 支持的媒体类型 仅音频 仅音频 仅音频 音频、视频、图片 音频、视频、图片 音频、视频、图片 跨平台支持 是 是 否（仅 Synology NAS） 是 是 是 客户端支持 多种（Web、手机应用） Web、手机应用 手机应用、浏览器 多种（Web、应用） 多种（Web、应用） 多种（Web、应用） 多用户支持 是 是 是 是 是 是 离线下载 是 是 否 是 是 是 流媒体转码支持 是 是 否 是 是 是 字幕支持 否 否 否 是 是 是 多设备同步 否 否 是 是 是 是 免费使用 部分功能 完全免费 包含于 Synology 部分功能免费 完全免费 部分功能免费 高级功能付费 是 否 不适用 是 否 是 活跃社区 较小 较小 专注于 Synology 用户群体 较大 较大 较大 硬件需求 较低 较低 依赖 Synology NAS 中等 中等 中等 Docker 支持 是 是 否 是 是 是 我说说我的看法 Subsonic 算是老牌的流媒体服务了，后续很多的流媒体服务都是基于 Subsonic 的 api 开发的，不过 Subsonic 基于 Java 开发的，资源消耗也会大一点，而且对我来说，它的功能有点复杂了 Navidrome 是使用 Go 开发的，完全开源，在网上也看见了不少朋友在推荐，也满足我的基本要求，除了上传音乐的功能 Audio Station 就不说了，我需要一个能 Docker 部署的服务 另外三个我没实际安装体验过就不发表意见了 除了上面的六个流媒体服务器之外，基于上传的需求，我找到了 airsonic-advanced，一个基于 Subsonic 开发的流媒体服务器，也支持上传 不知道大家会不会觉得功能太复杂了，实际安装之后我觉得有些复杂了，自用的系统不需要这么多功能 那么最终就选定 Navidrome 了，开干 部署基于 Navidrome 的安装文档，很快都能配置完毕，以下是我的 docker compose 配置，仅供参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647services: navidrome: image: deluan/navidrome:0.54.3 container_name: navidrome restart: unless-stopped user: 1000:1000 networks: - music environment: ND_SCANSCHEDULE: 1h ND_LOGLEVEL: info ND_SESSIONTIMEOUT: 24h ND_DEFAULTLANGUAGE: zh-Hans ND_ENABLETRANSCODINGCONFIG: true volumes: - ~/applications/music/data:/data - ~/applications/music/music:/music:ro lrcapi: image: hisatri/lrcapi:1.5.7 container_name: lrcapi restart: unless-stopped networks: - music depends_on: - navidrome environment: - API_AUTH=xxx volumes: - ~/applications/music/music:/music route-music: image: nginx:latest container_name: route-music restart: unless-stopped ports: - 3312:3312 networks: - music depends_on: - navidrome - lrcapi volumes: - ~/applications/music/nginx/nginx.conf:/etc/nginx/nginx.conf:ro - ~/applications/music/nginx/logs:/opt/nginx/logsnetworks: music: driver: bridge hisatri/lrcapi:1.5.7：是一个补充服务，用于弥补 Navidrome 无法提供歌词和封面的缺陷 上传音乐自建的流媒体是没有任何音乐的，需要手动上传到流媒体服务器上。这也是我期望有上传功能的原因，但上传并没有在 Subsonic 的 api 中 我目前是通过 SFTP 上传到服务器的。我的听歌范围变化不那么频繁，这一步虽然麻烦但还能接受 成果展示 体验首先 音流 确实很简洁，没有任何广告，基本功能除了一个上传也够我用 其它一些缺点在于，Navidrome 流媒体服务安装在我家里，网络延迟有点大，有时候会出现歌词加载不及时的问题。至于听歌本身我感觉下来还是没什么问题的，主要还是因为我的歌曲大都都是 128k 音质的，大小在 5MB 以内 如此如此~~","link":"/chat/2025/01/music-stram/index.html"},{"title":"浅谈 @EventListener 和 @TransactionalEventListener","text":"前言spring 有一个事件传播机制,可以较为方便地实现一个简单的广播模型 一般使用 ApplicationEventPublisher(org.springframework.context.ApplicationEventPublisher) 来发布一个事件,然后使用 @EventListener 或者 @TransactionalEventListener 标记的方法来接收指定的事件 这样做有什么好处呢?一方面是解耦,另一方面提高可拓展性 @EventListener 使用我一般会这样使用 事件定义123@Builderpublic record UserUpdateEvent(Long id) {} 事件发布者: xxxService 中123456789@Transactional(rollbackFor = Exception.class)public void updateUser() { // 其他业务逻辑 // 发布一个 用户修改 事件 publisher.publishEvent(UserUpdateEvent.builder() .id(userId) .build());} 监听器: xxxListener 中1234@EventListener(UserUpdateEvent.class)public void onUserUpdate(final UserUpdateEvent userUpdateEvent) { log.info(&quot;onUserUpdate listener: {}&quot;, userUpdateEvent.id());} 在这种的用法中,但发布者发布事件之后,就会触发该事件的所有监听器,并在同一个线程中,一个一个地执行监听器的动作,最后才返回到发布事件的位置继续往下执行 如果想要执行执行监听器而不影响主流程,可以配合 @Async 注解实现异步 @EventListener 不适用场景试想一下这样一个场景 如果事件发布时处于处于一个数据库事务当中,同步监听这个事件的监听器发出了一个异步通知给第三方系统,第三方系统接收到这个通知之后需要回查状态.那么使用上面的方案可能会遇到什么问题 第三方系统回查状态时,事件发布者所在的事务已经完成提交 第三方系统回查状态时,事件发布者所在的事务还未提交 回查时事件发布者所在的事务还未提交,那么就可能查询到旧数据,导致数据不一致 想要解决这个问题,有哪些处理方案呢? 使用手动事务,在提交之后再发布事件 使用 @TransactionalEventListener 注解,使监听器在事务提交后再执行 本地消息表.适用于最终一致性场景 方案1 我在实践中遇到一个问题 一般而言, spring 的事务传播机制是 Propagation.REQUIRED,通俗来讲就是有事务时加入,没事务时新建一个事务 在上面的例子中,如果 updateUser 的调用者已经处于一个事务之中,那么 updateUser 便会加入这个事务 也就是在这种场景下说这个事务的边界并非时我们在 方案1 预想的那样,等待 updateUser 执行完毕之后,事务就被提交了.那么监听器仍然是有可能在一个事务之中被执行 将事务传播机制换成 Propagation.REQUIRES_NEW 也能解决这个问题,但这个改动不一定符合实际使用场景是吧 方案2 我重点说说 把原来的监听器改成如下这样,和之前的区别就是方法上的注解,它从 @EventListener 变成了 @TransactionalEventListener 1234@TransactionalEventListener(value = UserUpdateEvent.class, phase = TransactionPhase.AFTER_COMMIT)public void onUserUpdate(final UserUpdateEvent userUpdateEvent) { log.info(&quot;onUserUpdate listener: {}&quot;, userUpdateEvent.id());} 来看看这个注解的定义 1234567891011121314151617181920212223@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@EventListenerpublic @interface TransactionalEventListener { TransactionPhase phase() default TransactionPhase.AFTER_COMMIT; boolean fallbackExecution() default false; @AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;) Class&lt;?&gt;[] value() default {}; @AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;) Class&lt;?&gt;[] classes() default {}; @AliasFor(annotation = EventListener.class, attribute = &quot;condition&quot;) String condition() default &quot;&quot;; @AliasFor(annotation = EventListener.class, attribute = &quot;id&quot;) String id() default &quot;&quot;;} 这是个复合注解,它扩展了 @EventListener 比较重要的属性是 phase: 定义监听器的执行时机,可以配置成 BEFORE_COMMIT, AFTER_COMMIT, AFTER_ROLLBACK, AFTER_COMPLETION 四种.四个配置项基本都能见名知意,最后一个 AFTER_COMPLETION 的意思是无法事务执行成功与否都会执行监听器的动作 fallbackExecution: @TransactionalEventListener 比 @EventListener 更加特别的一个地方是,如果事件的发布者没有处于一个事务中,默认不会触发监听器的动作.但如果配置 fallbackExecution 为 true,那么在无事务时发布事件,也可以触发监听器 value 和 classes: 这两互为别名,和 @EventListener 中是一样的,表示监听的事件类型 方案3 就不讲了, spring 的事件机制不支持持久化,也不支持分布式,使用本地消息表方案建议配合 mq 食用 小结@EventListener 适合用在无事务,或者不关心监听器的执行与事件发布者处于同一个事务中的场景 @TransactionalEventListener 适合用在存在事务,且需要控制监听器在事务执行的某个阶段(BEFORE_COMMIT, AFTER_COMMIT, AFTER_ROLLBACK, AFTER_COMPLETION )执行的场景 问题解决,如果使用 @EventListener 和 @TransactionalEventListener 同时监听同一个事件,会怎么样呢 首先,需要明确一个前提,同时使用 @EventListener 和 @TransactionalEventListener 意味着发布事件的时机在事务中(@TransactionalEventListener 也可以用在非事务环境,但一般不会这样使用吧),那么可以确认了,@EventListener 的监听器会先于 @TransactionalEventListener 被执行 理由是 @EventListener 的监听器总是在发布事件之后就被触发,而此时事务仍然处于未提交状态 @EventListener 的原理注册 ApplicationListener在 spring 容器启动时,会将标记了 @EventListener 的方法包装成一个 ApplicationListener 对象存放到容器中 ApplicationListener 中包含了监听器被触发是需要执行的动作,也就是 onApplicationEvent 方法 在 ApplicationListenerMethodAdapter(org.springframework.context.event.ApplicationListenerMethodAdapter) 中,它的 onApplicationEvent 方法如下 1234567891011121314151617181920public void onApplicationEvent(ApplicationEvent event) { // 触发监听器动作 processEvent(event);}public void processEvent(ApplicationEvent event) { // 解析参数 Object[] args = resolveArguments(event); // 根据 condition 属性判断是否需要触发 if (shouldHandle(event, args)) { // 反射执行监听器动作 Object result = doInvoke(args); if (result != null) { handleResult(result); } else { logger.trace(&quot;No result object given - no result to handle&quot;); } }} 再看一下事件的发布者做了什么在 SimpleApplicationEventMulticaster(org.springframework.context.event.SimpleApplicationEventMulticaster) 中 1234567891011121314public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) { ResolvableType type = (eventType != null ? eventType : ResolvableType.forInstance(event)); Executor executor = getTaskExecutor(); for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) { if (executor != null &amp;&amp; listener.supportsAsyncExecution()) { // 异步执行 executor.execute(() -&gt; invokeListener(listener, event)); } else { // 同步执行 invokeListener(listener, event); } }} 根据事件类型取出所有的监听器 这里的源码我也没太看明白,但逻辑就是根据事件类型取出监听器 123456789101112131415161718192021222324252627282930313233343536protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners( ApplicationEvent event, ResolvableType eventType) { Object source = event.getSource(); Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null); ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType); // Potential new retriever to populate CachedListenerRetriever newRetriever = null; // Quick check for existing entry on ConcurrentHashMap CachedListenerRetriever existingRetriever = this.retrieverCache.get(cacheKey); if (existingRetriever == null) { // Caching a new ListenerRetriever if possible if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp; (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) { newRetriever = new CachedListenerRetriever(); existingRetriever = this.retrieverCache.putIfAbsent(cacheKey, newRetriever); if (existingRetriever != null) { newRetriever = null; // no need to populate it in retrieveApplicationListeners } } } if (existingRetriever != null) { Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners(); if (result != null) { return result; } // If result is null, the existing retriever is not fully populated yet by another thread. // Proceed like caching wasn't possible for this current local attempt. } return retrieveApplicationListeners(eventType, sourceType, newRetriever);} 然后循环挨个触发监听器动作一路追下去,可以在 invokeListener -&gt; doInvokeListener -&gt; listener.onApplicationEvent(event) 看到 onApplicationEvent 被触发了.完成了一个闭环 @TransactionalEventListener 的原理上面说的是 @EventListener 的原理,那么 @TransactionalEventListener 会怎么样呢 它们区别在于注册监听器类型不一样 @EventListener 使用了 ApplicationListenerMethodAdapter 包装它的执行动作 @TransactionalEventListener 使用了 TransactionalApplicationListenerMethodAdapter 包装它的执行动作 123// TransactionalApplicationListenerMethodAdapter 继承了 ApplicationListenerMethodAdapterpublic class TransactionalApplicationListenerMethodAdapter extends ApplicationListenerMethodAdapter implements TransactionalApplicationListener&lt;ApplicationEvent&gt; {} 此外, TransactionalApplicationListenerMethodAdapter 额外保存了 @TransactionalEventListener 注解特有的 transactionPhase 和 fallbackExecution 属性 TransactionalApplicationListenerMethodAdapter 还重写了 onApplicationEvent 方法 12345678910111213141516171819public void onApplicationEvent(ApplicationEvent event) { if (TransactionalApplicationListenerSynchronization.register(event, this, this.callbacks)) { if (logger.isDebugEnabled()) { logger.debug(&quot;Registered transaction synchronization for &quot; + event); } } else if (this.fallbackExecution) { if (getTransactionPhase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) { logger.warn(&quot;Processing &quot; + event + &quot; as a fallback execution on AFTER_ROLLBACK phase&quot;); } processEvent(event); } else { // No transactional event execution at all if (logger.isDebugEnabled()) { logger.debug(&quot;No transaction is active - skipping &quot; + event); } }} 最重要的就是 TransactionalApplicationListenerSynchronization.register(event, this, this.callbacks) 它依赖了 spring 事务,注册了一个事件,方便在事务的生命周期内执行注册的动作. register 方法会判断当前是否处于一个事务中,如果不处于事务中,则会返回 false 如果事务未开启,则会进入第二个 if 判断,即 fallbackExecution 设置为 true 时,即便没有事务也会执行 否则,什么都不做 小结对比 @EventListener 和 @TransactionalEventListener,会发现,其实这两在底层代码上的区别并不是很大. @TransactionalEventListener 的主流程和 @EventListener 大差不差 spring 启动时注册 监听器 为 ApplicationListener 事件发布者发布事件,触发 onApplicationEvent 方法 反射调用 监听器方法 区别在于 @TransactionalEventListener 在触发 onApplicationEvent 时通过 TransactionalApplicationListenerSynchronization.register 将监听器事件注册给了事务管理器,之后的触发逻辑就由事务管理器来负责了 TransactionalApplicationListenerSynchronization最后我们来看看 TransactionalApplicationListenerSynchronization 的 register 方法 123456789101112131415161718public static &lt;E extends ApplicationEvent&gt; boolean register( E event, TransactionalApplicationListener&lt;E&gt; listener, List&lt;TransactionalApplicationListener.SynchronizationCallback&gt; callbacks) { // 事务处于执行状态 if (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) { TransactionSynchronizationManager.registerSynchronization(new PlatformSynchronization&lt;&gt;(event, listener, callbacks)); return true; } // 和响应式事务有关 else if (event.getSource() instanceof TransactionContext txContext) { TransactionSynchronizationManager rtsm = new TransactionSynchronizationManager(txContext); if (rtsm.isSynchronizationActive() &amp;&amp; rtsm.isActualTransactionActive()) { rtsm.registerSynchronization(new ReactiveSynchronization&lt;&gt;(event, listener, callbacks)); return true; } } return false;} 我的环境使用的是普通的事务,走第一个 if 判断.如果事务处于执行状态,则将监听器事件包装起来并注册到事务管理器中 123456789public static void registerSynchronization(TransactionSynchronization synchronization) throws IllegalStateException { Assert.notNull(synchronization, &quot;TransactionSynchronization must not be null&quot;); Set&lt;TransactionSynchronization&gt; synchs = synchronizations.get(); if (synchs == null) { throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;); } synchs.add(synchronization);} 后面的触发实际就有 spring 事务管理了 再看看提交给事务管理器的 PlatformSynchronization 1234567891011121314151617181920212223242526272829303132333435private static class PlatformSynchronization&lt;AE extends ApplicationEvent&gt; extends TransactionalApplicationListenerSynchronization&lt;AE&gt; implements org.springframework.transaction.support.TransactionSynchronization { public PlatformSynchronization(AE event, TransactionalApplicationListener&lt;AE&gt; listener, List&lt;TransactionalApplicationListener.SynchronizationCallback&gt; callbacks) { super(event, listener, callbacks); } @Override public void beforeCommit(boolean readOnly) { // 事务提交前 if (getTransactionPhase() == TransactionPhase.BEFORE_COMMIT) { processEventWithCallbacks(); } } @Override public void afterCompletion(int status) { TransactionPhase phase = getTransactionPhase(); // 事务提交后 if (phase == TransactionPhase.AFTER_COMMIT &amp;&amp; status == STATUS_COMMITTED) { processEventWithCallbacks(); } // 事务回滚 else if (phase == TransactionPhase.AFTER_ROLLBACK &amp;&amp; status == STATUS_ROLLED_BACK) { processEventWithCallbacks(); } // 无论如何都执行 else if (phase == TransactionPhase.AFTER_COMPLETION) { processEventWithCallbacks(); } }} 刚好处理了 @TransactionalEventListener 中 phase 的四个配置项 而它实现的接口 TransactionSynchronization 定义了事务的生命周期钩子方法 123456789101112131415161718192021222324252627282930313233343536public interface TransactionSynchronization extends Ordered, Flushable { int STATUS_COMMITTED = 0; int STATUS_ROLLED_BACK = 1; int STATUS_UNKNOWN = 2; @Override default int getOrder() { return Ordered.LOWEST_PRECEDENCE; } default void suspend() { } default void resume() { } @Override default void flush() { } default void beforeCommit(boolean readOnly) { } default void beforeCompletion() { } default void afterCommit() { } default void afterCompletion(int status) { }} 最后本文简单阐述了 @EventListener 和 @TransactionalEventListener 的使用场景,以及区别,尝试结合源码来说明事件的发布流程","link":"/chat/2025/08/event-listener/index.html"},{"title":"珂朵莉树","text":"前言不知道你是否听说过一个叫珂朵莉树(ODT, Old Driver Tree)的”数据结构“，它有个名称：“老司机树” 珂朵莉这个人物名称来源于日漫《末日时在做什么？有没有空？可以来拯救吗？》中的女主角，之所以叫珂朵莉树是因为被发布在 codeforces 算法题背景人物中有珂朵莉 在洛谷的题目CF896C中文翻译中，不仅把题目背景介绍移除了，连背景图也移除了，真是本末倒置 wiki 上对它的解释如下 老司机树，ODT(Old Driver Tree)，又名珂朵莉树（Chtholly Tree)。起源自 CF896C。 会用 STL 的 set 就行。 把值相同的区间合并成一个结点保存在 set 里面。 这是一个基于 TreeMap 的暴力算法，用来解决一些区间赋值操作的数据结构题。在相对随机的数据场合，也堪堪能通过 几年前我刚在网络上偶然刷到相关的文章时，那时候我能找到的相关题解都还是基于 cpp 语言的，对 cpp 不熟悉成了我放弃理解这个算法的拦路虎 在现在大语言模型的帮助下，我重新理解了这个算法，并按自己的理解实现了 Java 版本和 Go 版本的 ODT 我的理解先看题目要求 分别要求四个操作 区间加 区间赋值 区间排序 区间求和 我认为 ODT 树实现的核心就是，执行操作前，先按要执行的区间进行拆分 比如，区间 [left, right] 加操作，先以拆成以 left 起始的区间，再拆 right + 1 （以 right + 1为起始，就意味着必定有一个区间以 right 结尾）为起始的区间 拆完之后，就意味着在 [left, right] 这个大区间中，刚好会存在一个或者多个子区间在这个大区间内，而且这些子区间可以保证是大区间的子集 这样处理之后，只需要快速遍历这个大区间的所有子区间，就可以很方便地执行上面的四个操作 对于操作1，每个子区间都加上给定的 val 对于操作2，直接移除所有的子区间，并新增一个区间，范围就是 [left, right]，值为给定的值 对于操作3，稍稍复杂一些，需要把所有子区间按 val 排序，然后找第 k 个值所在的区间 对于操作4，同样是遍历整个子区间，使用快速幂计算模 对于查找子区间，由于 TreeMap 的特性，只需要$$O(log(n))$$的时间复杂度即可定位到起始区间 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class ODT { private static final class TreeNode implements Comparable&lt;TreeNode&gt; { private final int left; private final int right; private long val; private TreeNode(int left, int right, long val) { this.left = left; this.right = right; this.val = val; } private TreeNode(final int left) { this.left = left; this.right = Integer.MIN_VALUE; } @Override public int compareTo(final ODT.TreeNode o) { return Integer.compare(this.left, o.left); } @Override public boolean equals(final Object o) { if (o == null || getClass() != o.getClass()) { return false; } final TreeNode treeNode = (TreeNode) o; return left == treeNode.left &amp;&amp; right == treeNode.right &amp;&amp; val == treeNode.val; } @Override public int hashCode() { return Objects.hash(left, right, val); } } private final TreeSet&lt;TreeNode&gt; tree = new TreeSet&lt;&gt;(); public ODT(long[] data) { Objects.requireNonNull(data, &quot;input data is null&quot;); final int n = data.length; if (n == 0) { return; } var pre = 0; for (int i = 1; i &lt; n; i++) { if (data[i] != data[i - 1]) { this.tree.add(new TreeNode(pre, i - 1, data[i - 1])); pre = i; } } this.tree.add(new TreeNode(pre, n - 1, data[n - 1])); } private void split(final int index) { final var floor = tree.floor(new TreeNode(index)); if (floor == null || floor.left == index || floor.right &lt; index) { return; } tree.remove(floor); tree.add(new TreeNode(floor.left, index - 1, floor.val)); tree.add(new TreeNode(index, floor.right, floor.val)); } public void add(final int left, final int right, final long val) { this.split(right + 1); this.split(left); tree.subSet(new TreeNode(left), new TreeNode(right + 1)) .forEach(node -&gt; node.val += val); } public void assign(final int left, final int right, final long val) { this.split(right + 1); this.split(left); tree.subSet(new TreeNode(left), new TreeNode(right + 1)) .clear(); tree.add(new TreeNode(left, right, val)); } public long kth(final int left, final int right, final int k) { this.split(right + 1); this.split(left); final var treeNodes = tree.subSet(new TreeNode(left), new TreeNode(right + 1)); final var sortTreeNodes = new ArrayList&lt;TreeNode&gt;(treeNodes.size()); sortTreeNodes.addAll(treeNodes); sortTreeNodes.sort(Comparator.comparingLong(node -&gt; node.val)); var kth = k; for (final var sortTreeNode : sortTreeNodes) { final var length = sortTreeNode.right - sortTreeNode.left + 1; if (length &gt;= kth) { return sortTreeNode.val; } kth -= length; } return -1; } public long powerSum(final int left, final int right, final long x, final long y) { this.split(right + 1); this.split(left); var ans = 0L; for (final var treeNode : tree.subSet(new TreeNode(left), new TreeNode(right + 1))) { final var length = treeNode.right - treeNode.left + 1; ans = (ans + this.pow(treeNode.val, x, y) * (length % y) % y) % y; } return ans; } private long pow(long base, long pow, final long mod) { var ans = 1L; base %= mod; while (pow &gt; 0) { if ((pow &amp; 1) == 1) { ans = (ans * base) % mod; } base = (base * base) % mod; pow &gt;&gt;= 1; } return ans; }} 这里也有一份 Go 的实现，但 Go 的标准库中并没有 TreeMap 的实现，所以依赖了一个第三方库 gods，但 codeforces 不接受引入第三方库，以下代码提交后直接提示编译错误了，但实际应该是可行的实现（可以跑过给出的测试用例，虽然只有两个测试用例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import ( &quot;fmt&quot; &quot;github.com/emirpasic/gods/trees/redblacktree&quot; &quot;slices&quot;)type ODT struct { tree *redblacktree.Tree}type treeNode struct { left int right int val int64}func NewODT(data []int64) *ODT { tree := redblacktree.NewWith(func(a, b interface{}) int { treeNode1 := a.(*treeNode) treeNode2 := b.(*treeNode) return treeNode1.left - treeNode2.left }) if len(data) == 0 { return &amp;ODT{tree} } pre := 0 n := len(data) for i := 1; i &lt; n; i++ { if data[i] != data[i-1] { tree.Put(&amp;treeNode{pre, i - 1, data[i-1]}, struct{}{}) pre = i } } tree.Put(&amp;treeNode{pre, n - 1, data[n-1]}, struct{}{}) return &amp;ODT{tree}}func (o *ODT) split(index int) { key, ok := o.tree.Floor(&amp;treeNode{left: index}) if !ok || key.Key.(*treeNode).left == index || key.Key.(*treeNode).right &lt; index { return } node := key.Key.(*treeNode) o.tree.Remove(node) o.tree.Put(&amp;treeNode{node.left, index - 1, node.val}, struct{}{}) o.tree.Put(&amp;treeNode{index, node.right, node.val}, struct{}{})}func (o *ODT) foreach(start, end int, handle func(*treeNode)) { cur, _ := o.tree.Floor(&amp;treeNode{left: start}) iterator := o.tree.IteratorAt(cur) for { node := iterator.Key().(*treeNode) if node.left &gt; end { break } handle(node) if !iterator.Next() { break } }}func (o *ODT) Add(left, right int, val int64) { o.split(right + 1) o.split(left) o.foreach(left, right, func(node *treeNode) { node.val += val })}func (o *ODT) Assign(left, right int, val int64) { o.split(right + 1) o.split(left) var deleteNodes []*treeNode o.foreach(left, right, func(node *treeNode) { deleteNodes = append(deleteNodes, node) }) for _, node := range deleteNodes { o.tree.Remove(node) } o.tree.Put(&amp;treeNode{left, right, val}, struct{}{})}func (o *ODT) Kth(left, right, kth int) int64 { o.split(right + 1) o.split(left) var sortNodes []*treeNode o.foreach(left, right, func(node *treeNode) { sortNodes = append(sortNodes, node) }) slices.SortFunc(sortNodes, func(a, b *treeNode) int { return int(a.val - b.val) }) for _, node := range sortNodes { length := node.right - node.left + 1 if kth &lt;= length { return node.val } kth -= length } return -1}func (o *ODT) PowerSum(left, right int, x, y int64) int64 { o.split(right + 1) o.split(left) ans := int64(0) o.foreach(left, right, func(node *treeNode) { ans = (ans + ((int64(node.right-node.left+1)%y)*pow(node.val, x, y))%y) % y }) return ans}func pow(base, pow, mod int64) int64 { ans := int64(1) base %= mod for pow &gt; 0 { if (pow &amp; 1) == 1 { ans = (ans * base) % mod } base = (base * base) % mod pow &gt;&gt;= 1 } return ans} 总结ODT 树不算是一个多高级的数据结构，甚至也不算一个数据结构，强依赖了 TreeMap 我之所以有想法去探讨这个算法，应该是因为我们都喜欢珂朵莉吧","link":"/chat/2025/08/odt/index.html"},{"title":"VisualVM 远程连接","text":"VisualVM 远程连接简介 VisualVM is a visual tool integrating commandline JDK tools and lightweight profiling capabilities.Designed for both development and production time use.谷歌翻译：VisualVM 是一个集成了命令行 JDK 工具和轻量级分析功能的可视化工具。 专为开发和生产时间使用而设计。 服务端jstatd 授权文件 - jstatd.all.policyjdk8123grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; { permission java.security.AllPermission;}; jdk9+1234567grant codebase &quot;jrt:/jdk.jstatd&quot; { permission java.security.AllPermission;};grant codebase &quot;jrt:/jdk.internal.jvmstat&quot; { permission java.security.AllPermission;}; 启动 jstatd tool12# -p 指定使用的端口，默认使用的是 1099 端口jstatd -J-Djava.security.policy=&lt;jstatd.all.policy文件的路径&gt;/jstatd.all.policy -J-Djava.rmi.server.hostname=&lt;对外暴露的主机ip&gt; -p 1099 开放端口 1099 端口：jstatd 工具默认使用的是 1099 端口 其他：jstatd 工具还会使用一个端口，需要在运行期间查询获的。可通过 netstat 指令查询获取 1234&gt; netstat -tanp | grep jstatdtcp6 0 0 :::1099 :::* LISTEN 4046836/jstatd tcp6 0 0 :::40499 :::* LISTEN 4046836/jstatd tcp6 0 0 xx.xx.xx.xx:40499 xx.xx.xx.xx:60082 ESTABLISHED 4046836/jstatd 那么除了 1099 端口以外，还需要开放 40499 端口 注意：40499 端口是在 jstatd 运行之后查询获得的，每次重启 jstatd 都可能会不一样 客户端安装 VisualVm12# mac 环境brew install visualvm 远程连接服务端 选择需要查看的 JVM 进程 查看 GC 情况 CPU 内存指标需要使用 JMX，使用 JMX 需要服务端的 JVM 应用开启相关配置","link":"/jvm/2024/02/VisualVM%20%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/index.html"},{"title":"2824. 统计和小于目标的下标对数目","text":"2824. 统计和小于目标的下标对数目 难度: easy 原始链接: https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target 标签: 排序, 二分 解法一: 枚举go123456789101112func countPairs(nums []int, target int) int { ans := 0 length := len(nums) for i := 0; i &lt; length; i++ { for j := i + 1; j &lt; length; j++ { if nums[i] + nums[j] &lt; target { ans++ } } } return ans} 解法二: 排序, 二分go1234567891011121314151617181920func countPairs(nums []int, target int) int { sort.Ints(nums) ans := 0 length := len(nums) for i := 0; i &lt; length; i++ { left := i right := length - 1 curTarget := target - nums[i] for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if nums[mid] &gt;= curTarget { right = mid - 1 } else { left = mid } } ans += left - i } return ans}","link":"/leetcode/2023/11/count-pairs-whose-sum-is-less-than-target/index.html"},{"title":"2316. 统计无向图中无法互相到达点对数","text":"2316. 统计无向图中无法互相到达点对数 难度: medium 原始链接: https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031func countPairs(n int, edges [][]int) int64 { grip := make([][]int, n) for i := 0; i &lt; n; i++ { grip[i] = []int{} } for _, edge := range edges { grip[edge[0]] = append(grip[edge[0]], edge[1]) grip[edge[1]] = append(grip[edge[1]], edge[0]) } visit := make([]bool, n) var ans int64 var total int64 for i := 0; i &lt; n; i++ { size := dfs(i, grip, visit) ans += size * total total += size } return ans}func dfs(num int, grip [][]int, visit []bool) int64 { if visit[num] { return 0 } visit[num] = true var size int64 = 1 for _, num2 := range grip[num] { size += dfs(num2, grip, visit) } return size}","link":"/leetcode/2023/11/count-unreachable-pairs-of-nodes-in-an-undirected-graph/index.html"},{"title":"1670. 设计前中后队列","text":"1670. 设计前中后队列 难度: medium 原始链接: https://leetcode.cn/problems/design-front-middle-back-queue 标签: 队列 解法一: 队列java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class FrontMiddleBackQueue { private Deque&lt;Integer&gt; leftDeque; private Deque&lt;Integer&gt; rightDeque; public FrontMiddleBackQueue() { this.leftDeque = new LinkedList&lt;&gt;(); this.rightDeque = new LinkedList&lt;&gt;(); } public void pushFront(int val) { leftDeque.addFirst(val); if (leftDeque.size() &gt; rightDeque.size() + 1) { rightDeque.addFirst(leftDeque.pollLast()); } } public void pushMiddle(int val) { if (leftDeque.size() &gt; rightDeque.size()) { rightDeque.addFirst(leftDeque.pollLast()); } leftDeque.addLast(val); } public void pushBack(int val) { rightDeque.addLast(val); if (rightDeque.size() &gt; leftDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } } public int popFront() { if (leftDeque.isEmpty()) { return -1; } Integer ans = leftDeque.pollFirst(); if (leftDeque.size() &lt; rightDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } return ans; } public int popMiddle() { if (leftDeque.isEmpty()) { return -1; } Integer ans = leftDeque.pollLast(); if (leftDeque.size() &lt; rightDeque.size()) { leftDeque.addLast(rightDeque.pollFirst()); } return ans; } public int popBack() { if (rightDeque.isEmpty()) { if (leftDeque.isEmpty()) { return -1; } return leftDeque.pollLast(); } Integer ans = rightDeque.pollLast(); if (leftDeque.size() &gt; rightDeque.size() + 1) { rightDeque.addFirst(leftDeque.pollLast()); } return ans; } }/** * Your FrontMiddleBackQueue object will be instantiated and called as such: * FrontMiddleBackQueue obj = new FrontMiddleBackQueue(); * obj.pushFront(val); * obj.pushMiddle(val); * obj.pushBack(val); * int param_4 = obj.popFront(); * int param_5 = obj.popMiddle(); * int param_6 = obj.popBack(); */","link":"/leetcode/2023/11/design-front-middle-back-queue/index.html"},{"title":"1657. 确定两个字符串是否接近","text":"1657. 确定两个字符串是否接近 难度: medium 原始链接: https://leetcode.cn/problems/determine-if-two-strings-are-close 标签: 哈希计数 解法一: 哈希计数go1234567891011121314151617181920func closeStrings(word1 string, word2 string) bool { n := len(word1) if n != len(word2) { return false } counter := [2][26]int{} flags := [2]int{} for i := 0; i &lt; n; i++ { counter[0][word1[i] - 'a']++ counter[1][word2[i] - 'a']++ flags[0] |= 1 &lt;&lt; int(word1[i] - 'a') flags[1] |= 1 &lt;&lt; int(word2[i] - 'a') } if flags[0] != flags[1] { return false } sort.Ints(counter[0][:]) sort.Ints(counter[1][:]) return counter[0] == counter[1]}","link":"/leetcode/2023/11/determine-if-two-strings-are-close/index.html"},{"title":"1410. HTML 实体解析器","text":"1410. HTML 实体解析器 难度: medium 原始链接: https://leetcode.cn/problems/html-entity-parser 标签: 模拟 解法一: 模拟go123456789101112131415161718192021222324252627282930func entityParser(text string) string { n := len(text) sb := strings.Builder{} wordMap := map[string]string{ &quot;&amp;quot;&quot;: &quot;\\&quot;&quot;, &quot;&amp;apos;&quot;: &quot;'&quot;, &quot;&amp;amp;&quot;: &quot;&amp;&quot;, &quot;&amp;gt;&quot;: &quot;&gt;&quot;, &quot;&amp;lt;&quot;: &quot;&lt;&quot;, &quot;&amp;frasl;&quot;: &quot;/&quot;, } for i := 0; i &lt; n; { isReplace := false if text[i] == '&amp;' { for source, target := range wordMap { if i + len(source) &lt;= n &amp;&amp; text[i:i+len(source)] == source { sb.WriteString(target) i += len(source) isReplace = true break } } } if(!isReplace) { sb.WriteString(string(text[i])) i++ } } return sb.String()}","link":"/leetcode/2023/11/html-entity-parser/index.html"},{"title":"2342. 数位和相等数对的最大和","text":"2342. 数位和相等数对的最大和 难度: medium 原始链接: https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits 标签: 哈希, 贪心 解法一: 哈希, 贪心go1234567891011121314151617181920212223242526272829303132func maximumSum(nums []int) int { maxSumMap := make(map[int]int) ans := -1 for _, num := range nums { numSum := calcNumSum(num) if maxNum, exists := maxSumMap[numSum]; exists { if maxNum &lt; num { maxSumMap[numSum] = num } ans = max(ans, maxNum + num) } else { maxSumMap[numSum] = num } } return ans}func calcNumSum(num int) int { sum := 0 for num != 0 { sum += num % 10 num /= 10 } return sum}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/max-sum-of-a-pair-with-equal-sum-of-digits/index.html"},{"title":"2530. 执行 K 次操作后的最大分数","text":"2530. 执行 K 次操作后的最大分数 难度: medium 原始链接: https://leetcode.cn/problems/maximal-score-after-applying-k-operations 标签: 大根堆 解法一: 大根堆java123456789101112131415class Solution { public long maxKelements(int[] nums, int k) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); for (int num : nums) { priorityQueue.offer(num); } long ans = 0; for (int i = 0; i &lt; k; i++) { int num = priorityQueue.poll(); ans += num; priorityQueue.offer((num + 2) / 3); } return ans; }}","link":"/leetcode/2023/11/maximal-score-after-applying-k-operations/index.html"},{"title":"318. 最大单词长度乘积","text":"318. 最大单词长度乘积 难度: medium 原始链接: https://leetcode.cn/problems/maximum-product-of-word-lengths 标签: 位运算 解法一: 位运算go123456789101112131415161718192021222324252627func maxProduct(words []string) int { length := len(words) arr := make([]int, length) for i := 0; i &lt; length; i++ { num := 0 for _, word := range words[i] { num |= 1 &lt;&lt; int(word - 'a') } arr[i] = num } ans := 0 for i := 0; i &lt; length; i++ { for j := 0; j &lt; length; j++ { if arr[i] &amp; arr[j] == 0 { ans = max(ans, len(words[i]) * len(words[j])) } } } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/maximum-product-of-word-lengths/index.html"},{"title":"53. 最大子数组和","text":"53. 最大子数组和 难度: medium 原始链接: https://leetcode.cn/problems/maximum-subarray 标签: 动态规划, 分治法 解法一: 动态规划go12345678910111213141516func maxSubArray(nums []int) int { ans := nums[0] pre := nums[0] for _, num := range nums[1:] { pre = max(pre + num, num) ans = max(ans, pre) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2} 解法二: 分治法go12345678910111213141516171819202122232425262728293031323334353637383940414243func maxSubArray(nums []int) int { return dfs(nums, 0, len(nums) - 1)}func dfs(nums []int, left int, right int) int { if left == right { return nums[left] } mid := ((right - left) &gt;&gt; 1) + left leftSum := dfs(nums, left, mid) rightSum := dfs(nums, mid + 1, right) midSum := calcMidSubArray(nums, left, right, mid) return max(leftSum, max(rightSum, midSum))}func calcMidSubArray(nums []int, left, right, mid int) int { leftSum := -1000000000 sum := 0 for i := mid; i &gt;= left; i-- { sum += nums[i] if sum &gt; leftSum { leftSum = sum } } rightSum := -1000000000 sum = 0 for i := mid + 1; i &lt;= right; i++ { sum += nums[i] if sum &gt; rightSum { rightSum = sum } } return leftSum + rightSum}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/maximum-subarray/index.html"},{"title":"2216. 美化数组的最少删除数","text":"2216. 美化数组的最少删除数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful 标签: 模拟 解法一: 模拟go1234567891011121314func minDeletion(nums []int) int { count := 1 pre := nums[0] for _, num := range nums[1:] { if pre != num || pre == num &amp;&amp; (count &amp; 1) == 0 { count++ pre = num } } if (count &amp; 1) != 0 { return len(nums) - count + 1 } return len(nums) - count}","link":"/leetcode/2023/11/minimum-deletions-to-make-array-beautiful/index.html"},{"title":"2304. 网格中的最小路径代价","text":"2304. 网格中的最小路径代价 难度: medium 原始链接: https://leetcode.cn/problems/minimum-path-cost-in-a-grid 标签: 动态规划 解法一: 递归go1234567891011121314151617181920212223242526272829303132333435func minPathCost(grid [][]int, moveCost [][]int) int { m := len(grid) n := len(grid[0]) ans := math.MaxInt visits := make([][]int, m) for i := 0; i &lt; m; i++ { visits[i] = make([]int, n) } for i := 0; i &lt; n; i++ { ans = min(ans, dfs(grid, moveCost, visits, 0, i, m, n)) } return ans}func dfs(grid [][]int, moveCost [][]int, visits [][]int, i, j, m, n int) int { if visits[i][j] != 0 { return visits[i][j] } if i == m - 1 { return grid[i][j] } minVal := math.MaxInt for k := 0; k &lt; n; k++ { minVal = min(minVal, dfs(grid, moveCost, visits, i + 1, k, m, n) + moveCost[grid[i][j]][k]) } visits[i][j] = grid[i][j] + minVal return visits[i][j]}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2} 解法二: 迭代go123456789101112131415161718192021222324252627282930313233func minPathCost(grid [][]int, moveCost [][]int) int { m := len(grid) n := len(grid[0]) arr := [][]int{ make([]int, n), make([]int, n), } for i := 0; i &lt; n; i++ { arr[0][i] = grid[0][i] } for i := 1; i &lt; m; i++ { for j := 0; j &lt; n; j++ { minVal := math.MaxInt for k := 0; k &lt; n; k++ { minVal = min(minVal, arr[0][k] + moveCost[grid[i - 1][k]][j]) } arr[1][j] = minVal + grid[i][j] } arr[0], arr[1] = arr[1], arr[0] } ans := math.MaxInt for _, num := range arr[0] { ans = min(ans, num) } return ans}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/11/minimum-path-cost-in-a-grid/index.html"},{"title":"117. 填充每个节点的下一个右侧节点指针 II","text":"117. 填充每个节点的下一个右侧节点指针 II 难度: medium 原始链接: https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii 标签: bfs 解法一: bfsgo1234567891011121314151617181920212223242526272829303132333435/** * Definition for a Node. * type Node struct { * Val int * Left *Node * Right *Node * Next *Node * } */func connect(root *Node) *Node { if root == nil { return nil } queue := []*Node{root} for len(queue) &gt; 0 { length := len(queue) var pre *Node for i := 0; i &lt; length; i++ { node := queue[i] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } if i &gt; 0 { pre.Next = node } pre = node } queue = queue[length:] } return root} 解法二: 利用 Next 指针go123456789101112131415161718192021222324252627282930313233/** * Definition for a Node. * type Node struct { * Val int * Left *Node * Right *Node * Next *Node * } */func connect(root *Node) *Node { if root == nil { return nil } cur := root for cur != nil { linkNodeRoot := &amp;Node{Val: -1} curLinkNode := linkNodeRoot for cur != nil { if cur.Left != nil { curLinkNode.Next = cur.Left curLinkNode = curLinkNode.Next } if cur.Right != nil { curLinkNode.Next = cur.Right curLinkNode = curLinkNode.Next } cur = cur.Next } cur = linkNodeRoot.Next } return root}","link":"/leetcode/2023/11/populating-next-right-pointers-in-each-node-ii/index.html"},{"title":"1457. 二叉树中的伪回文路径","text":"1457. 二叉树中的伪回文路径 难度: medium 原始链接: https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree 标签: dfs 解法一: dfsgo1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func pseudoPalindromicPaths (root *TreeNode) int { flag := 0 var dfs func(node *TreeNode) int dfs = func(node *TreeNode) int { if node == nil { return 0 } count := 0 flag ^= 1 &lt;&lt; node.Val if node.Left == nil &amp;&amp; node.Right == nil { if flag == 0 || (flag &amp; (flag - 1)) == 0 { count = 1 } } else { count = dfs(node.Left) + dfs(node.Right) } flag ^= 1 &lt;&lt; node.Val return count } return dfs(root)}","link":"/leetcode/2023/11/pseudo-palindromic-paths-in-a-binary-tree/index.html"},{"title":"307. 区域和检索 - 数组可修改","text":"307. 区域和检索 - 数组可修改 难度: medium 原始链接: https://leetcode.cn/problems/range-sum-query-mutable 标签: 线段树 解法一: 线段树go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879type NumArray struct { leftNumArray *NumArray rightNumArray *NumArray left int right int sum int}func Constructor(nums []int) NumArray { return *dfs(nums, 0, len(nums) - 1)}func dfs(nums []int, left, right int) *NumArray { if left == right { return &amp;NumArray{ leftNumArray: nil, rightNumArray: nil, left: left, right: right, sum: nums[left], } } mid := ((right - left) &gt;&gt; 1) + left leftNumArray := dfs(nums, left, mid) rightNumArray := dfs(nums, mid + 1, right) return &amp;NumArray{ leftNumArray: leftNumArray, rightNumArray: rightNumArray, left: left, right: right, sum: leftNumArray.sum + rightNumArray.sum, }}func queryRange(numArray *NumArray, left, right int) int { if numArray.left == left &amp;&amp; numArray.right == right { return numArray.sum } mid := ((numArray.right - numArray.left) &gt;&gt; 1) + numArray.left if left &gt; mid { return queryRange(numArray.rightNumArray, left, right) } else if right &lt;= mid { return queryRange(numArray.leftNumArray, left, right) } return queryRange(numArray.leftNumArray, left, mid) + queryRange(numArray.rightNumArray, mid + 1, right)}func updateRange(numArray *NumArray, left, right, val int) *NumArray { if numArray.left == numArray.right &amp;&amp; numArray.left == left { numArray.sum = val return numArray } mid := ((numArray.right - numArray.left) &gt;&gt; 1) + numArray.left if left &gt; mid { updateRange(numArray.rightNumArray, left, right, val) } else if right &lt;= mid { updateRange(numArray.leftNumArray, left, right, val) } else { updateRange(numArray.leftNumArray, left, mid, val) updateRange(numArray.rightNumArray, mid + 1, right, val) } numArray.sum = numArray.leftNumArray.sum + numArray.rightNumArray.sum return numArray}func (this *NumArray) Update(index int, val int) { updateRange(this, index, index, val)}func (this *NumArray) SumRange(left int, right int) int { return queryRange(this, left, right)}/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * obj.Update(index,val); * param_2 := obj.SumRange(left,right); */","link":"/leetcode/2023/11/range-sum-query-mutable/index.html"},{"title":"187. 重复的DNA序列","text":"187. 重复的DNA序列 难度: medium 原始链接: https://leetcode.cn/problems/repeated-dna-sequences 标签: 哈希, 位运算 解法一: 哈希go12345678910111213141516171819202122func findRepeatedDnaSequences(s string) []string { length := len(s) if length &lt; 10 { return []string{} } hash := map[string]int{} str := &quot;0&quot; ans := []string{} for i := 0; i &lt; length; i++ { for len(str) &lt; 10 { str += string(s[i]) i++ } str += string(s[i]) str = str[1:] if hash[str] == 1 { ans = append(ans, str) } hash[str]++ } return ans} 解法二: 位运算go1234567891011121314151617181920212223242526272829303132func findRepeatedDnaSequences(s string) []string { length := len(s) if length &lt; 10 { return []string{} } num := 0 dict := map[byte]int{ 'A': 0, 'C': 1, 'G': 2, 'T': 3, } for i := 0; i &lt; 10; i++ { num = (num &lt;&lt; 2) | dict[s[i]] } hash := map[int]int{ num: 1, } ans := []string{} for i := 10; i &lt; length; i++ { num = ((num &lt;&lt; 2) | dict[s[i]]) &amp; ((1 &lt;&lt; 20) - 1) if hash[num] == 1 { sb := strings.Builder{} for j := i - 9; j &lt;= i; j++ { sb.WriteString(string(s[j])) } ans = append(ans, sb.String()) } hash[num]++ } return ans}","link":"/leetcode/2023/11/repeated-dna-sequences/index.html"},{"title":"2103. 环和杆","text":"2103. 环和杆 难度: easy 原始链接: https://leetcode.cn/problems/rings-and-rods 标签: 位运算 解法一: 位运算go1234567891011121314151617181920212223func countPoints(rings string) int { flag := 0 length := len(rings) for i := 1; i &lt; length; i += 2 { shift := 0 if rings[i - 1] == 'R' { shift = 1 } else if rings[i - 1] == 'G' { shift = 1 &lt;&lt; 1 } else if rings[i - 1] == 'B' { shift = 1 &lt;&lt; 2 } flag |= shift &lt;&lt; (int(rings[i] - '0') * 3) } ans := 0 for flag != 0 { if (flag &amp; 7) == 7 { ans++ } flag &gt;&gt;= 3 } return ans}","link":"/leetcode/2023/11/rings-and-rods/index.html"},{"title":"260. 只出现一次的数字 III","text":"260. 只出现一次的数字 III 难度: medium 原始链接: https://leetcode.cn/problems/single-number-iii 标签: 位运算 解法一: 位运算go1234567891011121314func singleNumber(nums []int) []int { xor := 0 for _, num := range nums { xor ^= num } mask := xor &amp; ((^xor) + 1) num1 := 0 for _, num := range nums { if (num &amp; mask) != 0 { num1 ^= num } } return []int{num1, xor ^ num1}}","link":"/leetcode/2023/11/single-number-iii/index.html"},{"title":"2336. 无限集中的最小数字","text":"2336. 无限集中的最小数字 难度: medium 原始链接: https://leetcode.cn/problems/smallest-number-in-infinite-set 标签: 有序哈希, 优先级队列 解法一: 有序哈希java123456789101112131415161718192021222324252627class SmallestInfiniteSet { private TreeSet&lt;Integer&gt; treeSet; public SmallestInfiniteSet() { treeSet = new TreeSet&lt;&gt;(); for (int i = 1; i &lt;= 1000; i++) { treeSet.add(i); } } public int popSmallest() { return treeSet.pollFirst(); } public void addBack(int num) { treeSet.add(num); } }/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ 解法二: 优先级队列java1234567891011121314151617181920212223242526272829303132333435363738class SmallestInfiniteSet { private PriorityQueue&lt;Integer&gt; priorityQueue; private boolean[] exists; private int min; public SmallestInfiniteSet() { priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); min = 1; exists = new boolean[1001]; } public int popSmallest() { if (!priorityQueue.isEmpty() &amp;&amp; exists[priorityQueue.peek()]) { Integer ans = priorityQueue.poll(); exists[ans] = false; return ans; } return min++; } public void addBack(int num) { if (num &lt; min &amp;&amp; !exists[num]) { priorityQueue.offer(num); exists[num] = true; } }}/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */","link":"/leetcode/2023/11/smallest-number-in-infinite-set/index.html"},{"title":"2300. 咒语和药水的成功对数","text":"2300. 咒语和药水的成功对数 难度: medium 原始链接: https://leetcode.cn/problems/successful-pairs-of-spells-and-potions 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920212223func successfulPairs(spells []int, potions []int, success int64) []int { sort.Ints(potions) ans := make([]int, len(spells)) length := len(potions) for i, num := range spells { ans[i] = length - halfSearch(potions, int((success + int64(num) - 1) / int64(num))) } return ans}func halfSearch(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if nums[mid] &lt; target { left = mid + 1 } else { right = mid - 1 } } return left}","link":"/leetcode/2023/11/successful-pairs-of-spells-and-potions/index.html"},{"title":"2652. 倍数求和","text":"2652. 倍数求和 难度: easy 原始链接: https://leetcode.cn/problems/sum-multiples 标签: 模拟 解法一: 枚举go123456789func sumOfMultiples(n int) int { sum := 0 for i := 0; i &lt;= n; i++ { if i % 3 == 0 || i % 5 == 0 || i % 7 == 0 { sum += i } } return sum}","link":"/leetcode/2023/11/sum-multiples/index.html"},{"title":"907. 子数组的最小值之和","text":"907. 子数组的最小值之和 难度: medium 原始链接: https://leetcode.cn/problems/sum-of-subarray-minimums 标签: 单调栈 解法一: 单调栈go123456789101112131415161718192021222324252627282930313233343536func sumSubarrayMins(arr []int) int { n := len(arr) leftArr := make([]int, n) queue := []int{} for i, num := range arr { for len(queue) &gt; 0 &amp;&amp; arr[queue[len(queue) - 1]] &gt; num { queue = queue[:len(queue) - 1] } if len(queue) == 0 { leftArr[i] = -1 } else { leftArr[i] = queue[len(queue) - 1] } queue = append(queue, i) } rightArr := make([]int, n) queue = []int{} for i := n - 1; i &gt;= 0; i-- { num := arr[i] for len(queue) &gt; 0 &amp;&amp; arr[queue[len(queue) - 1]] &gt;= num { queue = queue[:len(queue) - 1] } if len(queue) == 0 { rightArr[i] = n } else { rightArr[i] = queue[len(queue) - 1] } queue = append(queue, i) } ans := 0 const MOD = 1000000007 for i, num := range arr { ans = (ans + num * (i - leftArr[i]) * (rightArr[i] - i)) % MOD } return ans}","link":"/leetcode/2023/11/sum-of-subarray-minimums/index.html"},{"title":"1726. 同积元组","text":"1726. 同积元组 难度: medium 原始链接: https://leetcode.cn/problems/tuple-with-same-product 标签: 哈希, 数学 解法一: 哈希, 数学go1234567891011121314func tupleSameProduct(nums []int) int { mulMap := make(map[int]int) length := len(nums) for i := 0; i &lt; length; i++ { for j := i + 1; j &lt; length; j++ { mulMap[nums[i] * nums[j]]++ } } ans := 0 for _, count := range mulMap { ans += count * (count - 1) * 4 } return ans}","link":"/leetcode/2023/11/tuple-with-same-product/index.html"},{"title":"1038. 从二叉搜索树到更大和树","text":"1038. 从二叉搜索树到更大和树 难度: medium 原始链接: https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree 标签: 中序遍历 解法一: 中序遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func bstToGst(root *TreeNode) *TreeNode { var dfs func (node *TreeNode, sum int) int dfs = func (node *TreeNode, sum int) int { if node == nil { return sum } node.Val += dfs(node.Right, sum) return dfs(node.Left, node.Val) } dfs(root, 0) return root}","link":"/leetcode/2023/12/binary-search-tree-to-greater-sum-tree/index.html"},{"title":"2706. 购买两块巧克力","text":"2706. 购买两块巧克力 难度: easy 原始链接: https://leetcode.cn/problems/buy-two-chocolates 标签: 一次遍历 解法一: 一次遍历go12345678910111213141516func buyChoco(prices []int, money int) int { first := 100 second := 100 for _, price := range prices { if first &gt; price { second = first first = price } else if second &gt; price { second = price } } if first + second &gt; money { return money } return money - first - second}","link":"/leetcode/2023/12/buy-two-chocolates/index.html"},{"title":"1094. 拼车","text":"1094. 拼车 难度: medium 原始链接: https://leetcode.cn/problems/car-pooling 标签: 堆排序, 差分数组 解法一: 堆排序java123456789101112131415161718class Solution { public boolean carPooling(int[][] trips, int capacity) { Arrays.sort(trips, (arr1, arr2) -&gt; arr1[1] - arr2[1]); PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr1[2] - arr2[2]); int peopleCount = 0; for (int[] trip : trips) { while (!priorityQueue.isEmpty() &amp;&amp; trip[1] &gt;= priorityQueue.peek()[2]) { peopleCount -= priorityQueue.poll()[0]; } priorityQueue.offer(trip); peopleCount += trip[0]; if (peopleCount &gt; capacity) { return false; } } return true; }} 解法二: 差分数组go123456789101112131415func carPooling(trips [][]int, capacity int) bool { arr := make([]int, 1001) for _, trip := range trips { arr[trip[1]] += trip[0] arr[trip[2]] -= trip[0] } sum := 0 for _, num := range arr { sum += num if sum &gt; capacity { return false } } return true}","link":"/leetcode/2023/12/car-pooling/index.html"},{"title":"2828. 判别首字母缩略词","text":"2828. 判别首字母缩略词 难度: easy 原始链接: https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words 标签: 模拟 解法一: 朴素模拟go1234567891011func isAcronym(words []string, s string) bool { if len(words) != len(s) { return false } for i, word := range words { if word[0] != s[i] { return false } } return true} 解法二: java 一行java1234567class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { return Objects.equals(words.stream() .map(word -&gt; String.valueOf(word.charAt(0))) .collect(Collectors.joining()), s); }}","link":"/leetcode/2023/12/check-if-a-string-is-an-acronym-of-words/index.html"},{"title":"70. 爬楼梯","text":"70. 爬楼梯 难度: easy 原始链接: https://leetcode.cn/problems/climbing-stairs 标签: 动态规划 解法一: 动态规划: O(n) 空间复杂度go123456789101112func climbStairs(n int) int { if n == 1 { return 1 } dp := make([]int, n + 1) dp[1] = 1 dp[2] = 2 for i := 3; i &lt;= n; i++ { dp[i] = dp[i - 2] + dp[i - 1] } return dp[n]} 解法二: 动态规划: O(1) 空间复杂度go1234567891011func climbStairs(n int) int { if n == 1 { return 1 } i1 := 1 i2 := 2 for i := 3; i &lt;= n; i++ { i1, i2 = i2, i1 + i2 } return i2}","link":"/leetcode/2023/12/climbing-stairs/index.html"},{"title":"1185. 一周中的第几天","text":"1185. 一周中的第几天层 难度: easy 原始链接: https://leetcode.cn/problems/day-of-the-week 标签: 模拟 解法一: 按年份一次计算go123456789101112131415161718192021222324func dayOfTheWeek(day int, month int, year int) string { daySum := 0 for i := 1970; i &lt; year; i++ { if isLeep(i) { daySum += 366 } else { daySum += 365 } } months := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} for i := 1; i &lt; month; i++ { daySum += months[i - 1] } if month &gt; 2 &amp;&amp; isLeep(year) { daySum++ } daySum += day days := []string{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;} return days[(daySum + 3) % 7]}func isLeep(year int) bool { return (year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0))} 解法二: 日期工具类java1234567class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] weeks = {&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; LocalDate date = LocalDate.of(year, month, day); return weeks[date.getDayOfWeek().getValue() - 1]; }}","link":"/leetcode/2023/12/day-of-the-week/index.html"},{"title":"1154. 一年中的第几天","text":"1154. 一年中的第几天 难度: easy 原始链接: https://leetcode.cn/problems/day-of-the-year 标签: 直接计算 解法一: 直接计算go123456789101112131415161718func dayOfYear(date string) int { year, _ := strconv.Atoi(date[:4]) month, _ := strconv.Atoi(date[5:7]) day, _ := strconv.Atoi(date[8:]) months := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} daySum := 0 for i := 1; i &lt; month; i++ { daySum += months[i - 1] } if month &gt; 2 &amp;&amp; isLeep(year) { daySum++ } return daySum + day}func isLeep(year int) bool { return (year % 400 == 0) || ((year % 4 == 0) &amp;&amp; (year % 100 != 0))}","link":"/leetcode/2023/12/day-of-the-year/index.html"},{"title":"2660. 保龄球游戏的获胜者","text":"2660. 保龄球游戏的获胜者 难度: easy 原始链接: https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game 标签: 模拟 解法一: 模拟go1234567891011121314151617181920212223242526func isWinner(player1 []int, player2 []int) int { player1Score := calcScore(player1) player2Score := calcScore(player2) if player1Score == player2Score { return 0 } else if player1Score &gt; player2Score { return 1 } return 2}func calcScore(player []int) int { sum := 0 counter := 0 for _, score := range player { sum += score if counter &gt; 0 { counter-- sum += score } if score == 10 { counter = 2 } } return sum}","link":"/leetcode/2023/12/determine-the-winner-of-a-bowling-game/index.html"},{"title":"1901. 寻找峰值 II","text":"1901. 寻找峰值 II 难度: medium 原始链接: https://leetcode.cn/problems/find-a-peak-element-ii 标签: 二分查找 解法一: 暴力go123456789101112131415func findPeakGrid(mat [][]int) []int { m := len(mat) n := len(mat[0]) for r := 0; r &lt; m; r++ { for c := 0; c &lt; n; c++ { if (r == 0 || mat[r][c] &gt; mat[r - 1][c]) &amp;&amp; (r == m - 1 || mat[r][c] &gt; mat[r + 1][c]) &amp;&amp; (c == 0 || mat[r][c] &gt; mat[r][c - 1]) &amp;&amp; (c == n - 1 || mat[r][c] &gt; mat[r][c + 1]) { return []int{r, c} } } } return []int{}} 解法二: 二分查找go12345678910111213141516171819202122232425func findPeakGrid(mat [][]int) []int { m := len(mat) left := 0 right := m - 1 for left &lt; right { mid := ((right - left) &gt;&gt; 1) + left i := maxIndex(mat[mid]) if mat[mid][i] &lt; mat[mid + 1][i] { left = mid + 1 } else { right = mid } } return []int{left, maxIndex(mat[left])}}func maxIndex(nums []int) int { ans := 0 for i, num := range nums { if nums[ans] &lt; num { ans = i } } return ans}","link":"/leetcode/2023/12/find-a-peak-element-ii/index.html"},{"title":"162. 寻找峰值","text":"162. 寻找峰值 难度: medium 原始链接: https://leetcode.cn/problems/find-peak-element 标签: 二分查找 解法一: 半分查找go12345678910111213func findPeakElement(nums []int) int { left := 0 right := len(nums) - 1 for left &lt; right { mid := ((right - left) &gt;&gt; 1) + left if nums[mid] &lt; nums[mid + 1] { left = mid + 1 } else { right = mid } } return left}","link":"/leetcode/2023/12/find-peak-element/index.html"},{"title":"2661. 找出叠涂元素","text":"2661. 找出叠涂元素 难度: medium 原始链接: https://leetcode.cn/problems/first-completely-painted-row-or-column 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425262728func firstCompleteIndex(arr []int, mat [][]int) int { m := len(mat) n := len(mat[0]) type point struct { x int y int } hash := make([]point, m * n + 1) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { hash[mat[i][j]] = point{ x: i, y: j, } } } rows := make([]int, m) cols := make([]int, n) for i, num := range arr { r, c := hash[num].x, hash[num].y rows[r]++ cols[c]++ if rows[r] == n || cols[c] == m { return i } } return -1}","link":"/leetcode/2023/12/first-completely-painted-row-or-column/index.html"},{"title":"2697. 字典序最小回文串","text":"2697. 字典序最小回文串 难度: easy 原始链接: https://leetcode.cn/problems/lexicographically-smallest-palindrome 标签: 双指针 解法一: go 双指针go123456789101112131415func makeSmallestPalindrome(s string) string { bytes := []byte(s) left := 0 right := len(s) - 1 for left &lt; right { if bytes[left] &lt;= bytes[right] { bytes[right] = bytes[left] } else { bytes[left] = bytes[right] } left++ right-- } return string(bytes)} 解法二: java 一行代码java1234567class Solution { public String makeSmallestPalindrome(String s) { return IntStream.range(0, s.length()) .mapToObj(i -&gt; String.valueOf((char) Math.min(s.charAt(i), s.charAt(s.length() - i - 1)))) .collect(Collectors.joining()); }}","link":"/leetcode/2023/12/lexicographically-smallest-palindrome/index.html"},{"title":"2008. 出租车的最大盈利","text":"2008. 出租车的最大盈利 难度: medium 原始链接: https://leetcode.cn/problems/maximum-earnings-from-taxi 标签: 二分查找 解法一: 二分查找go123456789101112131415161718192021222324252627func maxTaxiEarnings(n int, rides [][]int) int64 { sort.Slice(rides, func (i, j int) bool { return rides[i][1] &lt; rides[j][1] }) dp := make([]int64, len(rides) + 1) for i, ride := range rides { start := ride[0] end := ride[1] tip := ride[2] j := halfSearch(rides, i, start) dp[i + 1] = max(dp[i], dp[j] + int64(end - start + tip)) } return dp[len(rides)]}func halfSearch(rides [][]int, right, target int) int { left := 0 for left &lt;= right { mid := ((right - left + 1) &gt;&gt; 1) + left if rides[mid][1] &lt;= target { left = mid + 1 } else { right = mid - 1 } } return left}","link":"/leetcode/2023/12/maximum-earnings-from-taxi/index.html"},{"title":"1423. 可获得的最大点数","text":"1423. 可获得的最大点数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards 标签: 滑动窗口 解法一: 正向计算go1234567891011121314151617181920212223242526func maxScore(cardPoints []int, k int) int { left := 0 sum := 0 for left &lt; k { sum += cardPoints[left] left++ } left-- right := len(cardPoints) - 1 ans := sum for i := 0; i &lt; k; i++ { sum -= cardPoints[left] sum += cardPoints[right] left-- right-- ans = max(ans, sum) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2} 解法二: 反向计算go123456789101112131415161718192021222324func maxScore(cardPoints []int, k int) int { allSum := 0 sum := 0 n := len(cardPoints) m := n - k for i := 0; i &lt; m; i++ { allSum += cardPoints[i] sum += cardPoints[i] } curMin := sum for i := m; i &lt; n; i++ { sum += cardPoints[i] - cardPoints[i - m] curMin = min(curMin, sum) allSum += cardPoints[i] } return allSum - curMin}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/12/maximum-points-you-can-obtain-from-cards/index.html"},{"title":"746. 使用最小花费爬楼梯","text":"746. 使用最小花费爬楼梯 难度: easy 原始链接: https://leetcode.cn/problems/min-cost-climbing-stairs 标签: 动态规划 解法一: 动态规划: O(n) 空间复杂度go1234567891011121314151617func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n) dp[0] = cost[0] dp[1] = cost[1] for i := 2; i &lt; n; i++ { dp[i] = cost[i] + min(dp[i - 1], dp[i - 2]) } return min(dp[n - 2], dp[n - 1])}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2} 解法二: 动态规划: O(1) 空间复杂度go12345678910111213141516func minCostClimbingStairs(cost []int) int { n := len(cost) cost1 := cost[0] cost2 := cost[1] for i := 2; i &lt; n; i++ { cost1, cost2 = cost2, cost[i] + min(cost1, cost2) } return min(cost1, cost2)}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2023/12/min-cost-climbing-stairs/index.html"},{"title":"2477. 到达首都的最少油耗","text":"2477. 到达首都的最少油耗 难度: medium 原始链接: https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital 标签: 贪心, 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223func minimumFuelCost(roads [][]int, seats int) int64 { n := len(roads) trees := make([][]int, n + 1) for _, road := range roads { trees[road[0]] = append(trees[road[0]], road[1]) trees[road[1]] = append(trees[road[1]], road[0]) } var ans int64 = 0 var dfs func (son, parent int) int dfs = func (son, parent int) int { count := 0 for _, tree := range trees[son] { if tree != parent { curCount := dfs(tree, son) + 1 count += curCount ans += int64((curCount + seats - 1) / seats) } } return count } dfs(0, -1) return ans}","link":"/leetcode/2023/12/minimum-fuel-cost-to-report-to-the-capital/index.html"},{"title":"1954. 收集足够苹果的最小花园周长","text":"1954. 收集足够苹果的最小花园周长 难度: medium 原始链接: https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples 标签: 数学 解法一: 数学go123456789func minimumPerimeter(neededApples int64) int64 { var d int64 var sum int64 for sum &lt; neededApples { d++ sum += 12 * d * d } return 8 * d}","link":"/leetcode/2023/12/minimum-garden-perimeter-to-collect-enough-apples/index.html"},{"title":"2454. 下一个更大元素 IV","text":"2454. 下一个更大元素 IV 难度: hard 原始链接: https://leetcode.cn/problems/next-greater-element-iv 标签: 单调栈 解法一: 单调栈go12345678910111213141516171819202122func secondGreaterElement(nums []int) []int { length := len(nums) ans := make([]int, length) for i := 0; i &lt; length; i++ { ans[i] = -1 } list1 := []int{} list2 := []int{} for i, num := range nums { for len(list2) &gt; 0 &amp;&amp; nums[list2[len(list2) - 1]] &lt; num { ans[list2[len(list2) - 1]] = num list2 = list2[:len(list2) - 1] } pos := len(list1) - 1 for pos &gt;= 0 &amp;&amp; nums[list1[pos]] &lt; num { pos-- } list2 = append(list2, list1[pos + 1:]...) list1 = append(list1[:pos + 1], i) } return ans} 其他 “下一个更大元素”496. 下一个更大元素 Igo12345678910111213141516171819202122func nextGreaterElement(nums1 []int, nums2 []int) []int { stack := []int{} length2 := len(nums2) moreLargeArr := make(map[int]int, length2) for i := length2 - 1; i &gt;= 0; i-- { for len(stack) &gt; 0 &amp;&amp; stack[len(stack) - 1] &lt; nums2[i] { stack = stack[:len(stack) - 1] } if len(stack) == 0 { moreLargeArr[nums2[i]] = -1 } else { moreLargeArr[nums2[i]] = stack[len(stack) - 1] } stack = append(stack, nums2[i]) } length1 := len(nums1) ans := make([]int, length1) for i, num := range nums1 { ans[i] = moreLargeArr[num] } return ans} 503. 下一个更大元素 IIgo1234567891011121314151617func nextGreaterElements(nums []int) []int { stack := []int{} n := len(nums) doubleN := n &lt;&lt; 1 ans := make([]int, n) for i := 0; i &lt; n; i++ { ans[i] = -1 } for i := 0; i &lt; doubleN; i++ { for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack) - 1]] &lt; nums[i % n] { ans[stack[len(stack) - 1]] = nums[i % n] stack = stack[:len(stack) - 1] } stack = append(stack, i % n) } return ans} 556. 下一个更大元素 IIIgo1234567891011121314151617181920212223242526272829303132333435363738394041func nextGreaterElement(n int) int { nums := toArr(n) length := len(nums) for i := len(nums) - 2; i &gt;= 0; i-- { if nums[i] &lt; nums[i + 1] { sort.Ints(nums[i + 1:]) for j := i + 1; j &lt; length; j++ { if nums[i] &lt; nums[j] { nums[i], nums[j] = nums[j], nums[i] break } } maxMinNum := toNum(nums) if maxMinNum &lt;= math.MaxInt32 { return maxMinNum } break } } return -1}func toArr(n int) []int { arr := []int{} for n != 0 { arr = append(arr, n % 10) n /= 10 } for i, j := 0, len(arr) - 1; i &lt; j; i, j = i + 1, j - 1 { arr[i], arr[j] = arr[j], arr[i] } return arr}func toNum(nums []int) int { num := 0 for i := 0; i &lt; len(nums); i++ { num = num * 10 + nums[i] } return num}","link":"/leetcode/2023/12/next-greater-element-iv/index.html"},{"title":"2048. 下一个更大的数值平衡数","text":"2048. 下一个更大的数值平衡数 难度: medium 原始链接: https://leetcode.cn/problems/next-greater-numerically-balanced-number 标签: 枚举 解法一: 枚举go1234567891011121314151617181920212223242526func nextBeautifulNumber(n int) int { for i := n + 1; ; i++ { if isBeautifulNumber(i) { return i } } return -1}func isBeautifulNumber(num int) bool { countMark := make([]int, 8) for num != 0 { div := num % 10 if div &gt;= 8 || countMark[div] &gt;= div { return false } countMark[div]++ num /= 10 } for i, count := range countMark { if count &gt; 0 &amp;&amp; count != i { return false } } return true}","link":"/leetcode/2023/12/next-greater-numerically-balanced-number/index.html"},{"title":"1276. 不浪费原料的汉堡制作方案","text":"1276. 不浪费原料的汉堡制作方案 难度: medium 原始链接: https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients 标签: 二分查找 解法一: 二分查找go12345678910111213141516171819func numOfBurgers(tomatoSlices int, cheeseSlices int) []int { if (tomatoSlices &amp; 1) == 1 || (tomatoSlices &gt;&gt; 1) &lt; cheeseSlices || (tomatoSlices &gt;&gt; 2) &gt; cheeseSlices { return []int{} } left := 0 right := tomatoSlices &gt;&gt; 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left target := (mid &lt;&lt; 1) + ((cheeseSlices - mid) &lt;&lt; 2) if target == tomatoSlices { return []int{cheeseSlices - mid, mid} } else if target &gt; tomatoSlices { left = mid + 1 } else { right = mid - 1 } } return []int{}}","link":"/leetcode/2023/12/number-of-burgers-with-no-waste-of-ingredients/index.html"},{"title":"1631. 最小体力消耗路径","text":"1631. 最小体力消耗路径 难度: medium 原始链接: https://leetcode.cn/problems/path-with-minimum-effort 标签: 二分查找, 并查集 解法一: 二分查找go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func minimumEffortPath(heights [][]int) int { m := len(heights) n := len(heights[0]) directions := [][]int{ {0, -1}, {1, 0}, {0, 1}, {-1, 0}, } var dfs func (heights [][]int, visit []bool, r, c, limit int) bool dfs = func (heights [][]int, visit []bool, r, c, limit int) bool { if visit[r * n + c] { return false } if r == m - 1 &amp;&amp; c == n - 1 { return true } visit[r * n + c] = true ans := false for _, direction := range directions { newR := r + direction[0] newC := c + direction[1] if newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n &amp;&amp; abs(heights[newR][newC] - heights[r][c]) &lt;= limit { ans = ans || dfs(heights, visit, newR, newC, limit) } } return ans } left := 0 right := 1000000 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if dfs(heights, make([]bool, m * n), 0, 0, mid) { right = mid - 1 } else { left = mid + 1 } } return left}func abs(num int) int { if num &gt;= 0 { return num } return -num} 解法二: 并查集go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475func minimumEffortPath(heights [][]int) int { m := len(heights) n := len(heights[0]) edges := [][]int{} for r, height := range heights { for c, num := range height { if c + 1 &lt; n { edges = append(edges, []int{ abs(heights[r][c + 1] - num), r * n + c, r * n + c + 1, }) } if r + 1 &lt; m { edges = append(edges, []int{ abs(heights[r + 1][c] - num), r * n + c, (r + 1) * n + c, }) } } } sort.Slice(edges, func(i, j int) bool { return edges[i][0] &lt;= edges[j][0] }) unionFind := newConstruct(m * n) for _, edge := range edges { unionFind.union(edge[1], edge[2]) if unionFind.find(0) == unionFind.find(m * n - 1) { return edge[0] } } return 0}type UnionFind struct { parents []int}func newConstruct(n int) *UnionFind { parents := make([]int, n) for i := 0; i &lt; n; i++ { parents[i] = i } return &amp;UnionFind{ parents: parents, }}func (this *UnionFind) union(num1, num2 int) { parents := this.parents target1 := this.find(num1) target2 := this.find(num2) if target1 == target2 { return } parents[target1] = target2}func (this *UnionFind) find(num int) int { parents := this.parents if parents[num] == num { return num } return this.find(parents[num])}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2023/12/path-with-minimum-effort/index.html"},{"title":"1962. 移除石子使总数最小","text":"1962. 移除石子使总数最小 难度: medium 原始链接: https://leetcode.cn/problems/remove-stones-to-minimize-the-total 标签: 优先队列 解法一: 优先队列java12345678910111213141516class Solution { public int minStoneSum(int[] piles, int k) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); for (int pile : piles) { priorityQueue.offer(pile); } for (int i = 0; i &lt; k; i++) { priorityQueue.offer((priorityQueue.poll() + 1) &gt;&gt; 1); } int sum = 0; for (Integer num : priorityQueue) { sum += num; } return sum; }}","link":"/leetcode/2023/12/remove-stones-to-minimize-the-total/index.html"},{"title":"1466. 重新规划路线","text":"1466. 重新规划路线 难度: medium 原始链接: https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero 标签: dfs 解法一: dfsgo123456789101112131415161718192021222324252627282930func minReorder(n int, connections [][]int) int { roads := make([][]int, n) for _, connection := range connections { roads[connection[0]] = append(roads[connection[0]], -connection[1]) roads[connection[1]] = append(roads[connection[1]], connection[0]) } ans := 0 var dfs func (start, parent int) dfs = func (start, parent int) { for _, road := range roads[start] { if abs(road) == parent { continue } if road &lt; 0 { ans++ road = -road } dfs(road, start) } } dfs(0, 0) return ans}func abs(num int) int { if num &gt;= 0 { return num } return -num} java12345678910111213141516171819202122232425class Solution { public int minReorder(int n, int[][] connections) { List&lt;int[]&gt;[] roads = new ArrayList[n]; for (int i = 0; i &lt; n; i++) { roads[i] = new ArrayList&lt;&gt;(); } for (int[] connection : connections) { roads[connection[0]].add(new int[]{connection[1], 1}); roads[connection[1]].add(new int[]{connection[0], 0}); } return this.dfs(0, -1, roads); } private int dfs(int start, int parent, List&lt;int[]&gt;[] roads) { int ans = 0; for (int[] road : roads[start]) { if (road[0] == parent) { continue; } ans += road[1] + this.dfs(road[0], start, roads); } return ans; }}","link":"/leetcode/2023/12/reorder-routes-to-make-all-paths-lead-to-the-city-zero/index.html"},{"title":"2415. 反转二叉树的奇数层","text":"2415. 反转二叉树的奇数层 难度: medium 原始链接: https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func reverseOddLevels(root *TreeNode) *TreeNode { if root == nil { return root } queue := []*TreeNode{root} isOdd := false for len(queue) &gt; 0 { size := len(queue) for i := 0; i &lt; size; i++ { if queue[i].Left != nil { queue = append(queue, queue[i].Left, queue[i].Right) } } if isOdd { left := 0 right := size - 1 for left &lt; right { queue[left].Val, queue[right].Val = queue[right].Val, queue[left].Val left++ right-- } } isOdd = !isOdd queue = queue[size:] } return root} 解法二: 深度优先遍历go1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func reverseOddLevels(root *TreeNode) *TreeNode { var dfs func (node1, node2 *TreeNode, isOdd bool) dfs = func (node1, node2 *TreeNode, isOdd bool) { if node1 == nil || node2 == nil { return } if isOdd { node1.Val, node2.Val = node2.Val, node1.Val } dfs(node1.Left, node2.Right, !isOdd) dfs(node1.Right, node2.Left, !isOdd) } dfs(root.Left, root.Right, true) return root}","link":"/leetcode/2023/12/reverse-odd-levels-of-binary-tree/index.html"},{"title":"2182. 构造限制重复的字符串","text":"2182. 构造限制重复的字符串 难度: medium 原始链接: https://leetcode.cn/problems/construct-string-with-repeat-limit 标签: 贪心, 大根堆 解法一: 贪心, 大根堆java1234567891011121314151617181920212223242526272829303132333435363738class Solution { public String repeatLimitedString(String s, int repeatLimit) { int n = s.length(); int[] wordCount = new int[26]; for (int i = 0; i &lt; n; i++) { wordCount[s.charAt(i) - 'a']++; } PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr2[1] - arr1[1]); for (int i = 0; i &lt; 26; i++) { if (wordCount[i] &gt; 0) { priorityQueue.offer(new int[] { wordCount[i], i }); } } StringBuffer sb = new StringBuffer(); while (!priorityQueue.isEmpty()) { int[] arr = priorityQueue.poll(); int count = Math.min(arr[0], repeatLimit); char ch = (char) (arr[1] + 'a'); for (int i = 0; i &lt; count; i++) { sb.append(ch); } if (arr[0] &gt; repeatLimit) { if (priorityQueue.isEmpty()) { break; } int[] arr2 = priorityQueue.poll(); sb.append((char) (arr2[1] + 'a')); if (arr2[0] &gt; 1) { arr2[0]--; priorityQueue.offer(arr2); } arr[0] -= repeatLimit; priorityQueue.offer(arr); } } return sb.toString(); }}","link":"/leetcode/2024/01/construct-string-with-repeat-limit/index.html"},{"title":"2085. 统计出现过一次的公共字符串","text":"2085. 统计出现过一次的公共字符串 难度: easy 原始链接: https://leetcode.cn/problems/count-common-words-with-one-occurrence 标签: 哈希 解法一: 双哈希go1234567891011121314151617func countWords(words1 []string, words2 []string) int { hash1 := make(map[string]int, len(words1)) hash2 := make(map[string]int, len(words2)) for _, word := range words1 { hash1[word]++ } for _, word := range words2 { hash2[word]++ } ans := 0 for word, count := range hash1 { if count == 1 &amp;&amp; hash2[word] == 1 { ans++ } } return ans} 解法二: 单哈希go12345678910111213141516171819func countWords(words1 []string, words2 []string) int { hash := make(map[string]int, len(words1)) for _, word := range words1 { hash[word]++ } ans := 0 for _, word := range words2 { if count, exists := hash[word]; exists { if count == 1 { ans++ hash[word] = -1 } else if count == -1 { ans-- delete(hash, word) } } } return ans}","link":"/leetcode/2024/01/count-common-words-with-one-occurrence/index.html"},{"title":"2707. 字符串中的额外字符","text":"2707. 字符串中的额外字符 难度: medium 原始链接: https://leetcode.cn/problems/extra-characters-in-a-string 标签: 动态规划, 前缀树 解法一: 动态规划java12345678910111213141516171819202122232425262728293031323334class Solution { public int minExtraChar(String s, String[] dictionary) { int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 1; for (String word : dictionary) { if (this.isSameFromLast(s, i, word)) { dp[i + 1] = Math.min(dp[i + 1], dp[i - word.length() + 1]); } } } return dp[n]; } private boolean isSameFromLast(String str, int endIndex, String subStr) { int n1 = str.length(); int n2 = subStr.length(); if (n2 &gt; endIndex + 1) { return false; } int i = endIndex; int j = n2 - 1; while (j &gt;= 0) { if (str.charAt(i) != subStr.charAt(j)) { return false; } i--; j--; } return true; }} 解法二: 前缀树java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { public static class Trie { private Trie[] tries; private boolean isEnd; public Trie() { this.tries = new Trie[26]; this.isEnd = false; } public void insert(String word) { int n = word.length(); Trie trie = this; for (int i = 0; i &lt; n; i++) { int j = word.charAt(i) - 'a'; if (trie.tries[j] == null) { trie.tries[j] = new Trie(); } trie = trie.tries[j]; } trie.isEnd = true; } public Trie track(char ch) { return tries[ch - 'a']; } public boolean isEnd() { return isEnd; } } public int minExtraChar(String s, String[] dictionary) { Trie root = new Trie(); for (String word : dictionary) { StringBuilder sb = new StringBuilder(word); root.insert(sb.reverse().toString()); } int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 1; Trie trie = root; for (int j = i; j &gt;= 0; j--) { trie = trie.track(s.charAt(j)); if (trie == null) { break; } if (trie.isEnd()) { dp[i + 1] = Math.min(dp[i + 1], dp[j]); } } } return dp[n]; }}","link":"/leetcode/2024/01/extra-characters-in-a-string/index.html"},{"title":"2744. 最大字符串配对数目","text":"2744. 最大字符串配对数目 难度: easy 原始链接: https://leetcode.cn/problems/find-maximum-number-of-string-pairs 标签: 哈希 解法一: 哈希go123456789101112131415161718192021func maximumNumberOfStringPairs(words []string) int { n := len(words) set := make(map[string]bool, n) ans := 0 for _, word := range words { if set[revertStr(word)] { ans++ } set[word] = true } return ans}func revertStr(str string) string { n := len(str) bytes := make([]byte, n) for i := 0; i &lt; n; i++ { bytes[i] = str[n - i - 1] } return string(bytes)}","link":"/leetcode/2024/01/find-maximum-number-of-string-pairs/index.html"},{"title":"2670. 找出不同元素数目差数组","text":"2670. 找出不同元素数目差数组 难度: easy 原始链接: https://leetcode.cn/problems/find-the-distinct-difference-array 标签: 哈希 解法一: 哈希go123456789101112131415161718func distinctDifferenceArray(nums []int) []int { leftCount := make(map[int]int) rightCount := make(map[int]int) for _, num := range nums { rightCount[num]++ } n := len(nums) ans := make([]int, n) for i, num := range nums { rightCount[num]-- if rightCount[num] == 0 { delete(rightCount, num) } leftCount[num]++ ans[i] = len(leftCount) - len(rightCount) } return ans}","link":"/leetcode/2024/01/find-the-distinct-difference-array/index.html"},{"title":"2807. 在链表中插入最大公约数","text":"2807. 在链表中插入最大公约数 难度: medium 原始链接: https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list 标签: 辗转相除法 解法一: 辗转相除法go1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func insertGreatestCommonDivisors(head *ListNode) *ListNode { first := head second := head.Next for second != nil { first.Next = &amp;ListNode{ Val: gcd(first.Val, second.Val), Next: second, } first, second = second, second.Next } return head}func gcd(num1, num2 int) int { for num2 != 0 { num1, num2 = num2, num1 % num2 } return num1}","link":"/leetcode/2024/01/insert-greatest-common-divisors-in-linked-list/index.html"},{"title":"2765. 最长交替子数组","text":"2765. 最长交替子数组 难度: easy 原始链接: https://leetcode.cn/problems/longest-alternating-subarray 标签: 双重循环 解法一: 双重循环go12345678910111213141516171819202122232425262728293031323334func alternatingSubarray(nums []int) int { n := len(nums) ans := -1 for i := 0; i &lt; n; i++ { ans = max(ans, maxAlternating(nums[i:])) } return ans}func maxAlternating(nums []int) int { n := len(nums) if n &lt;= 1 { return -1 } ans := 1 for i := 1; i &lt; n; i++ { if ((i&amp;1) == 0 &amp;&amp; nums[i] != nums[i-2]) || ((i&amp;1) == 1 &amp;&amp; nums[i] != nums[i-1]+1) { break } ans++ } if ans == 1 { return -1 } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/longest-alternating-subarray/index.html"},{"title":"2861. 最大合金数","text":"2861. 最大合金数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-alloys 标签: 二分查找 解法一: 二分查找go123456789101112131415161718192021222324252627282930313233343536373839404142func maxNumberOfAlloys(n int, k int, budget int, composition [][]int, stock []int, cost []int) int { ans := 0 for _, arr := range composition { left := 0 right := 200000000 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if isSuccess(mid, budget, arr, stock, cost) { left = mid } else { right = mid - 1 } } ans = max(ans, left) } return ans}func isSuccess(count, budget int, composition []int, stock []int, cost []int) bool { total := 0 for i, num := range composition { total += max(0, count*num-stock[i]) * cost[i] if total &gt; budget { return false } } return total &lt;= budget}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/maximum-number-of-alloys/index.html"},{"title":"1599. 经营摩天轮的最大利润","text":"1599. 经营摩天轮的最大利润 难度: medium 原始链接: https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel 标签: 模拟 解法一: 模拟go1234567891011121314151617181920212223242526272829func minOperationsMaxProfit(customers []int, boardingCost int, runningCost int) int { peopleSum := 0 curPeople := 0 i := 0 n := len(customers) curCost := 0 maxCost := 0 ans := -1 for i &lt; n || curPeople &lt; peopleSum { if i &lt; n { peopleSum += customers[i] } curPeople += min(4, peopleSum - curPeople) curCost = curPeople * boardingCost - (i + 1) * runningCost if maxCost &lt; curCost { maxCost = curCost ans = i + 1 } i++ } return ans}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/maximum-profit-of-operating-a-centennial-wheel/index.html"},{"title":"2397. 被列覆盖的最多行数","text":"2397. 被列覆盖的最多行数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-rows-covered-by-columns 标签: 回溯, 枚举 解法一: 回溯, 枚举java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int maximumRows(int[][] matrix, int numSelect) { List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); this.collectAllCombinations(0, numSelect, matrix[0].length, 0, 0, nums); List&lt;Integer&gt; rowBits = this.arrayRow2Bit(matrix); int ans = 0; for (Integer num : nums) { int count = 0; for (Integer rowBit : rowBits) { if ((num | rowBit) == num) { count++; } } ans = Math.max(ans, count); } return ans; } private List&lt;Integer&gt; arrayRow2Bit(int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int m = matrix.length; int n = matrix[0].length; for (int i = 0; i &lt; m; i++) { int num = 0; for (int j = 0; j &lt; n; j++) { if (matrix[i][j] == 1) { num |= 1 &lt;&lt; j; } } ans.add(num); } return ans; } private void collectAllCombinations(int start, int size, int n, int bitNum, int num, List&lt;Integer&gt; nums) { if (bitNum == size) { nums.add(num); return; } for (int i = start; i &lt; n; i++) { int numCopy = num; bitNum++; num |= 1 &lt;&lt; i; this.collectAllCombinations(i + 1, size, n, bitNum, num, nums); bitNum--; num = numCopy; } }}","link":"/leetcode/2024/01/maximum-rows-covered-by-columns/index.html"},{"title":"670. 最大交换","text":"670. 最大交换 难度: medium 原始链接: https://leetcode.cn/problems/maximum-swap 标签: 一次遍历 解法一: 一次遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243func maximumSwap(num int) int { numArr := toNumArr(num) n := len(numArr) maxIndex := n - 1 left := -1 right := -1 for i := n - 1; i &gt;= 0; i-- { if numArr[i] &gt; numArr[maxIndex] { maxIndex = i } else if numArr[i] &lt; numArr[maxIndex] { left = i right = maxIndex } } if left != -1 { numArr[left], numArr[right] = numArr[right], numArr[left] return toNum(numArr) } return num}func toNumArr(num int) []int { numArr := []int{} for num != 0 { numArr = append(numArr, num%10) num /= 10 } left, right := 0, len(numArr)-1 for left &lt; right { numArr[left], numArr[right] = numArr[right], numArr[left] left++ right-- } return numArr}func toNum(numArr []int) int { ans := 0 for _, num := range numArr { ans = ans*10 + num } return ans}","link":"/leetcode/2024/01/maximum-swap/index.html"},{"title":"2645. 构造有效字符串的最少插入数","text":"2645. 构造有效字符串的最少插入数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-additions-to-make-valid-string 标签: 动态规划, 模拟 解法一: 模拟go123456789101112131415func addMinimum(word string) int { insertList := [][]int{ {2, 0, 1}, {1, 2, 0}, {0, 1, 2}, } word += &quot;a&quot; pre := 'c' ans := 0 for _, ch := range word { ans += insertList[pre - 'a'][ch - 'a'] pre = ch } return ans} 解法二: 动态规划java12345678910111213class Solution { public int addMinimum(String word) { int n = word.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = dp[i] + 2; if (i &gt; 0 &amp;&amp; word.charAt(i) &gt; word.charAt(i - 1)) { dp[i + 1] = dp[i] - 1; } } return dp[n]; }} 解法三: 计数组数java123456789101112class Solution { public int addMinimum(String word) { int n = word.length(); int count = 1; for (int i = 1; i &lt; n; i++) { if (word.charAt(i) &lt;= word.charAt(i - 1)) { count++; } } return count * 3 - n; }}","link":"/leetcode/2024/01/minimum-additions-to-make-valid-string/index.html"},{"title":"2808. 使循环数组所有元素相等的最少秒数","text":"2808. 使循环数组所有元素相等的最少秒数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425262728293031func minimumSeconds(nums []int) int { listMap := make(map[int][]int) for i, num := range nums { listMap[num] = append(listMap[num], i) } n := len(nums) ans := n for _, list := range listMap { n2 := len(list) distance := list[0] + n - list[n2-1] for i := 1; i &lt; n2; i++ { distance = max(distance, list[i]-list[i-1]) } ans = min(ans, distance&gt;&gt;1) } return ans}func max(num1, num2 int) int { if num1 &gt;= num2 { return num1 } return num2}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/minimum-seconds-to-equalize-a-circular-array/index.html"},{"title":"2696. 删除子串后的字符串最小长度","text":"2696. 删除子串后的字符串最小长度 难度: easy 原始链接: https://leetcode.cn/problems/minimum-string-length-after-removing-substrings 标签: 栈 解法一: 栈go123456789101112func minLength(s string) int { stack := []byte{} n := len(s) for i := 0; i &lt; n; i++ { if len(stack) &gt; 0 &amp;&amp; (s[i] == 'B' &amp;&amp; stack[len(stack) - 1] == 'A' || s[i] == 'D' &amp;&amp; stack[len(stack) - 1] == 'C') { stack = stack[:len(stack) - 1] } else { stack = append(stack, s[i]) } } return len(stack)}","link":"/leetcode/2024/01/minimum-string-length-after-removing-substrings/index.html"},{"title":"447. 回旋镖的数量","text":"447. 回旋镖的数量 难度: medium 原始链接: https://leetcode.cn/problems/number-of-boomerangs 标签: 哈希 解法一: 哈希go123456789101112131415func numberOfBoomerangs(points [][]int) int { ans := 0 for _, point1 := range points { distanceHash := make(map[int]int) for _, point2 := range points { distanceHash[(point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1])]++ } for _, count := range distanceHash { if count &gt; 1 { ans += count * (count - 1) } } } return ans} java123456789101112131415161718class Solution { public int numberOfBoomerangs(int[][] points) { int ans = 0; Map&lt;Integer, Integer&gt; distanceHash = new HashMap&lt;&gt;(); for (int[] point1 : points) { distanceHash.clear(); for (int[] point2 : points) { int distance = (point2[0] - point1[0]) * (point2[0] - point1[0]) + (point2[1] - point1[1]) * (point2[1] - point1[1]); distanceHash.put(distance, distanceHash.getOrDefault(distance, 0) + 1); } for (Map.Entry&lt;Integer, Integer&gt; entry : distanceHash.entrySet()) { int count = entry.getValue(); ans += (count - 1) * count; } } return ans; }}","link":"/leetcode/2024/01/number-of-boomerangs/index.html"},{"title":"383. 赎金信","text":"383. 赎金信 难度: easy 原始链接: https://leetcode.cn/problems/ransom-note 标签: 哈希 解法一: 哈希go12345678910111213func canConstruct(ransomNote string, magazine string) bool { countMap := make([]int, 26) for _, ch := range magazine { countMap[ch - 'a']++ } for _, ch := range ransomNote { if countMap[ch - 'a'] == 0 { return false } countMap[ch - 'a']-- } return true}","link":"/leetcode/2024/01/ransom-note/index.html"},{"title":"82. 删除排序链表中的重复元素 II","text":"82. 删除排序链表中的重复元素 II 难度: medium 原始链接: https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii 标签: 一次遍历, 递归 解法一: 一次遍历go12345678910111213141516171819202122232425/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1000, Next: head, } cur := p for cur != nil { if cur.Next != nil &amp;&amp; cur.Next.Next != nil &amp;&amp; cur.Next.Val == cur.Next.Next.Val { curVal := cur.Next.Val for cur.Next != nil &amp;&amp; curVal == cur.Next.Val { cur.Next = cur.Next.Next } } else { cur = cur.Next } } return p.Next} 解法二: 递归go123456789101112131415161718192021/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } if head.Val == head.Next.Val { next := head.Next for next != nil &amp;&amp; head.Val == next.Val { next = next.Next } return deleteDuplicates(next) } head.Next = deleteDuplicates(head.Next) return head}","link":"/leetcode/2024/01/remove-duplicates-from-sorted-list-ii/index.html"},{"title":"83. 删除排序链表中的重复元素","text":"83. 删除排序链表中的重复元素 难度: easy 原始链接: https://leetcode.cn/problems/remove-duplicates-from-sorted-list 标签: 模拟 解法一: 模拟go12345678910111213141516171819202122232425/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func deleteDuplicates(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1000, Next: nil, } pre := p cur := head for cur != nil { if pre.Val != cur.Val { pre.Next = cur pre, cur = pre.Next, cur.Next pre.Next = nil } else { cur = cur.Next } } return p.Next}","link":"/leetcode/2024/01/remove-duplicates-from-sorted-list/index.html"},{"title":"2487. 从链表中移除节点","text":"2487. 从链表中移除节点 难度: medium 原始链接: https://leetcode.cn/problems/remove-nodes-from-linked-list 标签: 递归, 单调栈, 反转链表 解法一: 递归go123456789101112131415161718/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { if head == nil { return nil } next := removeNodes(head.Next) if next == nil || head.Val &gt;= next.Val { head.Next = next return head } return next} 解法二: 单调栈go12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { stack := []*ListNode{} node := head for node != nil { stack = append(stack, node) node = node.Next } pre := -1 p := &amp;ListNode{ Val: -1, Next: nil, } for len(stack) &gt; 0 { node = stack[len(stack) - 1] if node.Val &gt;= pre { pre = node.Val tmp := p.Next p.Next = node p.Next.Next = tmp } stack = stack[:len(stack) - 1] } return p.Next} 解法三: 反转链表go123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNodes(head *ListNode) *ListNode { revertHead := revertLinkNode(head) node := revertHead p := &amp;ListNode{ Val: -1, Next: nil, } pre := p for node != nil { if pre.Val &lt;= node.Val { pre.Next = node node = node.Next pre = pre.Next pre.Next = nil } else { node = node.Next } } return revertLinkNode(p.Next)}func revertLinkNode(head *ListNode) *ListNode { p := &amp;ListNode{ Val: -1, Next: nil, } node := head for node != nil { tmp := p.Next p.Next = node node = node.Next p.Next.Next = tmp } return p.Next}","link":"/leetcode/2024/01/remove-nodes-from-linked-list/index.html"},{"title":"2171. 拿出最少数目的魔法豆","text":"2171. 拿出最少数目的魔法豆 难度: medium 原始链接: https://leetcode.cn/problems/removing-minimum-number-of-magic-beans 标签: 排序, 前缀和 解法一: 排序, 前缀和go1234567891011func minimumRemoval(beans []int) int64 { sort.Ints(beans) var sum int64 = 0 var maxVal int64 = 0 n := len(beans) for i, bean := range beans { sum += int64(bean) maxVal = max(maxVal, int64(n - i) * int64(bean)) } return sum - maxVal}","link":"/leetcode/2024/01/removing-minimum-number-of-magic-beans/index.html"},{"title":"2788. 按分隔符拆分字符串","text":"2788. 按分隔符拆分字符串 难度: easy 原始链接: https://leetcode.cn/problems/split-strings-by-separator 标签: 模拟 解法一: 模拟java12345678910import java.util.regex.Pattern;class Solution { public List&lt;String&gt; splitWordsBySeparator(List&lt;String&gt; words, char separator) { return words.stream() .flatMap(word -&gt; Arrays.stream(word.split(Pattern.quote(String.valueOf(separator))))) .filter(word -&gt; !word.isEmpty()) .collect(Collectors.toList()); }}","link":"/leetcode/2024/01/split-strings-by-separator/index.html"},{"title":"2859. 计算 K 置位下标对应元素的和","text":"2859. 计算 K 置位下标对应元素的和 难度: easy 原始链接: https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits 标签: 位运算 解法一: 位运算go123456789101112131415161718func sumIndicesWithKSetBits(nums []int, k int) int { ans := 0 for i, num := range nums { if countBit(i) == k { ans += num } } return ans}func countBit(num int) int { count := 0 for num != 0 { count++ num &amp;= num - 1 } return count}","link":"/leetcode/2024/01/sum-of-values-at-indices-with-k-set-bits/index.html"},{"title":"365. 水壶问题","text":"365. 水壶问题 难度: medium 原始链接: https://leetcode.cn/problems/water-and-jug-problem 标签: 栈 解法一: 递归go1234567891011121314151617181920212223242526func canMeasureWater(jug1Capacity int, jug2Capacity int, targetCapacity int) bool { set := make(map[string]bool) var dfs func(x, y int) bool dfs = func(x, y int) bool { if x == targetCapacity || y == targetCapacity || x+y == targetCapacity { return true } numStr := strconv.Itoa(x) + &quot;,&quot; + strconv.Itoa(y) if set[numStr] { return false } set[numStr] = true return dfs(jug1Capacity, y) || dfs(0, y) || dfs(x, jug2Capacity) || dfs(x, 0) || dfs(x-min(x, jug2Capacity-y), y+min(x, jug2Capacity-y)) || dfs(x+min(y, jug1Capacity-x), y-min(y, jug1Capacity-x)) } return dfs(0, 0)}func min(num1, num2 int) int { if num1 &lt;= num2 { return num1 } return num2}","link":"/leetcode/2024/01/water-and-jug-problem/index.html"},{"title":"94. 二叉树的中序遍历","text":"二叉树的中序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-inorder-traversal 标签: 中序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func inorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) ans = append(ans, node.Val) dfs(node.Right) } dfs(root) return ans} 解法二: Morris 中序遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func inorderTraversal(root *TreeNode) []int { ans := []int{} node := root for node != nil { if node.Left != nil { predecessor := node.Left for predecessor.Right != nil &amp;&amp; predecessor.Right != node { predecessor = predecessor.Right } if predecessor.Right == nil { predecessor.Right = node node = node.Left } else { ans = append(ans, node.Val) node = node.Right predecessor.Right = nil } } else { ans = append(ans, node.Val) node = node.Right } } return ans}","link":"/leetcode/2024/02/binary-tree-inorder-traversal/index.html"},{"title":"107. 二叉树的层序遍历 II","text":"二叉树的层序遍历 II 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-level-order-traversal-ii 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrderBottom(root *TreeNode) [][]int { var ans [][]int var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) slices.Reverse(ans) return ans}","link":"/leetcode/2024/02/binary-tree-level-order-traversal-ii/index.html"},{"title":"102. 二叉树的层序遍历","text":"二叉树的层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-level-order-traversal 标签: 层序遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } queue := []*TreeNode{root} var ans [][]int for len(queue) &gt; 0 { size := len(queue) var list []int for i := 0; i &lt; size; i++ { node := queue[i] list = append(list, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] ans = append(ans, list) } return ans} 解法二: 深度优先遍历Go12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrder(root *TreeNode) [][]int { var ans [][]int var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans}","link":"/leetcode/2024/02/binary-tree-level-order-traversal/index.html"},{"title":"145. 二叉树的后序遍历","text":"二叉树的后序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-postorder-traversal 标签: 后序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func postorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } dfs(node.Left) dfs(node.Right) ans = append(ans, node.Val) } dfs(root) return ans}","link":"/leetcode/2024/02/binary-tree-postorder-traversal/index.html"},{"title":"145. 二叉树的前序遍历","text":"二叉树的前序遍历 难度: easy 原始链接: https://leetcode.cn/problems/binary-tree-preorder-traversal 标签: 前序遍历 解法一: 递归go12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func preorderTraversal(root *TreeNode) []int { ans := []int{} var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } ans = append(ans, node.Val) dfs(node.Left) dfs(node.Right) } dfs(root) return ans} 解法二: Morris 遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func preorderTraversal(root *TreeNode) []int { ans := []int{} node := root for node != nil { if node.Left != nil { postNode := node.Left for postNode.Right != nil &amp;&amp; postNode.Right != node { postNode = postNode.Right } if postNode.Right == nil { ans = append(ans, node.Val) postNode.Right = node node = node.Left } else { node = node.Right postNode.Right = nil } } else { ans = append(ans, node.Val) node = node.Right } } return ans}","link":"/leetcode/2024/02/binary-tree-preorder-traversal/index.html"},{"title":"103. 二叉树的锯齿形层序遍历","text":"二叉树的锯齿形层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历go123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func zigzagLevelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } queue := []*TreeNode{root} depth := 0 for len(queue) &gt; 0 { ans = append(ans, []int{}) size := len(queue) for i := 0; i &lt; size; i++ { if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } if (depth &amp; 1) == 0 { ans[depth] = append(ans[depth], queue[i].Val) } else { ans[depth] = append(ans[depth], queue[size-i-1].Val) } } queue = queue[size:] depth++ } return ans} 解法二: 深度优先遍历go1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func zigzagLevelOrder(root *TreeNode) [][]int { ans := [][]int{} var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } if (depth &amp; 1) == 0 { ans[depth] = append(ans[depth], node.Val) } else { // 往切片的头部插入一个元素 ans[depth] = append(ans[depth], -1) copy(ans[depth][1:], ans[depth]) ans[depth][0] = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans}","link":"/leetcode/2024/02/binary-tree-zigzag-level-order-traversal/index.html"},{"title":"2476. 二叉搜索树最近节点查询","text":"二叉搜索树最近节点查询 难度: medium 原始链接: https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree 标签: 中序遍历, 二分查找 解法一: 中序遍历，二分查找go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func closestNodes(root *TreeNode, queries []int) [][]int { list := []int{} dfs(root, &amp;list) ans := make([][]int, len(queries)) for i, query := range queries { ans[i] = []int{halfSearchMax(list, query), halfSearchMin(list, query)} } return ans}func dfs(node *TreeNode, list *[]int) { if node == nil { return } dfs(node.Left, list) *list = append(*list, node.Val) dfs(node.Right, list)}func halfSearchMax(list []int, target int) int { left := 0 right := len(list) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if list[mid] &lt;= target { left = mid + 1 } else { right = mid - 1 } } if right &lt; 0 { return -1 } return list[right]}func halfSearchMin(list []int, target int) int { left := 0 right := len(list) - 1 for left &lt;= right { mid := ((right - left) &gt;&gt; 1) + left if list[mid] &gt;= target { right = mid - 1 } else { left = mid + 1 } } if left &gt;= len(list) { return -1 } return list[left]}","link":"/leetcode/2024/02/closest-nodes-queries-in-a-binary-search-tree/index.html"},{"title":"106. 从中序与后序遍历序列构造二叉树","text":"从中序与后序遍历序列构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal 标签: 分治 解法一: 分治go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func buildTree(inorder []int, postorder []int) *TreeNode { n1 := len(postorder) n2 := len(inorder) inorderMap := make(map[int]int, n2) for i, num := range inorder { inorderMap[num] = i } return dfs(postorder, inorderMap, 0, n1-1, 0, n2-1)}func dfs(postorder []int, inorderMap map[int]int, postLeft, postRight, inLeft, inRight int) *TreeNode { if postLeft &gt; postRight { return nil } node := &amp;TreeNode{ Val: postorder[postRight], } inMid := inorderMap[postorder[postRight]] postMid := postRight - inRight + inMid node.Left = dfs(postorder, inorderMap, postLeft, postMid-1, inLeft, inMid-1) node.Right = dfs(postorder, inorderMap, postMid, postRight-1, inMid+1, inRight) return node} java1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { int n1 = inorder.length; int n2 = postorder.length; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;&gt;(n1); for (int i = 0; i &lt; n1; i++) { inorderMap.put(inorder[i], i); } return this.dfs(postorder, inorderMap, 0, n2 - 1, 0, n1 - 1); } private TreeNode dfs(int[] postorder, Map&lt;Integer, Integer&gt; inorderMap, int postLeft, int postRight, int inLeft, int inRight) { if (postLeft &gt; postRight) { return null; } TreeNode node = new TreeNode(postorder[postRight]); int inMid = inorderMap.get(postorder[postRight]); int postMid = postRight - inRight + inMid; node.left = dfs(postorder, inorderMap, postLeft, postMid - 1, inLeft, inMid - 1); node.right = dfs(postorder, inorderMap, postMid, postRight - 1, inMid + 1, inRight); return node; }}","link":"/leetcode/2024/02/construct-binary-tree-from-inorder-and-postorder-traversal/index.html"},{"title":"105. 从前序与中序遍历序列构造二叉树","text":"从前序与中序遍历序列构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal 标签: 分治 解法一: 分治go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func buildTree(preorder []int, inorder []int) *TreeNode { n1 := len(preorder) n2 := len(inorder) inorderMap := make(map[int]int, n2) for i, num := range inorder { inorderMap[num] = i } return dfs(preorder, inorderMap, 0, n1-1, 0, n2-1)}func dfs(preorder []int, inorderMap map[int]int, preLeft, preRight, inLeft, inRight int) *TreeNode { if preLeft &gt; preRight { return nil } node := &amp;TreeNode{ Val: preorder[preLeft], } inMid := inorderMap[preorder[preLeft]] preMid := preLeft + inMid - inLeft node.Left = dfs(preorder, inorderMap, preLeft+1, preMid, inLeft, inMid-1) node.Right = dfs(preorder, inorderMap, preMid+1, preRight, inMid+1, inRight) return node} java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int n1 = preorder.length; int n2 = inorder.length; Map&lt;Integer, Integer&gt; inorderMap = new HashMap&lt;Integer, Integer&gt;(n2); for (int i = 0; i &lt; n2; i++) { inorderMap.put(inorder[i], i); } return this.dfs(preorder, inorderMap, 0, n1 - 1, 0, n2 - 1); } private TreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; inorderMap, int preLeft, int preRight, int inLeft, int inRight) { if (preLeft &gt; preRight) { return null; } TreeNode node = new TreeNode(preorder[preLeft]); int inMid = inorderMap.get(preorder[preLeft]); int preMid = preLeft + inMid - inLeft; node.left = this.dfs(preorder, inorderMap, preLeft + 1, preMid, inLeft, inMid - 1); node.right = this.dfs(preorder, inorderMap, preMid + 1, preRight, inMid + 1, inRight); return node; }}","link":"/leetcode/2024/02/construct-binary-tree-from-preorder-and-inorder-traversal/index.html"},{"title":"889. 根据前序和后序遍历构造二叉树","text":"根据前序和后序遍历构造二叉树 难度: medium 原始链接: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal 标签: 分治 解法一: 分治go123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func constructFromPrePost(preorder []int, postorder []int) *TreeNode { n1 := len(preorder) n2 := len(postorder) postIndexMap := make(map[int]int, n2) for i, num := range postorder { postIndexMap[num] = i } return dfs(preorder, postIndexMap, 0, n1-1, 0, n2-1)}func dfs(preorder []int, postIndexMap map[int]int, preLeft, preRight, postLeft, postRight int) *TreeNode { if preLeft &gt; preRight { return nil } root := &amp;TreeNode{ Val: preorder[preLeft], } if preLeft &lt; preRight { postMid := postIndexMap[preorder[preLeft+1]] preMid := preLeft + postMid - postLeft + 1 root.Left = dfs(preorder, postIndexMap, preLeft+1, preMid, postLeft, postMid) root.Right = dfs(preorder, postIndexMap, preMid+1, preRight, postMid+1, postRight-1) } return root} java12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode constructFromPrePost(int[] preorder, int[] postorder) { int n1 = preorder.length; int n2 = postorder.length; Map&lt;Integer, Integer&gt; postIndexMap = new HashMap&lt;&gt;(n2); for (int i = 0; i &lt; n2; i++) { postIndexMap.put(postorder[i], i); } return this.dfs(preorder, postIndexMap, 0, n1 - 1, 0, n2 - 1); } private TreeNode dfs(int[] preorder, Map&lt;Integer, Integer&gt; postIndexMap, int preLeft, int preRight, int postLeft, int postRight) { if (preLeft &gt; preRight) { return null; } TreeNode root = new TreeNode(preorder[preLeft]); if (preLeft &lt; preRight) { int postMid = postIndexMap.get(preorder[preLeft + 1]); int preMid = preLeft + postMid - postLeft + 1; root.left = this.dfs(preorder, postIndexMap, preLeft + 1, preMid, postLeft, preMid); root.right = this.dfs(preorder, postIndexMap, preMid + 1, preRight, postMid + 1, postRight - 1); } return root; }}","link":"/leetcode/2024/02/construct-binary-tree-from-preorder-and-postorder-traversal/index.html"},{"title":"2867. 统计树中的合法路径数目","text":"统计树中的合法路径数目 难度: hard 原始链接: https://leetcode.cn/problems/count-valid-paths-in-a-tree 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func countPaths(n int, edges [][]int) int64 { primes := prime(n) grip := [][]int{} for i := 0; i &lt;= n; i++ { grip = append(grip, []int{}) } for _, edge := range edges { grip[edge[0]] = append(grip[edge[0]], edge[1]) grip[edge[1]] = append(grip[edge[1]], edge[0]) } var dfs func(cur, parent int, nodes *[]int) dfs = func(cur, parent int, nodes *[]int) { *nodes = append(*nodes, cur) for _, edge := range grip[cur] { if primes[edge] &amp;&amp; edge != parent { dfs(edge, cur, nodes) } } } sumArr := make([]int, n+1) ans := int64(0) for i := 2; i &lt;= n; i++ { if primes[i] { continue } sum := 0 for _, edge := range grip[i] { if !primes[edge] { continue } else if sumArr[edge] == 0 { nodes := []int{} dfs(edge, -1, &amp;nodes) for _, node := range nodes { sumArr[node] = len(nodes) } } ans += int64(sum * sumArr[edge]) sum += sumArr[edge] } ans += int64(sum) } return ans}func prime(n int) []bool { primes := make([]bool, n+1) primes[1] = true for i := 2; i &lt;= n; i++ { if !primes[i] { for j := i * i; j &lt;= n; j += i { primes[j] = true } } } return primes}","link":"/leetcode/2024/02/count-valid-paths-in-a-tree/index.html"},{"title":"2641. 二叉树的堂兄弟节点 II","text":"2641. 二叉树的堂兄弟节点 II 难度: medium 原始链接: https://leetcode.cn/problems/cousins-in-binary-tree-ii 标签: 广度优先遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func replaceValueInTree(root *TreeNode) *TreeNode { root.Val = 0 queue := []*TreeNode{root} for len(queue) &gt; 0 { sonSum := 0 for _, node := range queue { if node.Left != nil { sonSum += node.Left.Val } if node.Right != nil { sonSum += node.Right.Val } } size := len(queue) for _, node := range queue[:size] { curSonSum := 0 if node.Left != nil { curSonSum += node.Left.Val } if node.Right != nil { curSonSum += node.Right.Val } curSonVal := sonSum - curSonSum if node.Left != nil { node.Left.Val = curSonVal queue = append(queue, node.Left) } if node.Right != nil { node.Right.Val = curSonVal queue = append(queue, node.Right) } } queue = queue[size:] } return root} java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode replaceValueInTree(TreeNode root) { root.val = 0; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) { int sonSum = 0; for (TreeNode node : queue) { if (node.left != null) { sonSum += node.left.val; } if (node.right != null) { sonSum += node.right.val; } } int size = queue.size(); for (int i = 0; i &lt; size; i++) { int curSonSum = 0; TreeNode node = queue.poll(); if (node.left != null) { curSonSum += node.left.val; } if (node.right != null) { curSonSum += node.right.val; } int curSonVal = sonSum - curSonSum; if (node.left != null) { node.left.val = curSonVal; queue.offer(node.left); } if (node.right != null) { node.right.val = curSonVal; queue.offer(node.right); } } } return root; }}","link":"/leetcode/2024/02/cousins-in-binary-tree-ii/index.html"},{"title":"993. 二叉树的堂兄弟节点","text":"993. 二叉树的堂兄弟节点 难度: easy 原始链接: https://leetcode.cn/problems/cousins-in-binary-tree 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isCousins(root *TreeNode, x int, y int) bool { xParentNode, xDepth := dfs(root, nil, 0, x) yParentNode, yDepth := dfs(root, nil, 0, y) return xParentNode != yParentNode &amp;&amp; xDepth == yDepth}func dfs(curNode, parentNode *TreeNode, depth, target int) (int, int) { if curNode == nil { return -1, -1 } if curNode.Val == target { if parentNode == nil { return 0, depth } return parentNode.Val, depth } if leftParentNode, leftDepth := dfs(curNode.Left, curNode, depth+1, target); leftParentNode != -1 { return leftParentNode, leftDepth } return dfs(curNode.Right, curNode, depth+1, target)} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isCousins(root *TreeNode, x int, y int) bool { queue := []*TreeNode{root} for len(queue) &gt; 0 { size := len(queue) flag := 0 for _, node := range queue[:size] { preFlag := flag if node.Left != nil { curVal := node.Left.Val if curVal == x { flag |= 1 } if curVal == y { flag |= 2 } queue = append(queue, node.Left) } if node.Right != nil { curVal := node.Right.Val if curVal == x { flag |= 1 } if curVal == y { flag |= 2 } queue = append(queue, node.Right) } if flag == 3 { if preFlag == 0 { return false } return true } } queue = queue[size:] } return false}","link":"/leetcode/2024/02/cousins-in-binary-tree/index.html"},{"title":"1696. 跳跃游戏 VI","text":"1696. 跳跃游戏 VI 难度: medium 原始链接: https://leetcode.cn/problems/jump-game-vi 标签: 单调栈 解法一: 单调栈go1234567891011121314151617func maxResult(nums []int, k int) int { n := len(nums) dp := make([]int, n) dp[0] = nums[0] stack := []int{0} for i := 1; i &lt; n; i++ { if stack[0] &lt; i-k { stack = stack[1:] } dp[i] = nums[i] + dp[stack[0]] for len(stack) &gt; 0 &amp;&amp; dp[stack[len(stack)-1]] &lt;= dp[i] { stack = stack[:len(stack)-1] } stack = append(stack, i) } return dp[n-1]}","link":"/leetcode/2024/02/jump-game-vi/index.html"},{"title":"2583. 二叉树中的第 K 大层和","text":"二叉树中的第 K 大层和 难度: medium 原始链接: https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree 标签: 层序遍历 解法一: 广度优先遍历go1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func kthLargestLevelSum(root *TreeNode, k int) int64 { queue := []*TreeNode{root} var sumArr []int64 for len(queue) &gt; 0 { size := len(queue) var sum int64 for i := 0; i &lt; size; i++ { node := queue[i] sum += int64(node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } queue = queue[size:] sumArr = append(sumArr, sum) } if len(sumArr) &lt; k { return -1 } sort.Slice(sumArr, func(i, j int) bool { return sumArr[i] &gt;= sumArr[j] }) return sumArr[k-1]} 解法二: 深度优先遍历Go12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func kthLargestLevelSum(root *TreeNode, k int) int64 { var sumArr []int64 var dfs func(*TreeNode, int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(sumArr) &lt;= depth { sumArr = append(sumArr, 0) } sumArr[depth] += int64(node.Val) dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) if len(sumArr) &lt; k { return -1 } sort.Slice(sumArr, func(i, j int) bool { return sumArr[i] &gt;= sumArr[j] }) return sumArr[k-1]}","link":"/leetcode/2024/02/kth-largest-sum-in-a-binary-tree/index.html"},{"title":"235. 二叉搜索树的最近公共祖先","text":"二叉搜索树的最近公共祖先 难度: medium 原始链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val &gt; q.Val { return lowestCommonAncestor(root, q, p) } if root.Val &lt; p.Val { return lowestCommonAncestor(root.Right, q, p) } else if root.Val &gt; q.Val { return lowestCommonAncestor(root.Left, q, p) } return root}","link":"/leetcode/2024/02/lowest-common-ancestor-of-a-binary-search-tree/index.html"},{"title":"236. 二叉树的最近公共祖先","text":"236. 二叉树的最近公共祖先 难度: medium 原始链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree 标签: 后序遍历 解法一: 后序遍历go123456789101112131415161718192021/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil || root == p || root == q { return root } leftNode := lowestCommonAncestor(root.Left, p, q) rightNode := lowestCommonAncestor(root.Right, p, q) if leftNode == nil { return rightNode } else if rightNode == nil { return leftNode } return root}","link":"/leetcode/2024/02/lowest-common-ancestor-of-a-binary-tree/index.html"},{"title":"2673. 使二叉树所有路径值相等的最小代价","text":"使二叉树所有路径值相等的最小代价 难度: medium 原始链接: https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree 标签: 贪心 解法一: 贪心go12345678910111213141516171819func minIncrements(n int, cost []int) int { ans := 0 for i := (n &gt;&gt; 1); i &gt; 0; i-- { left, right := cost[(i&lt;&lt;1)-1], cost[i&lt;&lt;1] if left &gt; right { left, right = right, left } cost[i-1] += right ans += right - left } return ans}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2024/02/make-costs-of-paths-equal-in-a-binary-tree/index.html"},{"title":"429. N 叉树的层序遍历","text":"N 叉树的层序遍历 难度: medium 原始链接: https://leetcode.cn/problems/n-ary-tree-level-order-traversal 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go123456789101112131415161718192021222324252627/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func levelOrder(root *Node) [][]int { ans := [][]int{} var dfs func(node *Node, depth int) dfs = func(node *Node, depth int) { if node == nil { return } if len(ans) &lt;= depth { ans = append(ans, []int{}) } ans[depth] = append(ans[depth], node.Val) depth++ for _, child := range node.Children { dfs(child, depth) } } dfs(root, 0) return ans} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func levelOrder(root *Node) [][]int { ans := [][]int{} if root == nil { return ans } queue := []*Node{root} for len(queue) &gt; 0 { size := len(queue) nodes := make([]int, size) for i := 0; i &lt; size; i++ { nodes[i] = queue[i].Val for _, child := range queue[i].Children { queue = append(queue, child) } } queue = queue[size:] ans = append(ans, nodes) } return ans}","link":"/leetcode/2024/02/n-ary-tree-level-order-traversal/index.html"},{"title":"590. N 叉树的后序遍历","text":"N 叉树的后序遍历 难度: easy 原始链接: https://leetcode.cn/problems/n-ary-tree-postorder-traversal 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func postorder(root *Node) []int { ans := []int{} var dfs func(node *Node) dfs = func(node *Node) { if node == nil { return } for _, child := range node.Children { dfs(child) } ans = append(ans, node.Val) } dfs(root) return ans} 解法二: 广度优先遍历go12345678910111213141516171819202122232425262728293031/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func postorder(root *Node) []int { ans := []int{} if root == nil { return ans } stack := []*Node{root} set := make(map[*Node]bool) for len(stack) &gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] n := len(node.Children) if n &gt; 0 &amp;&amp; !set[node] { stack = append(stack, node) set[node] = true for i := n - 1; i &gt;= 0; i-- { stack = append(stack, node.Children[i]) } } else { ans = append(ans, node.Val) } } return ans}","link":"/leetcode/2024/02/n-ary-tree-postorder-traversal/index.html"},{"title":"589. N 叉树的前序遍历","text":"N 叉树的前序遍历 难度: easy 原始链接: https://leetcode.cn/problems/n-ary-tree-preorder-traversal 标签: 前序遍历 解法一: 递归go1234567891011121314151617181920212223/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func preorder(root *Node) []int { ans := []int{} var dfs func(node *Node) dfs = func(node *Node) { if node == nil { return } ans = append(ans, node.Val) for _, child := range node.Children { dfs(child) } } dfs(root) return ans} 解法二: 迭代go123456789101112131415161718192021222324/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */func preorder(root *Node) []int { ans := []int{} if root == nil { return ans } stack := []*Node{root} for len(stack) &gt; 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] ans = append(ans, node.Val) for i := len(node.Children) - 1; i &gt;= 0; i-- { stack = append(stack, node.Children[i]) } } return ans}","link":"/leetcode/2024/02/n-ary-tree-preorder-traversal/index.html"},{"title":"292. Nim 游戏","text":"292. Nim 游戏 难度: easy 原始链接: https://leetcode.cn/problems/nim-game 标签: 数学 解法一: 数学go123func canWinNim(n int) bool { return (n % 4) != 0}","link":"/leetcode/2024/02/nim-game/index.html"},{"title":"LCP 30. 魔塔游戏","text":"LCP 30. 魔塔游戏 难度: medium 原始链接: https://leetcode.cn/problems/p0NxJO 标签: 贪心 解法一: 贪心java12345678910111213141516171819202122class Solution { public int magicTower(int[] nums) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); int ans = 0; long hp = 1; long last = 0; for (int num : nums) { hp += num; if (num &lt; 0) { priorityQueue.offer(num); if (hp &lt;= 0) { Integer moveNum = priorityQueue.poll(); last += moveNum; hp -= moveNum; ans++; } } } hp += last; return hp &lt;= 0 ? -1 : ans; }}","link":"/leetcode/2024/02/p0NxJO/index.html"},{"title":"938. 二叉搜索树的范围和","text":"二叉搜索树的范围和 难度: easy 原始链接: https://leetcode.cn/problems/range-sum-of-bst 标签: 递归 解法一: 递归go12345678910111213141516171819/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func rangeSumBST(root *TreeNode, low int, high int) int { if root == nil { return 0 } if root.Val &lt; low { return rangeSumBST(root.Right, low, high) } else if root.Val &gt; high { return rangeSumBST(root.Left, low, high) } return root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)}","link":"/leetcode/2024/02/range-sum-of-bst/index.html"},{"title":"1686. 石子游戏 VI","text":"1686. 石子游戏 VI 难度: medium 原始链接: https://leetcode.cn/problems/stone-game-vi 标签: 贪心 解法一: 贪心go12345678910111213141516171819202122232425func stoneGameVI(aliceValues []int, bobValues []int) int { n := len(aliceValues) prices := make([][]int, n) for i := 0; i &lt; n; i++ { prices[i] = []int{aliceValues[i] + bobValues[i], i} } sort.Slice(prices, func(i, j int) bool { return prices[i][0] &gt;= prices[j][0] }) alice := 0 bob := 0 for i := 0; i &lt; n; i++ { if (i &amp; 1) == 0 { alice += aliceValues[prices[i][1]] } else { bob += bobValues[prices[i][1]] } } if alice &gt; bob { return 1 } else if alice &lt; bob { return -1 } return 0}","link":"/leetcode/2024/02/stone-game-vi/index.html"},{"title":"987. 二叉树的垂序遍历","text":"二叉树的垂序遍历 难度: hard 原始链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree 标签: 排序 解法一: 排序go123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func verticalTraversal(root *TreeNode) [][]int { var lists [][]int var dfs func(*TreeNode, int, int) dfs = func(node *TreeNode, col, row int) { if node == nil { return } lists = append(lists, []int{col, row, node.Val}) dfs(node.Left, col-1, row+1) dfs(node.Right, col+1, row+1) } dfs(root, 0, 0) sort.Slice(lists, func(i, j int) bool { if lists[i][0] != lists[j][0] { return lists[i][0] &lt;= lists[j][0] } if lists[i][1] != lists[j][1] { return lists[i][1] &lt;= lists[j][1] } return lists[i][2] &lt;= lists[j][2] }) preCol := -1001 var ans [][]int for _, list := range lists { if preCol == list[0] { last := len(ans) - 1 ans[last] = append(ans[last], list[2]) } else { preCol = list[0] ans = append(ans, []int{list[2]}) } } return ans}","link":"/leetcode/2024/02/vertical-order-traversal-of-a-binary-tree/index.html"},{"title":"299. 猜数字游戏","text":"猜数字游戏 难度: medium 原始链接: https://leetcode.cn/problems/bulls-and-cows 标签: 哈希 解法一: 哈希go12345678910111213141516171819func getHint(secret string, guess string) string { bulls := 0 cows := 0 sCount := make([]int, 10) gCount := make([]int, 10) n := len(secret) for i := 0; i &lt; n; i++ { if secret[i] == guess[i] { bulls++ } else { sCount[secret[i]-'0']++ gCount[guess[i]-'0']++ } } for i := 0; i &lt; 10; i++ { cows += min(sCount[i], gCount[i]) } return strconv.Itoa(bulls) + &quot;A&quot; + strconv.Itoa(cows) + &quot;B&quot;}","link":"/leetcode/2024/03/bulls-and-cows/index.html"},{"title":"2129. 将标题首字母大写","text":"将标题首字母大写 难度: easy 原始链接: https://leetcode.cn/problems/capitalize-the-title 标签: 模拟 解法一: 模拟go1234567891011func capitalizeTitle(title string) string { fields := strings.Fields(title) for i, field := range fields { if len(field) &lt;= 2 { fields[i] = strings.ToLower(field) } else { fields[i] = strings.ToUpper(field[:1]) + strings.ToLower(field[1:]) } } return strings.Join(fields, &quot; &quot;)} java123456789101112class Solution { public String capitalizeTitle(String title) { return Arrays.stream(title.split(&quot; &quot;)) .map(str -&gt; { if (str.length() &lt;= 2) { return str.toLowerCase(); } return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase(); }) .collect(Collectors.joining(&quot; &quot;)); }}","link":"/leetcode/2024/03/capitalize-the-title/index.html"},{"title":"2369. 检查数组是否存在有效划分","text":"检查数组是否存在有效划分 难度: medium 原始链接: https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array 标签: 动态规划 解法一: 动态规划go1234567891011121314151617181920212223242526func validPartition(nums []int) bool { n := len(nums) dp := make([]bool, n) // 初始化 dp 的前三个状态 dp[0] = false dp[1] = nums[0] == nums[1] if n == 2 { return dp[1] } dp[2] = dp[1] &amp;&amp; nums[1] == nums[2] || nums[0] == nums[1]-1 &amp;&amp; nums[0] == nums[2]-2 // 从第四个元素元素开始递推 for i := 3; i &lt; n; i++ { if dp[i-2] &amp;&amp; nums[i] == nums[i-1] { // 1. 两个元素相等 dp[i] = true } else if dp[i-3] &amp;&amp; nums[i] == nums[i-1] &amp;&amp; nums[i] == nums[i-2] { // 2. 三个元素相同 dp[i] = true } else if dp[i-3] &amp;&amp; nums[i] == nums[i-1]+1 &amp;&amp; nums[i] == nums[i-2]+2 { // 3. 三个元素递增 dp[i] = true } } // 返回最后一个元素状态是否可达 return dp[n-1]}","link":"/leetcode/2024/03/check-if-there-is-a-valid-partition-for-the-array/index.html"},{"title":"2549. 统计桌面上的不同数字","text":"统计桌面上的不同数字 难度: easy 原始链接: https://leetcode.cn/problems/count-distinct-numbers-on-board 标签: 数学 解法一: 数学go123func distinctIntegers(n int) int { return max(n-1, 1)}","link":"/leetcode/2024/03/count-distinct-numbers-on-board/index.html"},{"title":"2580. 统计将重叠区间合并成组的方案数","text":"统计将重叠区间合并成组的方案数 难度: medium 原始链接: https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges 标签: 排序, 快速幂 解法一: 排序, 快速幂go12345678910111213141516171819202122232425262728293031const MOD = 1_000_000_007func countWays(ranges [][]int) int { sort.Slice(ranges, func(i, j int) bool { return ranges[i][0] &lt;= ranges[j][0] }) count := 0 pre := -1 for _, r := range ranges { if pre &lt; r[0] { count++ } pre = max(pre, r[1]) } return quickSort(2%MOD, count, MOD)}func quickSort(num, x, mod int) int { if x == 0 { return 1 } else if x == 1 { return num % mod } half := x &gt;&gt; 1 halfAns := quickSort(num, half, mod) ans := halfAns * halfAns % mod if (x &amp; 1) == 1 { ans = ans * num % mod } return ans}","link":"/leetcode/2024/03/count-ways-to-group-overlapping-ranges/index.html"},{"title":"1261. 在受污染的二叉树中查找元素","text":"在受污染的二叉树中查找元素 难度: medium 原始链接: https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree 标签: 哈希 解法一: 哈希go1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */type FindElements struct { set map[int]bool}func Constructor(root *TreeNode) FindElements { set := map[int]bool{} var dfs func(node *TreeNode, cur int) dfs = func(node *TreeNode, cur int) { if node == nil { return } set[cur] = true dfs(node.Left, (cur&lt;&lt;1)+1) dfs(node.Right, (cur&lt;&lt;1)+2) } dfs(root, 0) return FindElements{ set, }}func (this *FindElements) Find(target int) bool { return this.set[target]}/** * Your FindElements object will be instantiated and called as such: * obj := Constructor(root); * param_1 := obj.Find(target); */","link":"/leetcode/2024/03/find-elements-in-a-contaminated-binary-tree/index.html"},{"title":"2575. 找出字符串的可整除数组","text":"找出字符串的可整除数组 难度: medium 原始链接: https://leetcode.cn/problems/find-the-divisibility-array-of-a-string 标签: 模运算 解法一: 模运算go123456789101112func divisibilityArray(word string, m int) []int { n := len(word) ans := make([]int, n) cur := 0 for i, ch := range word { cur = (cur*10 + int(ch-'0')) % m if cur == 0 { ans[i] = 1 } } return ans}","link":"/leetcode/2024/03/find-the-divisibility-array-of-a-string/index.html"},{"title":"2917. 找出数组中的 K-or 值","text":"找出数组中的 K-or 值 难度: easy 原始链接: https://leetcode.cn/problems/find-the-k-or-of-an-array 标签: 位运算 解法一: 位运算go12345678910111213141516func findKOr(nums []int, k int) int { ans := 0 for i := 0; i &lt; 31; i++ { count := 0 for _, num := range nums { if (num&gt;&gt;i)&amp;1 == 1 { count++ if count &gt;= k { ans += 1 &lt;&lt; i break } } } } return ans}","link":"/leetcode/2024/03/find-the-k-or-of-an-array/index.html"},{"title":"2834. 找出美丽数组的最小和","text":"找出美丽数组的最小和 难度: medium 原始链接: https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array 标签: 数学 解法一: 数学go12345678910111213const MOD = 1000000007func minimumPossibleSum(n int, target int) int { // 左边部分 left1 := 1 right1 := min(target&gt;&gt;1, n) leftSum := ((left1 + right1) * (right1 - left1 + 1)) &gt;&gt; 1 // 右边部分 left2 := target right2 := target + (n - (right1 - left1 + 1)) - 1 rightSum := ((left2 + right2) * (right2 - left2 + 1)) &gt;&gt; 1 return (leftSum + rightSum) % MOD}","link":"/leetcode/2024/03/find-the-minimum-possible-sum-of-a-beautiful-array/index.html"},{"title":"2671. 频率跟踪器","text":"频率跟踪器 难度: medium 原始链接: https://leetcode.cn/problems/frequency-tracker 标签: 哈希 解法一: 哈希go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type FrequencyTracker struct { hash1 map[int]int hash2 map[int]int}func Constructor() FrequencyTracker { return FrequencyTracker{ hash1: make(map[int]int), hash2: make(map[int]int), }}func (this *FrequencyTracker) Add(number int) { hash1 := this.hash1 hash2 := this.hash2 if count, exists := hash1[number]; exists { hash2[count]-- hash2[count+1]++ } else { hash2[1]++ } hash1[number]++}func (this *FrequencyTracker) DeleteOne(number int) { hash1 := this.hash1 hash2 := this.hash2 if count := hash1[number]; count != 0 { hash2[count]-- if count &gt; 1 { hash2[count-1]++ } hash1[number]-- }}func (this *FrequencyTracker) HasFrequency(frequency int) bool { hash2 := this.hash2 return hash2[frequency] &gt; 0}/** * Your FrequencyTracker object will be instantiated and called as such: * obj := Constructor(); * obj.Add(number); * obj.DeleteOne(number); * param_3 := obj.HasFrequency(frequency); */","link":"/leetcode/2024/03/frequency-tracker/index.html"},{"title":"232. 用栈实现队列","text":"用栈实现队列 难度: easy 原始链接: https://leetcode.cn/problems/implement-queue-using-stacks 标签: 堆栈, 队列 解法一: 双栈go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071type MyQueue struct { stack1 *[]int stack2 *[]int}func Constructor() MyQueue { return MyQueue{ stack1: &amp;[]int{}, stack2: &amp;[]int{}, }}func (this *MyQueue) Push(x int) { stack1 := *(this.stack1) stack1 = append(stack1, x) this.stack1 = &amp;stack1}func (this *MyQueue) Pop() int { stack2 := *(this.stack2) if len(stack2) &gt; 0 { ans := stack2[len(stack2)-1] stack2 = stack2[:len(stack2)-1] this.stack2 = &amp;stack2 return ans } this.stack12Stack2() return this.Pop()}func (this *MyQueue) Peek() int { stack2 := *(this.stack2) if len(stack2) &gt; 0 { return stack2[len(stack2)-1] } this.stack12Stack2() return this.Peek()}func (this *MyQueue) Empty() bool { stack2 := *(this.stack2) if len(stack2) &gt; 0 { return len(stack2) == 0 } this.stack12Stack2() stack2 = *(this.stack2) return len(stack2) == 0}func (this *MyQueue) stack12Stack2() { stack1 := *(this.stack1) stack2 := *(this.stack2) if len(stack2) &gt; 0 { return } for len(stack1) &gt; 0 { stack2 = append(stack2, stack1[len(stack1)-1]) stack1 = stack1[:len(stack1)-1] } this.stack1 = &amp;stack1 this.stack2 = &amp;stack2}/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */","link":"/leetcode/2024/03/implement-queue-using-stacks/index.html"},{"title":"225. 用队列实现栈","text":"用队列实现栈 难度: easy 原始链接: https://leetcode.cn/problems/implement-stack-using-queues 标签: 队列, 堆栈 解法一: 双队列go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type MyStack struct { queue1 *[]int queue2 *[]int}func Constructor() MyStack { return MyStack{ queue1: &amp;[]int{}, queue2: &amp;[]int{}, }}func (this *MyStack) Push(x int) { queue1 := this.queue1 queue2 := this.queue2 *queue2 = append(*queue2, x) if len(*queue1) &gt; 0 { *queue2 = append(*queue2, *queue1...) *queue1 = []int{} } this.queue1, this.queue2 = this.queue2, this.queue1}func (this *MyStack) Pop() int { queue1 := this.queue1 ans := (*queue1)[0] (*queue1) = (*queue1)[1:] return ans}func (this *MyStack) Top() int { queue1 := this.queue1 return (*queue1)[0]}func (this *MyStack) Empty() bool { queue1 := this.queue1 return len(*queue1) == 0}/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 解法二: 一个队列go123456789101112131415161718192021222324252627282930313233343536373839404142434445type MyStack struct { queue *[]int}func Constructor() MyStack { return MyStack{ queue: &amp;[]int{}, }}func (this *MyStack) Push(x int) { queue := this.queue n := len(*queue) *queue = append(*queue, x) for i := 0; i &lt; n; i++ { *queue = append(*queue, (*queue)[i]) } *queue = (*queue)[n:]}func (this *MyStack) Pop() int { queue := this.queue ans := (*queue)[0] (*queue) = (*queue)[1:] return ans}func (this *MyStack) Top() int { queue := this.queue return (*queue)[0]}func (this *MyStack) Empty() bool { queue := this.queue return len(*queue) == 0}/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */","link":"/leetcode/2024/03/implement-stack-using-queues/index.html"},{"title":"2789. 合并后数组中的最大元素","text":"合并后数组中的最大元素 难度: medium 原始链接: https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations 标签: 贪心 解法一: 贪心go123456789101112131415func maxArrayValue(nums []int) int64 { n := len(nums) cur := int64(nums[n-1]) ans := int64(cur) for i := n - 1; i &gt; 0; i-- { pre := int64(nums[i-1]) if cur &gt;= pre { cur += pre } else { cur = pre } ans = max(ans, cur) } return ans}","link":"/leetcode/2024/03/largest-element-in-an-array-after-merge-operations/index.html"},{"title":"2684. 矩阵中移动的最大次数","text":"矩阵中移动的最大次数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid 标签: 深度优先遍历, 广度优先遍历 解法一: 深度优先遍历go123456789101112131415161718192021222324252627282930313233func maxMoves(grid [][]int) int { m := len(grid) n := len(grid[0]) shift := []int{ -1, 0, 1, } ansMap := make(map[int]int) var dfs func(r, c int) int dfs = func(r, c int) int { if ans, exists := ansMap[r*n+c]; exists { return ans } ans := c - 1 if c &gt;= n { return ans } for i := 0; i &lt; 3; i++ { newR := r + shift[i] if newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; grid[newR][c] &gt; grid[r][c-1] { ans = max(ans, dfs(newR, c+1)) } } ansMap[r*n+c] = ans return ans } ans := 0 for i := 0; i &lt; m; i++ { ans = max(ans, dfs(i, 1)) } return ans} 解法二: 广度优先遍历go123456789101112131415161718192021222324252627282930313233func maxMoves(grid [][]int) int { m := len(grid) n := len(grid[0]) for i := 0; i &lt; m; i++ { grid[i][0] *= -1 } width := 1 shift := []int{ -1, 0, 1, } for width &lt; n { isNext := false for i := 0; i &lt; m; i++ { if grid[i][width-1] &gt; 0 { continue } for j := 0; j &lt; 3; j++ { r := i + shift[j] if r &gt;= 0 &amp;&amp; r &lt; m &amp;&amp; grid[r][width] &gt; 0 &amp;&amp; grid[r][width] &gt; -grid[i][width-1] { isNext = true grid[r][width] *= -1 } } } if !isNext { break } width++ } return width - 1}","link":"/leetcode/2024/03/maximum-number-of-moves-in-a-grid/index.html"},{"title":"2864. 最大二进制奇数","text":"最大二进制奇数 难度: easy 原始链接: https://leetcode.cn/problems/maximum-odd-binary-number 标签: 模拟 解法一: 模拟go1234567891011121314func maximumOddBinaryNumber(s string) string { one := countOne(s) return strings.Repeat(&quot;1&quot;, one-1) + strings.Repeat(&quot;0&quot;, len(s)-one) + &quot;1&quot;}func countOne(str string) int { count := 0 for _, ch := range str { if ch == '1' { count++ } } return count}","link":"/leetcode/2024/03/maximum-odd-binary-number/index.html"},{"title":"310. 最小高度树","text":"最小高度树 难度: medium 原始链接: https://leetcode.cn/problems/minimum-height-trees 标签: 广度优先遍历 解法一: 广度优先遍历go12345678910111213141516171819202122232425262728293031323334func findMinHeightTrees(n int, edges [][]int) []int { if n == 1 { return []int{0} } relations := make([][]int, n) inCount := make([]int, n) for _, edge := range edges { relations[edge[0]] = append(relations[edge[0]], edge[1]) relations[edge[1]] = append(relations[edge[1]], edge[0]) inCount[edge[0]]++ inCount[edge[1]]++ } queue := []int{} for i, count := range inCount { if count == 1 { queue = append(queue, i) } } ans := queue for len(queue) &gt; 0 { ans = queue size := len(queue) for i := 0; i &lt; size; i++ { for _, node := range relations[queue[i]] { inCount[node]-- if inCount[node] == 1 { queue = append(queue, node) } } } queue = queue[size:] } return ans}","link":"/leetcode/2024/03/minimum-height-trees/index.html"},{"title":"1969. 数组元素的最小非零乘积","text":"数组元素的最小非零乘积 难度: medium 原始链接: https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements 标签: 数学 解法一: 数学go1234567891011121314151617181920const MOD = 1000000007func minNonZeroProduct(p int) int { // (2 ^ p - 1) * (2 ^ p - 2) ^ (2 ^ (p - 1) - 1) base := 1 &lt;&lt; p return (base - 1) % MOD * pow((base-2)%MOD, (base&gt;&gt;1)-1) % MOD}func pow(x, n int) int { if n == 0 { return 1 } half := n &gt;&gt; 1 halfAns := pow(x, half) ans := halfAns * halfAns % MOD if (n &amp; 1) == 1 { ans = ans * x % MOD } return ans}","link":"/leetcode/2024/03/minimum-non-zero-product-of-the-array-elements/index.html"},{"title":"2952. 需要添加的硬币的最小数量","text":"需要添加的硬币的最小数量 难度: medium 原始链接: https://leetcode.cn/problems/minimum-number-of-coins-to-be-added 标签: 数学, 贪心 解法一: 数学, 贪心go1234567891011121314151617func minimumAddedCoins(coins []int, target int) int { sort.Ints(coins) n := len(coins) ans := 0 s := 1 i := 0 for s &lt;= target { if i &lt; n &amp;&amp; coins[i] &lt;= s { s += coins[i] i++ } else { ans++ s &lt;&lt;= 1 } } return ans}","link":"/leetcode/2024/03/minimum-number-of-coins-to-be-added/index.html"},{"title":"2908. 元素和最小的山形三元组 I","text":"元素和最小的山形三元组 I 难度: easy 原始链接: https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i 标签: 预处理 解法一: 预处理go1234567891011121314151617181920func minimumSum(nums []int) int { n := len(nums) minArr := make([]int, n) minArr[0] = nums[0] for i := 1; i &lt; n; i++ { minArr[i] = min(minArr[i-1], nums[i-1]) } pre := nums[n-1] ans := math.MaxInt for i := n - 2; i &gt; 0; i-- { if nums[i] &gt; pre &amp;&amp; nums[i] &gt; minArr[i] { ans = min(ans, pre+nums[i]+minArr[i]) } pre = min(pre, nums[i]) } if ans == math.MaxInt { return -1 } return ans}","link":"/leetcode/2024/03/minimum-sum-of-mountain-triplets-i/index.html"},{"title":"303. 区域和检索 - 数组不可变","text":"区域和检索 - 数组不可变 难度: easy 原始链接: https://leetcode.cn/problems/range-sum-query-immutable 标签: 前缀和 解法一: 前缀和go1234567891011121314151617181920212223242526type NumArray struct { preSum []int}func Constructor(nums []int) NumArray { sum := 0 preSum := make([]int, len(nums)+1) for i, num := range nums { sum += num preSum[i+1] = sum } return NumArray{ preSum, }}func (this *NumArray) SumRange(left int, right int) int { preSum := this.preSum return preSum[right+1] - preSum[left]}/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(left,right); */","link":"/leetcode/2024/03/range-sum-query-immutable/index.html"},{"title":"2368. 受限条件下可到达节点的数目","text":"2368. 受限条件下可到达节点的数目 难度: medium 原始链接: https://leetcode.cn/problems/reachable-nodes-with-restrictions 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122func reachableNodes(n int, edges [][]int, restricted []int) int { tree := make(map[int][]int) for _, edge := range edges { tree[edge[0]] = append(tree[edge[0]], edge[1]) tree[edge[1]] = append(tree[edge[1]], edge[0]) } set := make(map[int]bool, len(restricted)) for _, num := range restricted { set[num] = true } return dfs(0, -1, tree, set)}func dfs(cur, parent int, tree map[int][]int, set map[int]bool) int { ans := 1 for _, next := range tree[cur] { if next != parent &amp;&amp; !set[next] { ans += dfs(next, cur, tree, set) } } return ans}","link":"/leetcode/2024/03/reachable-nodes-with-restrictions/index.html"},{"title":"2192. 有向无环图中一个节点的所有祖先","text":"有向无环图中一个节点的所有祖先 难度: medium 原始链接: https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546func getAncestors(n int, edges [][]int) [][]int { relations := make([][]int, n) // 反方向建立联系 for _, edge := range edges { relations[edge[1]] = append(relations[edge[1]], edge[0]) } // 标记已经计算完成的节点 visit := make([]bool, n) // 结果 ans := make([][]int, n) // 计算指定节点的所有父节点，排序并去重 var dfs func(cur int) []int dfs = func(cur int) []int { if visit[cur] { return ans[cur] } // 标记当前节点已计算完毕 visit[cur] = true // 记录当前节点的所有父节点，可能会有节点重复 parent := []int{} for _, relation := range relations[cur] { parent = append(parent, dfs(relation)...) parent = append(parent, relation) } // 排序 sort.Ints(parent) n := len(parent) // 双指针去重 if n &gt; 0 { i := 0 for j := 1; j &lt; n; j++ { if parent[j] != parent[i] { i++ parent[i] = parent[j] } } ans[cur] = parent[:i+1] } return parent } // 循环计算每个节点 for i := 0; i &lt; n; i++ { dfs(i) } return ans} java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { public List&lt;List&lt;Integer&gt;&gt; getAncestors(int n, int[][] edges) { // 标记已经计算完成的节点 boolean[] visit = new boolean[n]; // 反方向建立联系 Map&lt;Integer, List&lt;Integer&gt;&gt; relations = new HashMap&lt;&gt;(n); for (int[] edge : edges) { relations.merge(edge[1], Collections.singletonList(edge[0]), (origin, target) -&gt; { if (origin.size() == 1) { origin = new ArrayList&lt;&gt;(origin); } origin.addAll(target); return origin; }); } List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(n); for (int i = 0; i &lt; n; i++) { ans.add(new ArrayList&lt;&gt;()); } // 循环计算每个节点 for (int i = 0; i &lt; n; i++) { this.dfs(i, visit, relations, ans); } return ans; } private List&lt;Integer&gt; dfs(int cur, boolean[] visit, Map&lt;Integer, List&lt;Integer&gt;&gt; relations, List&lt;List&lt;Integer&gt;&gt; ans) { if (visit[cur]) { return ans.get(cur); } // 标记当前节点已计算完毕 visit[cur] = true; // 记录当前节点的所有父节点，可能会有节点重复 List&lt;Integer&gt; parent = new ArrayList&lt;&gt;(); for (Integer relation : relations.getOrDefault(cur, Collections.emptyList())) { parent.addAll(this.dfs(relation, visit, relations, ans)); parent.add(relation); } if (parent.isEmpty()) { return parent; } // 排序 Collections.sort(parent); // 双指针去重 int i = 0; int n = parent.size(); for (int j = 1; j &lt; n; j++) { if (!Objects.equals(parent.get(j), parent.get(i))) { parent.set(++i, parent.get(j)); } } ans.set(cur, parent.subList(0, i + 1)); return parent; }}","link":"/leetcode/2024/04/all-ancestors-of-a-node-in-a-directed-acyclic-graph/index.html"},{"title":"2385. 感染二叉树需要的总时间","text":"感染二叉树需要的总时间 难度: medium 原始链接: https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected 标签: 广度优先遍历, 深度优先遍历 解法一: 广度优先遍历, 深度优先遍历go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func amountOfTime(root *TreeNode, start int) int { relations := make(map[int][]int) var searchParent func(cur, pre *TreeNode) searchParent = func(cur, pre *TreeNode) { list := []int{} if pre != nil { list = append(list, pre.Val) } if cur.Left != nil { list = append(list, cur.Left.Val) searchParent(cur.Left, cur) } if cur.Right != nil { list = append(list, cur.Right.Val) searchParent(cur.Right, cur) } relations[cur.Val] = list } searchParent(root, nil) queue := []int{start} visit := map[int]bool{start: true} ans := 0 for { size := len(queue) for i := 0; i &lt; size; i++ { for _, nodeVal := range relations[queue[i]] { if !visit[nodeVal] { visit[nodeVal] = true queue = append(queue, nodeVal) } } } queue = queue[size:] if len(queue) == 0 { break } ans++ } return ans}","link":"/leetcode/2024/04/amount-of-time-for-binary-tree-to-be-infected/index.html"},{"title":"216. 组合总和 III","text":"组合总和 III 难度: medium 原始链接: https://leetcode.cn/problems/combination-sum-iii 标签: 回溯 解法一: 回溯go123456789101112131415161718192021222324func combinationSum3(k int, n int) [][]int { ans := [][]int{} var dfs func(cur, sum int, list []int) dfs = func(cur, sum int, list []int) { if len(list) == k &amp;&amp; sum == n { newList := make([]int, k) copy(newList, list) ans = append(ans, newList) return } if cur &gt; 9 || len(list) &gt; k || sum &gt; n { return } for i := cur; i &lt;= 9; i++ { list = append(list, i) sum += i dfs(i+1, sum, list) sum -= i list = list[:len(list)-1] } } dfs(1, 0, []int{}) return ans}","link":"/leetcode/2024/04/combination-sum-iii/index.html"},{"title":"377. 组合总和 IV","text":"组合总和 IV 难度: medium 原始链接: https://leetcode.cn/problems/combination-sum-iv 标签: 动态规划 解法一: 递归, 记忆化搜索go1234567891011121314151617181920212223func combinationSum4(nums []int, target int) int { record := make([]int, target+1) for i := 1; i &lt;= target; i++ { record[i] = -1 } var dfs func(cur int) int dfs = func(cur int) int { if cur == 0 { return 1 } else if record[cur] &gt; -1 { return record[cur] } sum := 0 for _, num := range nums { if cur &gt;= num { sum += dfs(cur - num) } } record[cur] = sum return sum } return dfs(target)} 解法二: 迭代go1234567891011121314func combinationSum4(nums []int, target int) int { record := make([]int, target+1) record[0] = 1 for i := 1; i &lt;= target; i++ { sum := 0 for _, num := range nums { if i &gt;= num { sum += record[i-num] } } record[i] = sum } return record[target]}","link":"/leetcode/2024/04/combination-sum-iv/index.html"},{"title":"706. 设计哈希映射","text":"设计哈希映射 难度: easy 原始链接: https://leetcode.cn/problems/design-hashmap 标签: 数组 解法一: 数组go1234567891011121314151617181920212223242526272829303132333435const N = 1000001type MyHashMap struct { data []int}func Constructor() MyHashMap { data := make([]int, N) for i := 0; i &lt; N; i++ { data[i] = -1 } return MyHashMap{ data, }}func (this *MyHashMap) Put(key int, value int) { this.data[key] = value}func (this *MyHashMap) Get(key int) int { return this.data[key]}func (this *MyHashMap) Remove(key int) { this.data[key] = -1}/** * Your MyHashMap object will be instantiated and called as such: * obj := Constructor(); * obj.Put(key,value); * param_2 := obj.Get(key); * obj.Remove(key); */","link":"/leetcode/2024/04/design-hashmap/index.html"},{"title":"705. 设计哈希集合","text":"设计哈希集合 难度: easy 原始链接: https://leetcode.cn/problems/design-hashset 标签: 数组 解法一: 数组go1234567891011121314151617181920212223242526272829type MyHashSet struct { data []bool}func Constructor() MyHashSet { return MyHashSet{ data: make([]bool, 1000001), }}func (this *MyHashSet) Add(key int) { this.data[key] = true}func (this *MyHashSet) Remove(key int) { this.data[key] = false}func (this *MyHashSet) Contains(key int) bool { return this.data[key]}/** * Your MyHashSet object will be instantiated and called as such: * obj := Constructor(); * obj.Add(key); * obj.Remove(key); * param_3 := obj.Contains(key); */","link":"/leetcode/2024/04/design-hashset/index.html"},{"title":"2810. 故障键盘","text":"故障键盘 难度: easy 原始链接: https://leetcode.cn/problems/faulty-keyboard 标签: 双端队列 解法一: 双端队列go1234567891011121314151617181920212223func finalString(s string) string { queues := [][]rune{ []rune{}, []rune{}, } for _, ch := range s { if ch == 'i' { queues[0], queues[1] = queues[1], queues[0] } else { queues[0] = append(queues[0], ch) } } sb := strings.Builder{} n1 := len(queues[0]) n2 := len(queues[1]) for i := n2 - 1; i &gt;= 0; i-- { sb.WriteString(string(queues[1][i])) } for i := 0; i &lt; n1; i++ { sb.WriteString(string(queues[0][i])) } return sb.String()}","link":"/leetcode/2024/04/faulty-keyboard/index.html"},{"title":"1379. 找出克隆二叉树中的相同节点","text":"找出克隆二叉树中的相同节点 难度: easy 原始链接: https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree 标签: 前序遍历 解法一: 前序遍历java123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) { if (original == null) { return null; } else if (original == target) { return cloned; } TreeNode ans = this.getTargetCopy(original.left, cloned.left, target); if (ans != null) { return ans; } return this.getTargetCopy(original.right, cloned.right, target); }}","link":"/leetcode/2024/04/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/index.html"},{"title":"2923. 找到冠军 I","text":"找到冠军 I 难度: easy 原始链接: https://leetcode.cn/problems/find-champion-i 标签: 数组 解法一: O(n ^ 2) 时间复杂度go12345678910111213141516func findChampion(grid [][]int) int { n := len(grid) for i := 0; i &lt; n; i++ { isSuccess := true for j := 0; j &lt; n; j++ { if i != j &amp;&amp; grid[i][j] == 0 { isSuccess = false break } } if isSuccess { return i } } return -1} 解法二: O(n) 时间复杂度go12345678910func findChampion(grid [][]int) int { ans := 0 n := len(grid) for i := 1; i &lt; n; i++ { if grid[i][ans] == 1 { ans = i } } return ans}","link":"/leetcode/2024/04/find-champion-i/index.html"},{"title":"2924. 找到冠军 II","text":"找到冠军 II 难度: medium 原始链接: https://leetcode.cn/problems/find-champion-ii 标签: 图 解法一: 直接遍历go1234567891011121314151617func findChampion(n int, edges [][]int) int { state := make([]bool, n) for _, edge := range edges { state[edge[1]] = true } ans := -1 for i := 0; i &lt; n; i++ { if !state[i] { if ans == -1 { ans = i } else { return -1 } } } return ans}","link":"/leetcode/2024/04/find-champion-ii/index.html"},{"title":"2007. 从双倍数组中还原原数组","text":"从双倍数组中还原原数组 难度: medium 原始链接: https://leetcode.cn/problems/find-original-array-from-doubled-array 标签: 排序, 贪心 解法一: 排序, 贪心go1234567891011121314151617181920func findOriginalArray(changed []int) []int { n := len(changed) sort.Ints(changed) queue := []int{} ans := make([]int, n&gt;&gt;1) i := 0 for _, num := range changed { if len(queue) &gt; 0 &amp;&amp; num == queue[0] { queue = queue[1:] } else { if i == len(ans) { return []int{} } ans[i] = num i++ queue = append(queue, num&lt;&lt;1) } } return ans}","link":"/leetcode/2024/04/find-original-array-from-doubled-array/index.html"},{"title":"2639. 查询网格图中每一列的宽度","text":"查询网格图中每一列的宽度 难度: easy 原始链接: https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid 标签: 数学 解法一: 数学go12345678910111213141516171819202122func findColumnWidth(grid [][]int) []int { m := len(grid) n := len(grid[0]) ans := make([]int, n) for i := 0; i &lt; n; i++ { num := 0 for j := 0; j &lt; m; j++ { num = max(num, max(grid[j][i]/10, -grid[j][i])) } ans[i] = calcWidth(num) + 1 } return ans}func calcWidth(num int) int { count := 0 for num != 0 { count++ num /= 10 } return count}","link":"/leetcode/2024/04/find-the-width-of-columns-of-a-grid/index.html"},{"title":"1052. 爱生气的书店老板","text":"爱生气的书店老板 难度: medium 原始链接: https://leetcode.cn/problems/grumpy-bookstore-owner 标签: 滑动窗口 解法一: 滑动窗口go12345678910111213141516171819202122232425func maxSatisfied(customers []int, grumpy []int, minutes int) int { n := len(customers) sum := 0 saveCustomer := 0 for i := 0; i &lt; minutes; i++ { if grumpy[i] == 1 { saveCustomer += customers[i] } else { sum += customers[i] } } ans := saveCustomer for i := minutes; i &lt; n; i++ { if grumpy[i-minutes] == 1 { saveCustomer -= customers[i-minutes] } if grumpy[i] == 1 { saveCustomer += customers[i] } else { sum += customers[i] } ans = max(ans, saveCustomer) } return ans + sum}","link":"/leetcode/2024/04/grumpy-bookstore-owner/index.html"},{"title":"1702. 修改后的最大二进制字符串","text":"故障键盘 难度: medium 原始链接: https://leetcode.cn/problems/maximum-binary-string-after-change 标签: 贪心 解法一: 贪心go1234567891011121314151617181920func maximumBinaryString(binary string) string { n := len(binary) first := 0 for first &lt; n { if binary[first] != '1' { break } first++ } if first &gt;= n { return binary } oneCount := 0 for i := first; i &lt; n; i++ { if binary[i] == '1' { oneCount++ } } return strings.Repeat(&quot;1&quot;, n-oneCount-1) + &quot;0&quot; + strings.Repeat(&quot;1&quot;, oneCount)}","link":"/leetcode/2024/04/maximum-binary-string-after-change/index.html"},{"title":"2529. 正整数和负整数的最大计数","text":"正整数和负整数的最大计数 难度: easy 原始链接: https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920func maximumCount(nums []int) int { return max(targetMin(nums, 0)+1, len(nums)-targetMin(nums, 1)-1)}func targetMin(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if nums[mid] &gt;= target { right = mid - 1 } else { left = mid } } if nums[left] &gt;= target { return -1 } return left}","link":"/leetcode/2024/04/maximum-count-of-positive-integer-and-negative-integer/index.html"},{"title":"1026. 节点与其祖先之间的最大差值","text":"节点与其祖先之间的最大差值 难度: medium 原始链接: https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func maxAncestorDiff(root *TreeNode) int { var dfs func(node *TreeNode, minVal, maxVal int) int dfs = func(node *TreeNode, minVal, maxVal int) int { if node == nil { return maxVal - minVal } minVal = min(minVal, node.Val) maxVal = max(maxVal, node.Val) return max(dfs(node.Left, minVal, maxVal), dfs(node.Right, minVal, maxVal)) } return dfs(root, root.Val, root.Val)}","link":"/leetcode/2024/04/maximum-difference-between-node-and-ancestor/index.html"},{"title":"2798. 满足目标工作时长的员工数目","text":"满足目标工作时长的员工数目 难度: easy 原始链接: https://leetcode.cn/problems/number-of-employees-who-met-the-target 标签: 一次遍历 解法一: 一次遍历go123456789func numberOfEmployeesWhoMetTarget(hours []int, target int) int { ans := 0 for _, hour := range hours { if hour &gt;= target { ans++ } } return ans} java1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { return (int) Arrays.stream(hours) .filter(hour -&gt; hour &gt;= target) .count(); }}","link":"/leetcode/2024/04/number-of-employees-who-met-the-target/index.html"},{"title":"1146. 快照数组","text":"快照数组 难度: medium 原始链接: https://leetcode.cn/problems/snapshot-array 标签: 二分查找 解法一: 二分查找go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type SnapshotArray struct { version int data [][][]int}func Constructor(length int) SnapshotArray { return SnapshotArray{ version: 0, data: make([][][]int, length), }}func (this *SnapshotArray) Set(index int, val int) { this.data[index] = append(this.data[index], []int{this.version, val})}func (this *SnapshotArray) Snap() int { oldVersion := this.version this.version++ return oldVersion}func (this *SnapshotArray) Get(index int, snap_id int) int { return binarySearch(this.data[index], snap_id)}func binarySearch(arr [][]int, version int) int { if len(arr) == 0 { return 0 } left := 0 right := len(arr) - 1 for left &lt; right { mid := ((right - left + 1) &gt;&gt; 1) + left if arr[mid][0] &gt; version { right = mid - 1 } else { left = mid } } if arr[left][0] &lt;= version { return arr[left][1] } return 0}/** * Your SnapshotArray object will be instantiated and called as such: * obj := Constructor(length); * obj.Set(index,val); * param_2 := obj.Snap(); * param_3 := obj.Get(index,snap_id); */","link":"/leetcode/2024/04/snapshot-array/index.html"},{"title":"1329. 将矩阵按对角线排序","text":"将矩阵按对角线排序 难度: medium 原始链接: https://leetcode.cn/problems/sort-the-matrix-diagonally 标签: 模拟 解法一: 模拟go1234567891011121314151617181920func diagonalSort(mat [][]int) [][]int { m := len(mat) n := len(mat[0]) lists := make([][]int, m+n) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { lists[i-j+n] = append(lists[i-j+n], mat[i][j]) } } for i := m + n - 1; i &gt; 0; i-- { sort.Ints(lists[i]) } for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { mat[i][j] = lists[i-j+n][0] lists[i-j+n] = lists[i-j+n][1:] } } return mat}","link":"/leetcode/2024/04/sort-the-matrix-diagonally/index.html"},{"title":"1600. 王位继承顺序","text":"王位继承顺序 难度: medium 原始链接: https://leetcode.cn/problems/throne-inheritance 标签: 前序遍历 解法一: 前序遍历go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455type ThroneInheritance struct { Root *Node Deads map[string]*Node}type Node struct { Name string IsDead bool Children *[]*Node}func Constructor(kingName string) ThroneInheritance { root := &amp;Node{ Name: kingName, Children: &amp;[]*Node{}, } return ThroneInheritance{ Root: root, Deads: map[string]*Node{ kingName: root, }, }}func (this *ThroneInheritance) Birth(parentName string, childName string) { node := &amp;Node{ Name: childName, Children: &amp;[]*Node{}, } children := this.Deads[parentName].Children *children = append(*children, node) this.Deads[childName] = node}func (this *ThroneInheritance) Death(name string) { this.Deads[name].IsDead = true}func (this *ThroneInheritance) GetInheritanceOrder() []string { ans := []string{} var dfs func(root *Node) dfs = func(root *Node) { if root == nil { return } if !root.IsDead { ans = append(ans, root.Name) } for _, child := range *root.Children { dfs(child) } } dfs(this.Root) return ans} java123456789101112131415161718192021222324252627282930313233343536373839404142434445class ThroneInheritance { private String kingName; private Map&lt;String, List&lt;String&gt;&gt; nodes; private Set&lt;String&gt; deads; public ThroneInheritance(String kingName) { this.kingName = kingName; nodes = new HashMap&lt;&gt;(); deads = new HashSet&lt;&gt;(); } public void birth(String parentName, String childName) { nodes.merge(parentName, Collections.singletonList(childName), (children, newChildren) -&gt; { if (children.size() == 1) { children = new ArrayList&lt;&gt;(children); } children.addAll(newChildren); return children; }); } public void death(String name) { deads.add(name); } public List&lt;String&gt; getInheritanceOrder() { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); this.dfs(kingName, ans); return ans; } private void dfs(String nodeName, List&lt;String&gt; ans) { if (!deads.contains(nodeName)) { ans.add(nodeName); } List&lt;String&gt; nodeNames = nodes.getOrDefault(nodeName, Collections.emptyList()); for (String childName : nodeNames) { this.dfs(childName, ans); } }}","link":"/leetcode/2024/04/throne-inheritance/index.html"},{"title":"2739. 总行驶距离","text":"总行驶距离 难度: easy 原始链接: https://leetcode.cn/problems/total-distance-traveled 标签: 数学 解法一: 数学go123func distanceTraveled(mainTank int, additionalTank int) int { return (mainTank + min((mainTank-1)/4, additionalTank)) * 10}","link":"/leetcode/2024/04/total-distance-traveled/index.html"},{"title":"1491. 去掉最低工资和最高工资后的工资平均值","text":"去掉最低工资和最高工资后的工资平均值 难度: easy 原始链接: https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary 标签: 循环 解法一: 循环go1234567891011func average(salary []int) float64 { minSalary := math.MaxInt maxSalary := math.MinInt sum := 0 for _, num := range salary { sum += num minSalary = min(minSalary, num) maxSalary = max(maxSalary, num) } return float64(sum-minSalary-maxSalary) / float64(len(salary)-2)}","link":"/leetcode/2024/05/average-salary-excluding-the-minimum-and-maximum-salary/index.html"},{"title":"2960. 统计已测试设备","text":"统计已测试设备 难度: easy 原始链接: https://leetcode.cn/problems/count-tested-devices-after-test-operations 标签: 一次遍历 解法一: 一次遍历go123456789func countTestedDevices(batteryPercentages []int) int { ans := 0 for _, batteryPercentage := range batteryPercentages { if batteryPercentage-ans &gt; 0 { ans++ } } return ans}","link":"/leetcode/2024/05/count-tested-devices-after-test-operations/index.html"},{"title":"2903. 找出满足差值条件的下标 I","text":"找出满足差值条件的下标 I 难度: medium 原始链接: https://leetcode.cn/problems/find-indices-with-index-and-value-difference-i 标签: 双层循环 解法一: 双层循环go123456789101112131415161718func findIndices(nums []int, indexDifference int, valueDifference int) []int { n := len(nums) for i := 0; i &lt; n; i++ { for j := i + indexDifference; j &lt; n; j++ { if abs(nums[i]-nums[j]) &gt;= valueDifference { return []int{i, j} } } } return []int{-1, -1}}func abs(num int) int { if num &gt;= 0 { return num } return -num}","link":"/leetcode/2024/05/find-indices-with-index-and-value-difference-i/index.html"},{"title":"2981. 找出出现至少三次的最长特殊子字符串 I","text":"找出出现至少三次的最长特殊子字符串 I 难度: medium 原始链接: https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718192021222324252627func maximumLength(s string) int { numList := make([][]int, 26) n := len(s) count := 0 for i := 0; i &lt; n; i++ { count++ if i == n-1 || s[i] != s[i+1] { numList[s[i]-'a'] = append(numList[s[i]-'a'], count) count = 0 } } ans := 0 for _, list := range numList { if len(list) == 0 { continue } sort.Slice(list, func(i, j int) bool { return list[i] &gt;= list[j] }) list = append(list, 0, 0) ans = max(ans, max(list[0]-2, max(min(list[0]-1, list[1]), list[2]))) } if ans == 0 { return -1 } return ans}","link":"/leetcode/2024/05/find-longest-special-substring-that-occurs-thrice-i/index.html"},{"title":"2982. 找出出现至少三次的最长特殊子字符串 II","text":"找出出现至少三次的最长特殊子字符串 II 难度: medium 原始链接: https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718192021222324252627func maximumLength(s string) int { numList := make([][]int, 26) n := len(s) count := 0 for i := 0; i &lt; n; i++ { count++ if i == n-1 || s[i] != s[i+1] { numList[s[i]-'a'] = append(numList[s[i]-'a'], count) count = 0 } } ans := 0 for _, list := range numList { if len(list) == 0 { continue } sort.Slice(list, func(i, j int) bool { return list[i] &gt;= list[j] }) list = append(list, 0, 0) ans = max(ans, max(list[0]-2, max(min(list[0]-1, list[1]), list[2]))) } if ans == 0 { return -1 } return ans}","link":"/leetcode/2024/05/find-longest-special-substring-that-occurs-thrice-ii/index.html"},{"title":"2965. 找出缺失和重复的数字","text":"找出缺失和重复的数字 难度: easy 原始链接: https://leetcode.cn/problems/find-missing-and-repeated-values 标签: 哈希 解法一: 哈希go12345678910111213141516171819func findMissingAndRepeatedValues(grid [][]int) []int { n := len(grid) countMap := make([]int, n*n+1) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { countMap[grid[i][j]]++ } } zero := 0 two := 0 for i := 1; i &lt;= n*n; i++ { if countMap[i] == 0 { zero = i } else if countMap[i] == 2 { two = i } } return []int{two, zero}}","link":"/leetcode/2024/05/find-missing-and-repeated-values/index.html"},{"title":"2028. 找出缺失的观测数据","text":"找出缺失的观测数据 难度: medium 原始链接: https://leetcode.cn/problems/find-missing-observations 标签: 数学 解法一: 数学go1234567891011121314151617181920func missingRolls(rolls []int, mean int, n int) []int { m := len(rolls) sum := mean * (m + n) curSum := 0 for _, roll := range rolls { curSum += roll } subSum := sum - curSum if subSum &lt; n || subSum &gt; 6*n { return []int{} } ans := make([]int, n) per := subSum / n div := subSum - per*n for i := 0; i &lt; n; i++ { ans[i] = per + min(1, div) div = max(0, div-1) } return ans}","link":"/leetcode/2024/05/find-missing-observations/index.html"},{"title":"2225. 找出输掉零场或一场比赛的玩家","text":"找出输掉零场或一场比赛的玩家 难度: medium 原始链接: https://leetcode.cn/problems/find-players-with-zero-or-one-losses 标签: 哈希, 排序 解法一: 哈希, 排序go123456789101112131415161718func findWinners(matches [][]int) [][]int { loseCount := make(map[int]int) for _, match := range matches { if loseCount[match[0]] == 0 { loseCount[match[0]] = 0 } loseCount[match[1]]++ } ans := make([][]int, 2) for key, val := range loseCount { if val &lt;= 1 { ans[val] = append(ans[val], key) } } sort.Ints(ans[0]) sort.Ints(ans[1]) return ans}","link":"/leetcode/2024/05/find-players-with-zero-or-one-losses/index.html"},{"title":"2831. 找出最长等值子数组","text":"找出最长等值子数组 难度: medium 原始链接: https://leetcode.cn/problems/find-the-longest-equal-subarray 标签: 滑动窗口 解法一: 滑动窗口go1234567891011121314151617181920func longestEqualSubarray(nums []int, k int) int { numListMap := make(map[int][]int) for i, num := range nums { numListMap[num] = append(numListMap[num], i) } ans := 0 for _, list := range numListMap { n := len(list) left := 0 right := 0 for right &lt; n { for list[right]-list[left]-right+left &gt; k { left++ } ans = max(ans, right-left+1) right++ } } return ans}","link":"/leetcode/2024/05/find-the-longest-equal-subarray/index.html"},{"title":"2769. 找出最大的可达成数字","text":"找出最大的可达成数字 难度: easy 原始链接: https://leetcode.cn/problems/find-the-maximum-achievable-number 标签: 直接计算 解法一: 直接计算go123func theMaximumAchievableX(num int, t int) int { return num + (t &lt;&lt; 1)}","link":"/leetcode/2024/05/find-the-maximum-achievable-number/index.html"},{"title":"2644. 找出可整除性得分最大的整数","text":"找出可整除性得分最大的整数 难度: easy 原始链接: https://leetcode.cn/problems/find-the-maximum-divisibility-score 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617func maxDivScore(nums []int, divisors []int) int { ans := divisors[0] maxCount := 0 for _, divisor := range divisors { curCount := 0 for _, num := range nums { if num%divisor == 0 { curCount++ } } if curCount &gt; maxCount || curCount == maxCount &amp;&amp; ans &gt; divisor { maxCount = curCount ans = divisor } } return ans}","link":"/leetcode/2024/05/find-the-maximum-divisibility-score/index.html"},{"title":"1673. 找出最具竞争力的子序列","text":"找出最具竞争力的子序列 难度: medium 原始链接: https://leetcode.cn/problems/find-the-most-competitive-subsequence 标签: 单调栈 解法一: 单调栈go12345678910111213func mostCompetitive(nums []int, k int) []int { stack := []int{} n := len(nums) for i, num := range nums { for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] &gt; num &amp;&amp; (len(stack)-1+n-i) &gt;= k { stack = stack[:len(stack)-1] } if len(stack) &lt; k { stack = append(stack, num) } } return stack}","link":"/leetcode/2024/05/find-the-most-competitive-subsequence/index.html"},{"title":"2951. 找出峰值","text":"找出峰值 难度: easy 原始链接: https://leetcode.cn/problems/find-the-peaks 标签: 循环 解法一: 循环go1234567891011func findPeaks(mountain []int) []int { ans := []int{} n := len(mountain) for i := 1; i &lt; n-1; i++ { if mountain[i] &gt; mountain[i-1] &amp;&amp; mountain[i] &gt; mountain[i+1] { ans = append(ans, i) i++ } } return ans}","link":"/leetcode/2024/05/find-the-peaks/index.html"},{"title":"1535. 找出数组游戏的赢家","text":"找出数组游戏的赢家 难度: medium 原始链接: https://leetcode.cn/problems/find-the-winner-of-an-array-game 标签: 模拟 解法一: 模拟go12345678910111213func getWinner(arr []int, k int) int { n := len(arr) countMap := make(map[int]int, n) cur := arr[0] for i := 1; i &lt; n; i++ { cur = max(cur, arr[i]) countMap[cur]++ if countMap[cur] &gt;= k { return cur } } return cur}","link":"/leetcode/2024/05/find-the-winner-of-an-array-game/index.html"},{"title":"1953. 你可以工作的最大周数","text":"你可以工作的最大周数 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work 标签: 数学 解法一: 数学go12345678910111213func numberOfWeeks(milestones []int) int64 { maxVal := int64(0) sum := int64(0) for _, milestone := range milestones { maxVal = max(maxVal, int64(milestone)) sum += int64(milestone) } sum -= maxVal if sum+1 &gt;= maxVal { return sum + maxVal } return (sum &lt;&lt; 1) + 1}","link":"/leetcode/2024/05/maximum-number-of-weeks-for-which-you-can-work/index.html"},{"title":"2391. 收集垃圾的最少总时间","text":"收集垃圾的最少总时间 难度: medium 原始链接: https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617181920func garbageCollection(garbage []string, travel []int) int { n := len(garbage) ans := 0 cur := 0 countMap := map[byte]int{ 'M': 0, 'P': 0, 'G': 0, } travel = append(travel, 0) for i := 0; i &lt; n; i++ { m := len(garbage[i]) ans += m for j := 0; j &lt; m; j++ { countMap[garbage[i][j]] = cur } cur += travel[i] } return ans + countMap['M'] + countMap['P'] + countMap['G']}","link":"/leetcode/2024/05/minimum-amount-of-time-to-collect-garbage/index.html"},{"title":"2244. 完成所有任务需要的最少轮数","text":"完成所有任务需要的最少轮数 难度: medium 原始链接: https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks 标签: 贪心 解法一: 贪心go1234567891011121314func minimumRounds(tasks []int) int { countMap := make(map[int]int, len(tasks)) for _, task := range tasks { countMap[task]++ } ans := 0 for _, count := range countMap { if count == 1 { return -1 } ans += (count + 2) / 3 } return ans}","link":"/leetcode/2024/05/minimum-rounds-to-complete-all-tasks/index.html"},{"title":"826. 安排工作以达到最大收益","text":"安排工作以达到最大收益 难度: medium 原始链接: https://leetcode.cn/problems/most-profit-assigning-work 标签: 排序 解法一: 排序go1234567891011121314151617181920212223242526272829func maxProfitAssignment(difficulty []int, profit []int, worker []int) int { type work struct { d int p int } n := len(difficulty) arr := make([]work, n) for i := 0; i &lt; n; i++ { arr[i] = work{ d: difficulty[i], p: profit[i], } } sort.Slice(arr, func(i, j int) bool { return arr[i].d &lt;= arr[j].d }) sort.Ints(worker) ans := 0 i := 0 maxVal := 0 for _, w := range worker { for i &lt; n &amp;&amp; w &gt;= arr[i].d { maxVal = max(maxVal, arr[i].p) i++ } ans += maxVal } return ans}","link":"/leetcode/2024/05/most-profit-assigning-work/index.html"},{"title":"994. 腐烂的橘子","text":"腐烂的橘子 难度: medium 原始链接: https://leetcode.cn/problems/rotting-oranges 标签: 广度优先遍历 解法一: 广度优先遍历go123456789101112131415161718192021222324252627282930313233343536373839404142434445func orangesRotting(grid [][]int) int { m := len(grid) n := len(grid[0]) queue := []int{} fresh := 0 for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { if grid[i][j] == 1 { fresh++ } else if grid[i][j] == 2 { queue = append(queue, i*n+j) } } } directions := [][]int{ {-1, 0}, {0, 1}, {1, 0}, {0, -1}, } ans := 0 for len(queue) &gt; 0 &amp;&amp; fresh &gt; 0 { size := len(queue) for i := 0; i &lt; size; i++ { sum := queue[i] row := sum / n col := sum - row*n for _, direction := range directions { newRow := row + direction[0] newCol := col + direction[1] if newRow &gt;= 0 &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; n &amp;&amp; grid[newRow][newCol] == 1 { fresh-- grid[newRow][newCol] = 2 queue = append(queue, newRow*n+newCol) } } } queue = queue[size:] ans++ } if fresh &gt; 0 { return -1 } return ans}","link":"/leetcode/2024/05/rotting-oranges/index.html"},{"title":"2462. 雇佣 K 位工人的总代价","text":"雇佣 K 位工人的总代价 难度: medium 原始链接: https://leetcode.cn/problems/total-cost-to-hire-k-workers 标签: 优先级队列 解法一: 优先级队列java123456789101112131415161718192021222324252627282930class Solution { public long totalCost(int[] costs, int k, int candidates) { PriorityQueue&lt;Integer&gt; leftQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); PriorityQueue&lt;Integer&gt; rightQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num1 - num2); int n = costs.length; int left = 0; int right = n - 1; for (int i = 0; i &lt; candidates &amp;&amp; left &lt;= right; i++) { leftQueue.offer(costs[left++]); if (left &lt;= right) { rightQueue.offer(costs[right--]); } } long ans = 0L; while (k-- &gt; 0) { if (leftQueue.isEmpty() || !rightQueue.isEmpty() &amp;&amp; leftQueue.peek() &gt; rightQueue.peek()) { ans += rightQueue.poll(); while (left &lt;= right &amp;&amp; rightQueue.size() &lt; candidates) { rightQueue.offer(costs[right--]); } } else { ans += leftQueue.poll(); while (left &lt;= right &amp;&amp; leftQueue.size() &lt; candidates) { leftQueue.offer(costs[left++]); } } } return ans; }}","link":"/leetcode/2024/05/total-cost-to-hire-k-workers/index.html"},{"title":"LeetCode 竞赛分 1800","text":"LeetCode 竞赛分 1800 纪念","link":"/leetcode/2024/05/version1.0.0/index.html"},{"title":"2105. 给植物浇水 II","text":"给植物浇水 II 难度: medium 原始链接: https://leetcode.cn/problems/watering-plants-ii 标签: 贪心 解法一: 贪心go12345678910111213141516171819202122232425262728func minimumRefill(plants []int, capacityA int, capacityB int) int { a := capacityA b := capacityB ans := 0 left := 0 right := len(plants) - 1 for left &lt;= right { if left == right { if a &lt; plants[left] &amp;&amp; b &lt; plants[left] { ans++ } break } if a &lt; plants[left] { ans++ a = capacityA } a -= plants[left] if b &lt; plants[right] { ans++ b = capacityB } b -= plants[right] left++ right-- } return ans}","link":"/leetcode/2024/05/watering-plants-ii/index.html"},{"title":"2079. 给植物浇水","text":"给植物浇水 难度: medium 原始链接: https://leetcode.cn/problems/watering-plants 标签: 贪心 解法一: 贪心go12345678910111213func wateringPlants(plants []int, capacity int) int { cur := capacity ans := 0 for i, plant := range plants { if plant &gt; cur { ans += i &lt;&lt; 1 cur = capacity } ans++ cur -= plant } return ans}","link":"/leetcode/2024/05/watering-plants/index.html"},{"title":"LCP 61. 气温变化趋势","text":"气温变化趋势 难度: easy 原始链接: https://leetcode.cn/problems/6CE719 标签: 循环 解法一: 循环go1234567891011121314151617181920212223func temperatureTrend(temperatureA []int, temperatureB []int) int { ans := 0 cur := 0 n := len(temperatureA) for i := 1; i &lt; n; i++ { if compare(temperatureA[i], temperatureA[i-1]) == compare(temperatureB[i], temperatureB[i-1]) { cur++ ans = max(ans, cur) } else { cur = 0 } } return ans}func compare(num1, num2 int) int { if num1 == num2 { return 0 } else if num1 &gt; num2 { return 1 } return -1}","link":"/leetcode/2024/06/6CE719/index.html"},{"title":"2806. 取整购买后的账户余额","text":"取整购买后的账户余额 难度: easy 原始链接: https://leetcode.cn/problems/account-balance-after-rounded-purchase 标签: 四舍五入 解法一: 四舍五入go123func accountBalanceAfterPurchase(purchaseAmount int) int { return 100 - ((purchaseAmount+5)/10)*10}","link":"/leetcode/2024/06/account-balance-after-rounded-purchase/index.html"},{"title":"2288. 价格减免","text":"价格减免 难度: medium 原始链接: https://leetcode.cn/problems/apply-discount-to-prices 标签: 模拟 解法一: 模拟go123456789101112131415161718192021222324func discountPrices(sentence string, discount int) string { strArr := strings.Split(sentence, &quot; &quot;) n := len(strArr) for i := 0; i &lt; n; i++ { if checkMoney(strArr[i]) { num, _ := strconv.Atoi(strArr[i][1:]) strArr[i] = fmt.Sprintf(&quot;$%.2f&quot;, float64(num*100-num*discount)/100.0) } } return strings.Join(strArr, &quot; &quot;)}func checkMoney(str string) bool { n := len(str) if n &lt; 2 || str[0] != '$' { return false } for i := 1; i &lt; n; i++ { if str[i] &lt; '0' || str[i] &gt; '9' { return false } } return true}","link":"/leetcode/2024/06/apply-discount-to-prices/index.html"},{"title":"419. 甲板上的战舰","text":"甲板上的战舰 难度: medium 原始链接: https://leetcode.cn/problems/battleships-in-a-board 标签: 脑筋急转弯 解法一: 脑筋急转弯go123456789101112131415func countBattleships(board [][]byte) int { ans := 0 rLen := len(board) cLen := len(board[0]) for r := 0; r &lt; rLen; r++ { for c := 0; c &lt; cLen; c++ { if board[r][c] == 'X' &amp;&amp; (r == 0 || r &gt; 0 &amp;&amp; board[r-1][c] == '.') &amp;&amp; (c == 0 || c &gt; 0 &amp;&amp; board[r][c-1] == '.') { ans++ } } } return ans}","link":"/leetcode/2024/06/battleships-in-a-board/index.html"},{"title":"881. 救生艇","text":"救生艇 难度: medium 原始链接: https://leetcode.cn/problems/boats-to-save-people 标签: 贪心 解法一: 完全贪心java1234567891011121314151617class Solution { public int numRescueBoats(int[] people, int limit) { Arrays.sort(people); int n = people.length; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;((num1, num2) -&gt; num2 - num1); int ans = 0; for (int i = n - 1; i &gt;= 0; i--) { if (!priorityQueue.isEmpty() &amp;&amp; people[i] &lt;= priorityQueue.peek()) { priorityQueue.poll(); } else { ans++; priorityQueue.offer(limit - people[i]); } } return ans; }} 解法二: 贪心go123456789101112131415func numRescueBoats(people []int, limit int) int { sort.Ints(people) n := len(people) left := 0 right := n - 1 ans := 0 for left &lt;= right { if people[left]+people[right] &lt;= limit { left++ } right-- ans++ } return ans}","link":"/leetcode/2024/06/boats-to-save-people/index.html"},{"title":"3067. 在带权树网络中统计可连接服务器对数目","text":"分糖果 难度: medium 原始链接: https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334func countPairsOfConnectableServers(edges [][]int, signalSpeed int) []int { n := len(edges) + 1 grid := make([][][]int, n) for _, edge := range edges { grid[edge[0]] = append(grid[edge[0]], []int{edge[1], edge[2]}) grid[edge[1]] = append(grid[edge[1]], []int{edge[0], edge[2]}) } var dfs func(int, int, int) int dfs = func(cur, parent, sum int) int { count := 0 if sum%signalSpeed == 0 { count++ } for _, node := range grid[cur] { if node[0] != parent { count += dfs(node[0], cur, sum+node[1]) } } return count } ans := make([]int, n) for i := 0; i &lt; n; i++ { if len(grid[i]) &lt;= 1 { continue } sum := 0 for _, node := range grid[i] { count := dfs(node[0], i, node[1]) ans[i] += count * sum sum += count } } return ans}","link":"/leetcode/2024/06/count-pairs-of-connectable-servers-in-a-weighted-tree-network/index.html"},{"title":"520. 检测大写字母","text":"检测大写字母 难度: easy 原始链接: https://leetcode.cn/problems/detect-capital 标签: 模拟 解法一: 模拟go12345678910111213141516func detectCapitalUse(word string) bool { n := len(word) // true：大写；false：小写 fisrtUpper := word[0] &lt;= 'Z' pre := false for i := 1; i &lt; n; i++ { if i == 1 { pre = word[i] &lt;= 'Z' continue } if pre != (word[i] &lt;= 'Z') { return false } } return fisrtUpper || !fisrtUpper &amp;&amp; !pre}","link":"/leetcode/2024/06/detect-capital/index.html"},{"title":"2928. 给小朋友们分糖果 I","text":"给小朋友们分糖果 I 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies-among-children-i 标签: 数学 解法一: 数学go12345678910111213func distributeCandies(n int, limit int) int { ans := 0 for i := 0; i &lt;= n &amp;&amp; i &lt;= limit; i++ { rest := n - i if rest &gt; (limit &lt;&lt; 1) { continue } maxVal := min(limit, rest) minVal := max(0, rest-limit) ans += maxVal - minVal + 1 } return ans}","link":"/leetcode/2024/06/distribute-candies-among-children-i/index.html"},{"title":"1103. 分糖果 II","text":"分糖果 II 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies-to-people 标签: 模拟 解法一: 哈希go12345678func distributeCandies(candies int, num_people int) []int { ans := make([]int, num_people) for i := 0; candies &gt; 0; i++ { ans[i%num_people] += min(i+1, candies) candies -= i + 1 } return ans}","link":"/leetcode/2024/06/distribute-candies-to-people/index.html"},{"title":"575. 分糖果","text":"分糖果 难度: easy 原始链接: https://leetcode.cn/problems/distribute-candies 标签: 哈希 解法一: 哈希go12345678func distributeCandies(candyType []int) int { n := len(candyType) typeHash := make(map[int]bool) for i := 0; i &lt; n; i++ { typeHash[candyType[i]] = true } return min(n&gt;&gt;1, len(typeHash))}","link":"/leetcode/2024/06/distribute-candies/index.html"},{"title":"2734. 执行子串操作后的字典序最小字符串","text":"执行子串操作后的字典序最小字符串 难度: medium 原始链接: https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation 标签: 贪心 解法一: 贪心go123456789101112131415func smallestString(s string) string { ans := []byte(s) n := len(s) for i := 0; i &lt; n; i++ { if ans[i] != 'a' { for i &lt; n &amp;&amp; ans[i] != 'a' { ans[i]-- i++ } return string(ans) } } ans[n-1] = 'z' return string(ans)}","link":"/leetcode/2024/06/lexicographically-smallest-string-after-substring-operation/index.html"},{"title":"522. 最长特殊序列 II","text":"最长特殊序列 II 难度: medium 原始链接: https://leetcode.cn/problems/longest-uncommon-subsequence-ii 标签: 枚举 解法一: 枚举go12345678910111213141516171819202122232425262728293031323334353637383940func findLUSlength(strs []string) int { ans := -1 for i, str1 := range strs { n := len(str1) if ans &gt;= n { continue } isUnique := true for j, str2 := range strs { if i != j &amp;&amp; check(str1, str2) { isUnique = false break } } if isUnique { ans = max(ans, n) } } return ans}func check(str1, str2 string) bool { n1 := len(str1) n2 := len(str2) if n1 &gt; n2 { return false } i1 := 0 i2 := 0 for i1 &lt; n1 { if i2 &gt;= n2 { return false } if str1[i1] == str2[i2] { i1++ } i2++ } return true}","link":"/leetcode/2024/06/longest-uncommon-subsequence-ii/index.html"},{"title":"2779. 数组的最大美丽值","text":"数组的最大美丽值 难度: medium 原始链接: https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation 标签: 滑动窗口 解法一: 滑动窗口go123456789101112131415func maximumBeauty(nums []int, k int) int { sort.Ints(nums) left := 0 right := 0 n := len(nums) ans := 0 for right &lt; n { for left &lt;= right &amp;&amp; nums[right]-nums[left] &gt; (k&lt;&lt;1) { left++ } ans = max(ans, right-left+1) right++ } return ans}","link":"/leetcode/2024/06/maximum-beauty-of-an-array-after-applying-operation/index.html"},{"title":"3038. 相同分数的最大操作数目 I","text":"相同分数的最大操作数目 I 难度: easy 原始链接: https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i 标签: 模拟 解法一: 模拟go123456789101112func maxOperations(nums []int) int { n := len(nums) ans := 1 sum := nums[0] + nums[1] for i := 3; i &lt; n; i += 2 { if nums[i]+nums[i-1] != sum { break } ans++ } return ans}","link":"/leetcode/2024/06/maximum-number-of-operations-with-the-same-score-i/index.html"},{"title":"3040. 相同分数的最大操作数目 II","text":"相同分数的最大操作数目 II 难度: medium 原始链接: https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii 标签: 递归 解法一: 递归go12345678910111213141516171819202122232425262728293031323334353637func maxOperations(nums []int) int { n := len(nums) cache := make([][]int, n) for i := range cache { cache[i] = make([]int, n) for j := range cache[i] { cache[i][j] = -1 } } return max(dfs(nums, nums[0]+nums[1], 0, 2, n-1, cache), max(dfs(nums, nums[n-2]+nums[n-1], 0, 0, n-3, cache), dfs(nums, nums[0]+nums[n-1], 0, 1, n-2, cache))) + 1}func dfs(nums []int, sum, count, left, right int, cache [][]int) int { if left &gt;= right { return 0 } if cache[left][right] != -1 { return cache[left][right] } curCount := 0 // 前两个元素 if sum == nums[left]+nums[left+1] { curCount = max(curCount, 1+dfs(nums, sum, count, left+2, right, cache)) } // 最后两个元素 if sum == nums[right]+nums[right-1] { curCount = max(curCount, 1+dfs(nums, sum, count, left, right-2, cache)) } // 前后两个元素 if sum == nums[left]+nums[right] { curCount = max(curCount, 1+dfs(nums, sum, count, left+1, right-1, cache)) } cache[left][right] = count + curCount return cache[left][right]}","link":"/leetcode/2024/06/maximum-number-of-operations-with-the-same-score-ii/index.html"},{"title":"2713. 矩阵中严格递增的单元格数","text":"矩阵中严格递增的单元格数 难度: hard 原始链接: https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix 标签: 动态规划 解法一: 动态规划go1234567891011121314151617181920212223242526272829303132333435func maxIncreasingCells(mat [][]int) int { type point struct { x int y int } m := len(mat) n := len(mat[0]) points := make(map[int][]point) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { points[mat[i][j]] = append(points[mat[i][j]], point{ x: i, y: j, }) } } pointKeys := make([]int, 0, len(points)) for key := range points { pointKeys = append(pointKeys, key) } slices.Sort(pointKeys) maxRows := make([]int, m) maxCols := make([]int, n) for _, key := range pointKeys { maxNums := make([]int, len(points[key])) for i, point := range points[key] { maxNums[i] = max(maxRows[point.x], maxCols[point.y]) + 1 } for i, point := range points[key] { maxRows[point.x] = max(maxRows[point.x], maxNums[i]) maxCols[point.y] = max(maxCols[point.y], maxNums[i]) } } return slices.Max(maxRows)}","link":"/leetcode/2024/06/maximum-strictly-increasing-cells-in-a-matrix/index.html"},{"title":"503. 下一个更大元素 II","text":"下一个更大元素 II 难度: medium 原始链接: https://leetcode.cn/problems/next-greater-element-ii 标签: 单调栈 解法一: 单调栈go12345678910111213141516func nextGreaterElements(nums []int) []int { n := len(nums) ans := make([]int, n) for i := 0; i &lt; n; i++ { ans[i] = -1 } stack := []int{} for i := 0; i &lt; (n &lt;&lt; 1); i++ { for len(stack) &gt; 0 &amp;&amp; nums[stack[len(stack)-1]%n] &lt; nums[i%n] { ans[stack[len(stack)-1]%n] = nums[i%n] stack = stack[:len(stack)-1] } stack = append(stack, i) } return ans}","link":"/leetcode/2024/06/next-greater-element-ii/index.html"},{"title":"2748. 美丽下标对的数目","text":"最长特殊序列 II 难度: easy 原始链接: https://leetcode.cn/problems/number-of-beautiful-pairs 标签: 哈希 解法一: 哈希go12345678910111213141516171819202122232425func countBeautifulPairs(nums []int) int { ans := 0 countArr := make([]int, 10) for _, num := range nums { num1 := num % 10 for j := 1; j &lt; 10; j++ { if countArr[j] &gt; 0 &amp;&amp; gcd(j, num1) == 1 { ans += countArr[j] } } num2 := num for num2 &gt;= 10 { num2 /= 10 } countArr[num2]++ } return ans}func gcd(num1, num2 int) int { if num2 == 0 { return num1 } return gcd(num2, num1%num2)}","link":"/leetcode/2024/06/number-of-beautiful-pairs/index.html"},{"title":"2710. 移除字符串中的尾随零","text":"最长特殊序列 II 难度: easy 原始链接: https://leetcode.cn/problems/remove-trailing-zeros-from-a-string 标签: 模拟 解法一: 模拟go1234567func removeTrailingZeros(num string) string { i := len(num) - 1 for i &gt; 0 &amp;&amp; num[i] == '0' { i-- } return num[:i+1]}","link":"/leetcode/2024/06/remove-trailing-zeros-from-a-string/index.html"},{"title":"2938. 区分黑球与白球","text":"区分黑球与白球 难度: medium 原始链接: https://leetcode.cn/problems/separate-black-and-white-balls 标签: 双指针 解法一: 双指针go12345678910111213141516171819202122func minimumSteps(s string) int64 { n := len(s) bytes := []byte(s) left := n - 1 right := n - 1 ans := int64(0) for { for right &gt;= 0 &amp;&amp; bytes[right] == '1' { right-- } left = min(left, right-1) for left &gt;= 0 &amp;&amp; bytes[left] == '0' { left-- } if left &lt; 0 { break } bytes[left], bytes[right] = bytes[right], bytes[left] ans += int64(right - left) } return ans} 解法二: 逆向思维go123456789101112func minimumSteps(s string) int64 { ans := int64(0) sum := 0 for _, ch := range s { if ch == '1' { sum++ } else { ans += int64(sum) } } return ans}","link":"/leetcode/2024/06/separate-black-and-white-balls/index.html"},{"title":"494. 目标和","text":"目标和 难度: medium 原始链接: https://leetcode.cn/problems/target-sum 标签: 深度优先遍历 解法一: 深度优先遍历go123456789101112131415161718func findTargetSumWays(nums []int, target int) int { // f(i) = nums[i] + f(i - 1) // f(i) = -nums[i] + f(i - 1) ans := 0 var dfs func(int, int) dfs = func(i, cur int) { if i &lt; 0 { if cur == 0 { ans++ } return } dfs(i-1, cur+nums[i]) dfs(i-1, cur-nums[i]) } dfs(len(nums)-1, target) return ans}","link":"/leetcode/2024/06/target-sum/index.html"},{"title":"721. 账户合并","text":"账户合并 难度: medium 原始链接: https://leetcode.cn/problems/accounts-merge 标签: 并查集, 深度优先遍历 解法一: 并查集go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071func accountsMerge(accounts [][]string) [][]string { n := len(accounts) unionFind := newUnionFind(n) mailGroup := make(map[string]int) for i, account := range accounts { for _, mail := range account[1:] { if groupIndex, ok := mailGroup[mail]; ok { unionFind.Union(groupIndex, i) } else { mailGroup[mail] = i } } } groupMail := make(map[int]map[string]bool) visit := make([]bool, n) for i, account := range accounts { if visit[i] { continue } visit[i] = true root := unionFind.Find(i) if len(groupMail[root]) == 0 { groupMail[root] = make(map[string]bool) } for _, mail := range account[1:] { groupMail[root][mail] = true } } ans := make([][]string, 0, len(groupMail)) for i, mails := range groupMail { elements := make([]string, 0, len(mails)+1) elements = append(elements, accounts[i][0]) for mail := range mails { elements = append(elements, mail) } sort.Strings(elements[1:]) ans = append(ans, elements) } return ans}type UnionFind struct { parent []int}func newUnionFind(n int) *UnionFind { parent := make([]int, n) for i := 0; i &lt; n; i++ { parent[i] = i } return &amp;UnionFind{ parent, }}func (unionFind *UnionFind) Find(i int) int { if unionFind.parent[i] != i { unionFind.parent[i] = unionFind.Find(unionFind.parent[i]) } return unionFind.parent[i]}func (unionFind *UnionFind) Union(i, j int) bool { rootI := unionFind.Find(i) rootJ := unionFind.Find(j) if rootI == rootJ { return false } unionFind.parent[rootI] = rootJ return true} 解法二: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334353637383940func accountsMerge(accounts [][]string) [][]string { mails := make(map[string][]int) for i, account := range accounts { for _, mail := range account[1:] { mails[mail] = append(mails[mail], i) } } n := len(accounts) visit := make([]bool, n) set := make(map[string]bool) var dfs func(int) dfs = func(i int) { if visit[i] { return } visit[i] = true for _, mail := range accounts[i][1:] { set[mail] = true for _, j := range mails[mail] { dfs(j) } } } ans := [][]string{} for i := range n { if visit[i] { continue } clear(set) dfs(i) curMails := make([]string, 0, len(set)) curMails = append(curMails, accounts[i][0]) for mail := range set { curMails = append(curMails, mail) } sort.Strings(curMails[1:]) ans = append(ans, curMails) } return ans}","link":"/leetcode/2024/07/accounts-merge/index.html"},{"title":"682. 棒球比赛","text":"棒球比赛 难度: easy 原始链接: https://leetcode.cn/problems/baseball-game 标签: 栈 解法一: 栈go12345678910111213141516171819202122func calPoints(operations []string) int { stack := []int{} ans := 0 for _, operation := range operations { switch operation { case &quot;+&quot;: stack = append(stack, stack[len(stack)-2]+stack[len(stack)-1]) ans += stack[len(stack)-1] case &quot;D&quot;: stack = append(stack, stack[len(stack)-1]&lt;&lt;1) ans += stack[len(stack)-1] case &quot;C&quot;: ans -= stack[len(stack)-1] stack = stack[:len(stack)-1] default: num, _ := strconv.Atoi(operation) stack = append(stack, num) ans += num } } return ans}","link":"/leetcode/2024/07/baseball-game/index.html"},{"title":"1958. 检查操作是否合法","text":"检查操作是否合法 难度: medium 原始链接: https://leetcode.cn/problems/check-if-move-is-legal 标签: 枚举 解法一: 枚举go1234567891011121314151617181920212223242526272829303132333435func calcClean(board [][]byte, rMove int, cMove int, color byte) int { m, n := len(board), len(board[0]) directions := []struct { x int y int }{ {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, } ans := 0 for _, direction := range directions { x := rMove + direction.x y := cMove + direction.y if x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] == '.' || board[x][y] == color { continue } cur := 1 for x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; board[x][y] != '.' { if board[x][y] == color { ans += cur break } cur++ x += direction.x y += direction.y } } return ans}","link":"/leetcode/2024/07/check-if-move-is-legal/index.html"},{"title":"3101. 交替子数组计数","text":"交替子数组计数 难度: medium 原始链接: https://leetcode.cn/problems/count-alternating-subarrays 标签: 双指针 解法一: 双指针go123456789101112131415func countAlternatingSubarrays(nums []int) int64 { n := len(nums) ans := int64(n) i := 0 j := 1 for j &lt; n { if nums[j] != nums[j-1] { ans += int64(j - i) } else { i = j } j++ } return ans}","link":"/leetcode/2024/07/count-alternating-subarrays/index.html"},{"title":"2970. 统计移除递增子数组的数目 I","text":"统计移除递增子数组的数目 I 难度: easy 原始链接: https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i 标签: 双指针 解法一: 双指针go12345678910111213141516171819202122232425262728func incremovableSubarrayCount(nums []int) int { n := len(nums) ans := 0 for i := 0; i &lt; n; i++ { for j := i; j &lt; n; j++ { isSucess := true preNum := -1 for k := 0; k &lt; i; k++ { if nums[k] &lt;= preNum { isSucess = false break } preNum = nums[k] } for k := j + 1; k &lt; n; k++ { if nums[k] &lt;= preNum { isSucess = false break } preNum = nums[k] } if isSucess { ans++ } } } return ans}","link":"/leetcode/2024/07/count-the-number-of-incremovable-subarrays-i/index.html"},{"title":"2101. 引爆最多的炸弹","text":"引爆最多的炸弹 难度: medium 原始链接: https://leetcode.cn/problems/detonate-the-maximum-bombs 标签: 深度优先遍历 解法一: 深度优先遍历go12345678910111213141516171819202122232425262728293031323334func maximumDetonation(bombs [][]int) int { n := len(bombs) grid := make([][]int, n) for i, bomb1 := range bombs { x := bomb1[0] y := bomb1[1] r := bomb1[2] for j, bomb2 := range bombs { distanceX := x - bomb2[0] distanceY := y - bomb2[1] if distanceX*distanceX+distanceY*distanceY &lt;= r*r { grid[i] = append(grid[i], j) } } } var dfs func(int, []bool) int dfs = func(i int, visit []bool) int { if visit[i] { return 0 } ans := 1 visit[i] = true for _, j := range grid[i] { ans += dfs(j, visit) } return ans } ans := 0 for i := 0; i &lt; n; i++ { visit := make([]bool, n) ans = max(ans, dfs(i, visit)) } return ans}","link":"/leetcode/2024/07/detonate-the-maximum-bombs/index.html"},{"title":"2961. 双模幂运算","text":"双模幂运算 难度: medium 原始链接: https://leetcode.cn/problems/double-modular-exponentiation 标签: 快速幂 解法一: 快速幂go123456789101112131415161718192021222324func getGoodIndices(variables [][]int, target int) []int { ans := []int{} for i, variable := range variables { a := variable[0] b := variable[1] c := variable[2] m := variable[3] if quickPow(quickPow(a, b, 10), c, m) == target { ans = append(ans, i) } } return ans}func quickPow(num, pow, mod int) int { if pow == 0 { return 1 } half := quickPow(num, pow&gt;&gt;1, mod) if (pow &amp; 1) == 0 { return (half * half) % mod } return (half * half * num) % mod}","link":"/leetcode/2024/07/double-modular-exponentiation/index.html"},{"title":"2956. 找到两个数组中的公共元素","text":"找到两个数组中的公共元素 难度: easy 原始链接: https://leetcode.cn/problems/find-common-elements-between-two-arrays 标签: 哈希 解法一: 哈希go1234567891011121314151617181920212223func findIntersectionValues(nums1 []int, nums2 []int) []int { set1 := make(map[int]bool, len(nums1)) set2 := make(map[int]bool, len(nums2)) for _, num := range nums1 { set1[num] = true } for _, num := range nums2 { set2[num] = true } count1 := 0 for _, num := range nums1 { if set2[num] { count1++ } } count2 := 0 for _, num := range nums2 { if set1[num] { count2++ } } return []int{count1, count2}}","link":"/leetcode/2024/07/find-common-elements-between-two-arrays/index.html"},{"title":"3011. 判断一个数组是否可以变为有序","text":"修改矩阵 难度: medium 原始链接: https://leetcode.cn/problems/find-if-array-can-be-sorted 标签: 循环 解法一: 循环go1234567891011121314151617181920212223242526272829func canSortArray(nums []int) bool { preBit := 0 preNum := 0 curNum := 0 for _, num := range nums { if num &lt; preNum { return false } curBit := calcBitNum(num) if curBit != preBit { if num &lt; curNum { return false } preBit = curBit preNum = curNum } curNum = max(curNum, num) } return true}func calcBitNum(num int) int { count := 0 for num != 0 { count++ num &amp;= num - 1 } return count}","link":"/leetcode/2024/07/find-if-array-can-be-sorted/index.html"},{"title":"724. 寻找数组的中心下标","text":"寻找数组的中心下标 难度: easy 原始链接: https://leetcode.cn/problems/find-pivot-index 标签: 前缀和 解法一: 前缀和go123456789101112131415func pivotIndex(nums []int) int { sum := 0 for _, num := range nums { sum += num } leftSum := 0 for i, num := range nums { sum -= num if leftSum == sum { return i } leftSum += num } return -1}","link":"/leetcode/2024/07/find-pivot-index/index.html"},{"title":"2740. 找出分区值","text":"找出分区值 难度: medium 原始链接: https://leetcode.cn/problems/find-the-value-of-the-partition 标签: 排序, 贪心 解法一: 排序, 贪心go123456789func findValueOfPartition(nums []int) int { n := len(nums) sort.Ints(nums) ans := math.MaxInt for i := 1; i &lt; n; i++ { ans = min(ans, nums[i]-nums[i-1]) } return ans}","link":"/leetcode/2024/07/find-the-value-of-the-partition/index.html"},{"title":"3099. 哈沙德数","text":"哈沙德数 难度: easy 原始链接: https://leetcode.cn/problems/harshad-number 标签: 数学 解法一: 数学go12345678910111213141516func sumOfTheDigitsOfHarshadNumber(x int) int { sum := perSum(x) if x%sum == 0 { return sum } return -1}func perSum(num int) int { ans := 0 for num != 0 { ans += num % 10 num /= 10 } return ans}","link":"/leetcode/2024/07/harshad-number/index.html"},{"title":"3106. 满足距离约束且字典序最小的字符串","text":"满足距离约束且字典序最小的字符串 难度: medium 原始链接: https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint 标签: 贪心 解法一: 贪心go1234567891011121314func getSmallestString(s string, k int) string { bytes := []byte(s) n := len(bytes) for i := 0; i &lt; n; i++ { distance := int(min(bytes[i]-'a', 'z'-bytes[i]+1)) if distance &gt; k { bytes[i] -= byte(k) break } bytes[i] = 'a' k -= distance } return string(bytes)} java12345678910111213141516class Solution { public String getSmallestString(String s, int k) { char[] chars = s.toCharArray(); int n = chars.length; for (int i = 0; i &lt; n; i++) { int distance = Math.min(chars[i] - 'a', 'z' - chars[i] + 1); if (distance &gt; k) { chars[i] -= k; break; } chars[i] = 'a'; k -= distance; } return String.valueOf(chars); }}","link":"/leetcode/2024/07/lexicographically-smallest-string-after-operations-with-constraint/index.html"},{"title":"807. 保持城市天际线","text":"保持城市天际线 难度: medium 原始链接: https://leetcode.cn/problems/max-increase-to-keep-city-skyline 标签: 贪心 解法一: 贪心go123456789101112131415161718func maxIncreaseKeepingSkyline(grid [][]int) int { m, n := len(grid), len(grid[0]) rArr := make([]int, n) cArr := make([]int, m) for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { rArr[i] = max(rArr[i], grid[i][j]) cArr[j] = max(cArr[j], grid[i][j]) } } ans := 0 for i := 0; i &lt; m; i++ { for j := 0; j &lt; n; j++ { ans += max(grid[i][j], min(rArr[i], cArr[j])) - grid[i][j] } } return ans}","link":"/leetcode/2024/07/max-increase-to-keep-city-skyline/index.html"},{"title":"3115. 质数的最大距离","text":"质数的最大距离 难度: medium 原始链接: https://leetcode.cn/problems/maximum-prime-difference 标签: 循环 解法一: 循环go1234567891011121314151617181920212223242526func maximumPrimeDifference(nums []int) int { left := 0 right := len(nums) - 1 for left &lt;= right { if isPrime(nums[left]) { break } left++ } for right &gt;= left { if isPrime(nums[right]) { break } right-- } return right - left}func isPrime(num int) bool { for i := 2; i*i &lt;= num; i++ { if num%i == 0 { return false } } return num &gt;= 2}","link":"/leetcode/2024/07/maximum-prime-difference/index.html"},{"title":"3096. 得到更多分数的最少关卡数目","text":"得到更多分数的最少关卡数目 难度: medium 原始链接: https://leetcode.cn/problems/minimum-levels-to-gain-more-points 标签: 前缀和 解法一: 前缀和go12345678910111213141516171819202122232425func minimumLevels(possible []int) int { n := len(possible) alice := 0 bob := 0 for i := 0; i &lt; n; i++ { if possible[i] == 0 { bob-- } else { bob++ } } for i := 0; i &lt; n-1; i++ { if possible[i] == 0 { bob++ alice-- } else { bob-- alice++ } if alice &gt; bob { return i + 1 } } return -1}","link":"/leetcode/2024/07/minimum-levels-to-gain-more-points/index.html"},{"title":"2974. 最小数字游戏","text":"最小数字游戏 难度: easy 原始链接: https://leetcode.cn/problems/minimum-number-game 标签: 排序 解法一: 排序go12345678func numberGame(nums []int) []int { sort.Ints(nums) n := len(nums) for i := 0; i &lt; n; i += 2 { nums[i], nums[i+1] = nums[i+1], nums[i] } return nums}","link":"/leetcode/2024/07/minimum-number-game/index.html"},{"title":"2844. 生成特殊数字的最少操作","text":"生成特殊数字的最少操作 难度: medium 原始链接: https://leetcode.cn/problems/minimum-operations-to-make-a-special-number 标签: 一次遍历 解法一: 一次遍历go1234567891011121314151617181920func minimumOperations(num string) int { hasZero := false hasFive := false n := len(num) for i := n - 1; i &gt;= 0; i-- { if hasZero &amp;&amp; (num[i] == '0' || num[i] == '5') || hasFive &amp;&amp; (num[i] == '2' || num[i] == '7') { return n - i - 2 } if num[i] == '0' { hasZero = true } else if num[i] == '5' { hasFive = true } } if hasZero { return n - 1 } return n}","link":"/leetcode/2024/07/minimum-operations-to-make-a-special-number/index.html"},{"title":"3111. 覆盖所有点的最少矩形数目","text":"覆盖所有点的最少矩形数目 难度: medium 原始链接: https://leetcode.cn/problems/minimum-rectangles-to-cover-points 标签: 排序, 贪心 解法一: 排序, 贪心go1234567891011121314func minRectanglesToCoverPoints(points [][]int, w int) int { sort.Slice(points, func(i, j int) bool { return points[i][0] &lt;= points[j][0] }) pre := -w - 1 ans := 0 for _, point := range points { if point[0]-pre &gt; w { ans++ pre = point[0] } } return ans}","link":"/leetcode/2024/07/minimum-rectangles-to-cover-points/index.html"},{"title":"3112. 访问消失节点的最少时间","text":"访问消失节点的最少时间 难度: medium 原始链接: https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes 标签: Dijkstra 算法 解法一: Dijkstra 算法java12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static class Node { private int id; private int distance; private static Node of(int id, int distance) { Node node = new Node(); node.id = id; node.distance = distance; return node; } } public int[] minimumTime(int n, int[][] edges, int[] disappear) { List&lt;List&lt;Node&gt;&gt; grid = new ArrayList&lt;&gt;(n); for (int i = 0; i &lt; n; i++) { grid.add(new ArrayList&lt;&gt;()); } for (int[] edge : edges) { grid.get(edge[0]).add(Node.of(edge[1], edge[2])); grid.get(edge[1]).add(Node.of(edge[0], edge[2])); } int[] ans = new int[n]; Arrays.fill(ans, -1); ans[0] = 0; PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;((node1, node2) -&gt; node1.distance - node2.distance); priorityQueue.add(Node.of(0, 0)); while (!priorityQueue.isEmpty()) { Node node = priorityQueue.poll(); if (node.distance &gt; ans[node.id]) { continue; } for (Node nextNode : grid.get(node.id)) { if (node.distance + nextNode.distance &lt; disappear[nextNode.id] &amp;&amp; (ans[nextNode.id] == -1 || node.distance + nextNode.distance &lt; ans[nextNode.id])) { ans[nextNode.id] = node.distance + nextNode.distance; priorityQueue.offer(Node.of(nextNode.id, ans[nextNode.id])); } } } return ans; }}","link":"/leetcode/2024/07/minimum-time-to-visit-disappearing-nodes/index.html"},{"title":"3033. 修改矩阵","text":"修改矩阵 难度: easy 原始链接: https://leetcode.cn/problems/modify-the-matrix 标签: 循环 解法一: 循环go12345678910111213141516func modifiedMatrix(matrix [][]int) [][]int { m := len(matrix) n := len(matrix[0]) for c := 0; c &lt; n; c++ { curMax := -1 for r := 0; r &lt; m; r++ { curMax = max(curMax, matrix[r][c]) } for r := 0; r &lt; m; r++ { if matrix[r][c] == -1 { matrix[r][c] = curMax } } } return matrix}","link":"/leetcode/2024/07/modify-the-matrix/index.html"},{"title":"2766. 重新放置石块","text":"重新放置石块 难度: medium 原始链接: https://leetcode.cn/problems/relocate-marbles 标签: 哈希 解法一: 哈希go12345678910111213141516171819func relocateMarbles(nums []int, moveFrom []int, moveTo []int) []int { positions := make(map[int]bool) for _, num := range nums { positions[num] = true } n := len(moveFrom) for i := 0; i &lt; n; i++ { positions[moveFrom[i]] = false positions[moveTo[i]] = true } ans := []int{} for position, exists := range positions { if exists { ans = append(ans, position) } } sort.Ints(ans) return ans}","link":"/leetcode/2024/07/relocate-marbles/index.html"},{"title":"3131. 找出与数组相加的整数 I","text":"找出与数组相加的整数 I 难度: easy 原始链接: https://leetcode.cn/problems/find-the-integer-added-to-array-i 标签: 最小值之差 解法一: 最小值之差go123func addedInteger(nums1 []int, nums2 []int) int { return slices.Min(nums2) - slices.Min(nums1)}","link":"/leetcode/2024/08/find-the-integer-added-to-array-i/index.html"},{"title":"3128. 直角三角形","text":"直角三角形 难度: medium 原始链接: https://leetcode.cn/problems/right-triangles 标签: 枚举 解法一: 枚举go123456789101112131415161718192021func numberOfRightTriangles(grid [][]int) int64 { rLen := len(grid) cLen := len(grid[0]) rows := make([]int, rLen) cols := make([]int, cLen) for r := 0; r &lt; rLen; r++ { for c := 0; c &lt; cLen; c++ { rows[r] += grid[r][c] cols[c] += grid[r][c] } } ans := int64(0) for r := 0; r &lt; rLen; r++ { for c := 0; c &lt; cLen; c++ { if grid[r][c] == 1 { ans += int64((rows[r] - 1) * (cols[c] - 1)) } } } return ans}","link":"/leetcode/2024/08/right-triangles/index.html"},{"title":"3151. 特殊数组 I","text":"特殊数组 I 难度: easy 原始链接: https://leetcode.cn/problems/special-array-i 标签: 循环 解法一: 循环go12345678910func isArraySpecial(nums []int) bool { flag := nums[0] &amp; 1 for _, num := range nums[1:] { if flag == (num &amp; 1) { return false } flag = num &amp; 1 } return true}","link":"/leetcode/2024/08/special-array-i/index.html"},{"title":"3152. 特殊数组 II","text":"特殊数组 II 难度: medium 原始链接: https://leetcode.cn/problems/special-array-ii 标签: 预处理 解法一: 预处理go123456789101112131415161718192021func isArraySpecial(nums []int, queries [][]int) []bool { n := len(nums) dp := make([]int, n) flag := nums[0] &amp; 1 pre := 0 for i := 1; i &lt; n; i++ { num := nums[i] if (num &amp; 1) == flag { pre = i } dp[i] = pre flag = num &amp; 1 } ans := make([]bool, len(queries)) for i, query := range queries { if dp[query[1]] &lt;= query[0] { ans[i] = true } } return ans}","link":"/leetcode/2024/08/special-array-ii/index.html"},{"title":"572. 另一棵树的子树","text":"另一棵树的子树 难度: easy 原始链接: https://leetcode.cn/problems/subtree-of-another-tree 标签: 深度优先遍历 解法一: 深度优先遍历go1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isSubtree(root *TreeNode, subRoot *TreeNode) bool { if root == nil { return false } return equalTree(root, subRoot) || isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)}func equalTree(node1, node2 *TreeNode) bool { if node1 == nil &amp;&amp; node2 == nil { return true } else if node1 == nil || node2 == nil || node1.Val != node2.Val { return false } return equalTree(node1.Left, node2.Left) &amp;&amp; equalTree(node1.Right, node2.Right)}","link":"/leetcode/2024/08/subtree-of-another-tree/index.html"},{"title":"LCP 40. 心算挑战","text":"心算挑战 难度: easy 原始链接: https://leetcode.cn/problems/uOAnQW 标签: 前缀和, 贪心 解法一: 前缀和, 贪心go12345678910111213141516171819202122232425262728293031323334353637383940414243func maxmiumScore(cards []int, cnt int) int { // 奇偶分组 odds := []int{} evens := []int{} for _, card := range cards { if (card &amp; 1) == 0 { evens = append(evens, card) } else { odds = append(odds, card) } } // 排序，在数组最后多插入一个 0，方便后续计算 n1 := len(odds) sort.Ints(odds) for i := n1 - 2; i &gt;= 0; i-- { odds[i] += odds[i+1] } odds = append(odds, 0) n2 := len(evens) sort.Ints(evens) for i := n2 - 2; i &gt;= 0; i-- { evens[i] += evens[i+1] } evens = append(evens, 0) // 假设奇数数量为 oddNum，偶数数量为 evenNum // 最后相加的结果要得到偶数，奇数的数量需要满足 oddNum % 2 == 0，那么偶数的数量就是 cnt - oddNum // 为了得到最大的总和，需要枚举所有满足的奇偶组合，取最大值为最后的结果 ans := 0 for oddNum := 0; oddNum &lt;= n1 &amp;&amp; oddNum &lt;= cnt; oddNum += 2 { evenNum := cnt - oddNum if evenNum &lt; 0 { break } else if evenNum &gt; n2 { continue } curSum := 0 curSum += odds[n1-oddNum] curSum += evens[n2-evenNum] ans = max(ans, curSum) } return ans}","link":"/leetcode/2024/08/uOAnQW/index.html"},{"title":"面经 - 一叶智能一面技术面","text":"一叶智能 – 一面面经公司简介听面试官说，以前本部是在北京，然后在江苏也有分布，现在在深圳的发展挺好的，总部正在往深圳这边迁移 面试官问空窗期 saas服务发布是怎么做的 项目中的redis主要用来做什么 项目中的gateway主要用来做什么 表a有一个复合索引 (a, b, c)，假设查询语句是 select b from a where a = ? and c = ? group by b，索引使用情况 大表的冷数据要通过什么方式迁移 大表索引变更要怎么做 threadlocal在多线程中如何使用 mybatis的拦截器有没有用过 myabtis中如果想要把一个对象保存为json格式要怎么做 项目中遇到的难点 上一份工作除了技术上，你觉得还给你了什么提升 未来的发展方向 反问贵公司目前的项目上使用到了哪些技术 贵公司的关系型数据库为什么选择了 postgresql，而不是 mysql","link":"/mianjing/2024/02/yishuyiye/index.html"},{"title":"面经 - 江西燃点","text":"江西燃点 – 面经情报面试是混面，技术面，主管面(一般针对个人经历，发展提问的面试我称之为主管面) 公司运营的项目目前趋于稳定，期望开发者拥有大数据方面的技能，可以给一定的时间给开发者来转这个方向 技术面面试官问二分法适用的场景 分布式事务中，有八个 rpc 修改类接口需要同步调用，现在发现整个事务执行效率较低，该如何优化 spring 中的循环依赖是如何解决的 有没有在网关层做过鉴权 ThreadLocal 使用场景，以及可能遇到的问题 有没有做过 sql 调优类的实践工作 有没有做过数据权限，要怎么实现 其他面试结果在本周内会给回复 这算是第一个打开了我个人博客的面试官，虽然我的个人博客并没有很么干货，感动ing，呜呜呜～～","link":"/mianjing/2024/03/jiang-xi-ran-dian/index.html"},{"title":"面经 - 深圳同行者","text":"深圳同行者 – 技术面面经情报 约的面试是下午 3 点，签到的时候就发现有好些人都是去面试这家公司的，有 Java，有测试，有实习。 到了之后公司门口的会客室一堆人在做笔试题，面试 Java 的人比较多，我笔试的时候对面坐的人也是面试 Java的 面试有两轮，第一轮问八股多一些，第二轮会结合场景问实际应用 笔试 三道算法题，一道sql题 算法题没有给出方法签名 有 1000 个数，取值取值范围是 [0, 999]，其中有两个数出现了两次，要求找出这个重复的数 sql 题，题目比较长，题目就不写了，需要用到 group by，having 以及 聚合函数 设计一个程序，可以让两个线程交替打印从0到n的数字 应该是 LeetCode 原题，这会儿没找到是哪个原题，但印象中我做过 打印26个小写字母的所有不重复排列组合，每个字母只能使用一次，类似于a，ab，abc这种都算是一个合法的组合 一轮技术面面试官问数据冷热分离是怎么做的 开源项目的 star 是多少 笔试第四题的结果数量有多少 二轮技术面 二轮面试的面试官就在面试的等待区面试，其他人是可以听见面试的过程 不过二轮面试的面试官对每个人问的问题不尽相同，我面试之前这个面试官对另一位面试者问了笔试的第 3 题，也稍微深入问了下 gc 对于公司批量通知十多个面试者同一时间段来笔试的行为我心里有点不爽，对于二轮技术面的面试官直接在面试等待区面试的行为我表示贵公司没有对面试者给到基本的尊重 面试官问谈谈你对 CAS 的理解 这里我回答，基于 CAS 的轻量级锁比重锁更节省系统资源。然后被面试官打脸了，后面面试官一步步引导我玩正确的方向回答 你是如何分析 jvm 的 dump 文件的 笔试第一题我使用数组计数的方式来做的，也可以换成使用 map 来计数，面试官要求使用 O(1) 空间复杂度求解，需要现场写，面试官就在旁边看着 有没有自己搞过一些开源的工具类 开源项目中使用的 netty 是做什么用的 有没有在 gateway 中进行限流 是否有独立负责的微服务项目 最近一个项目的架构图，需要现场画出来 有一个接口需要做限流，每天每个用户有额定的调用次数，然后随后系统还有一个总的调用次数，调用次数达到这个用户的调用次数或者达到总的调用次数上限都要做限流，你的方案是什么 进度二面的面试官说，差不多两天会给通知","link":"/mianjing/2024/03/tongxingzhe/index.html"},{"title":"面经 - 行云绽放","text":"行云绽放 – 技术面面经情报 公司有三个产品，按我的理解，是比较偏向安全类的产品。比如，数据库操作层面的安全，服务器操作层面的安全 对开发而言，要求会网络编程 面试流程上分为笔试 + 一面（技术面）+ 二面（偏向主管面，偶尔也问点技术问题） 笔试主要说说最后的三个大题 写一个延迟加载的单例 给一个byte数组，要求写入指定文件，如果文件已经存在，则采用追加写，否则创建该文件并写入字节数组 有一个程序运行有一些问题，具体的问题如下，分别写出排查和定位的过程 CPU占用过高 出现了OOM异常 出现了open too many files异常 其他笔试还有两个填写关键代码的算法，分别是冒泡排序和二分查找 笔试中除了第二题考了字节流，选择题中也有考字节流 一轮技术面Java 常用的数据结构，说说你对 List，Queue 的看法 线程池的参数 创建线程的方法 如果有一批任务被提交给线程池，线程池是怎么分排线程的 Linux 常用命令 查询指定时间范围内的日志的 Linux 命令 jvm 内存结构 对于这种文件最好和面试官说明是想要问 java内存模型 还是 jvm运行时内存区域 分布式锁是使用redis来实现的吗 jdk 原生自带了 nio 的一套 api，为什么还要用 netty 呢，好处是什么 二轮主管面如果和其他同事发生了冲突，不一定是字面意义上的冲突，也可能是观念上的不认同，具体的场景比如，测试反馈了一个bug，但你不认为这是一个bug，你会怎么做 工作中有没有遇到什么难题，又是怎么解决的 你觉得自己有什么优点 你觉得自己有什么缺点 你期望一个怎么样的工作环境","link":"/mianjing/2024/03/xingyunzhangfang/index.html"},{"title":"面经 - 一临云科技","text":"一临云科技 – 一面面经公司简介一家医疗行业的公司，在深圳和成都有分布，深圳这边的开发大概二十多人，测试都在成都，有交流通过线上会议的方式进行 面试官问自我介绍 数据冷热分离是怎么做的 对线程池的理解 redis 在项目的用处 redis 分布锁的实现 gateway 在项目中的用处 要怎么保证 mq 消息不丢失 sql 优化 索引失效的情况有哪些 仔细谈谈最左匹配原则 回表是什么 反问深圳这边的开发规模 开发团队 20 人左右 面试的流程，是否还有二面 线上一面，最好线下二面","link":"/mianjing/2024/03/yilinyun/index.html"},{"title":"面经 - 易世通达(跨境电商)技术面","text":"易世通达(跨境电商) – 技术面面经前言不知道其他人是怎么理解电商的，我以前一直以为电商这一行的互联网是自己搞购物平台，但这家公司和我说，公司主要做海外的电商业务，对商品的上下架，机器人客服啥的，这才是电商 公司简介强调了加班，周末有事情也要加班，不过公司提供住宿来着，就是不知道住宿的环境如何 一面面试官问线程池的参数有哪些 如果要实现核心线程也能被回收，要怎么做 es 是否了解 HashMap的put流程 链表变红黑树的条件 线程安全的map 简单说说ConcurrentHashMap是怎么保证线程安全的 你对b+树的了解 一道需要分组聚合查询的sql题，比较简单，面试官现场出题需要现场写查询sql 二面面试官问有没有遇到过tomcat线程阻塞的场景 gateway使用的是容器是什么，tomcat还是netty 举一个mysql死锁的例子 nacos一致性协议有哪些 gRPC是否了解 http2是否了解 quartz框架是否可以通过手动修改cron的方式不停机更新cron xxl-job是否有了解","link":"/mianjing/2024/03/yishitongda/index.html"},{"title":"面经 - 卓讯信息技术","text":"卓讯信息技术 – 技术面面经公司简介公司简介上写的时候双休，每天工作7小时，但hr给我的表态是还是得一周工作至少40小时，估计多的5小时是不算加班费的 技术面的面试官给我的信息是，工作会很忙，周六也要加班，大概可以理解为 996 吧，hr给我的反馈是周末加班算调休，但我猜测有概率是不给任何薪水或者调休补偿的 面试前公司需要收集的信息有点越界了，除了要写每家公司的证明人和联系电话，还要求填写自己的优缺点，工作过公司的一些对标企业 公司目前做的项目是一个低代码平台，面向的客户也是政府机关 笔试 笔试题整体偏简单（除了问 Session 失效的 api 以外），题量也不大，主要考 sql 查询 如何使 Servlet 中的 Session 对象失效，然后有四个选项。笔试后我查询了一下，应该选第3个 session.clear() session.remove() session.invalidate() session.stop() 最后有一个编程题，大概的意思是一个对象，有三个属性（id，name，children），然后它是一个树状结构，给一个id给你，要你返回目标对象，题目给出了方法签名，需要补充方法体 123public Map test(List&lt;Map&gt; list, String id) { // TODO 需要面试者填充方法体} 这题我使用广度优先遍历来做的，面试官疑惑怎么还用上队列了，我解释了一番之后，他还是表示没这么复杂 事后我才想总不会是直接循环这个List，然后比较id，而不需要去遍历children来做的吧 技术面面试官问 问了一下我的开源项目以及工作项目，没啥干货 反问我脑海中的低代码平台还是停留在非开发者也能快速上手，但后期维护难的印象。如果客户有需要导入旧数据到低代码平台的需要，要怎么做 面试官的大概意思他们的低代码平台用户还是需要一点代码水平的，针对我说的数据迁移，他说这个业务不在考虑范围内 hr 面主要谈了谈薪水和工作时间，薪水压了我1k，现场给了意向 offer 总结自我感觉这家公司的业务可能并没有涉及分布式微服务之类的，给offer倒是挺快的，算是我来深圳的第一个offer","link":"/mianjing/2024/03/zhuoxun/index.html"},{"title":"基于 langchain4j 的简易 MCP Client","text":"前言这次的定语比较多，又是 简易 又是 client 的 如果你去翻阅 langchain4j 有关 MCP 的文档（点击这里），你会发现有关它的内容比起 RAG 少的可怜 在我看来，应该是以下几个原因有关 langchain4j 并没有实现完整的 MCP 协议。在目前版本（1.0.1）的 langchain4j 中是不存在 MCP Server 这个组件的 langchain4j 对于 MCP Client 的理解和 Function Calling 异曲同工，有一些逻辑在其他模块已经实现了 我其实是有些纳闷的，因为我最初就是想用 langchain4j 把现有的服务构建成一个 MCP Server，至于 MCP Client 我想许多客户端都可以充当这个角色 以上推论主观性很强，如果有错误，可以联系我的邮箱 langchain4j 中的 MCP Client在 langchain4j 中，McpClient 本质还是一个 tool 从官方文档中给的例子中可以看出来一些端倪 12345678910111213141516171819McpTransport transport = new HttpMcpTransport.Builder() .sseUrl(&quot;http://localhost:3001/sse&quot;) .logRequests(true) // if you want to see the traffic in the log .logResponses(true) .build(); McpClient mcpClient = new DefaultMcpClient.Builder() .key(&quot;MyMCPClient&quot;) .transport(transport) .build();McpToolProvider toolProvider = McpToolProvider.builder() .mcpClients(mcpClient) .build();Bot bot = AiServices.builder(Bot.class) .chatModel(model) .toolProvider(toolProvider) .build(); 先是构建了一个基于 SSE 的传输对象 transport，然后封装成一个 McpClient 客户端，再包装成一个工具供应商 McpToolProvider，最后交给 AiServices 构建一个服务组件 AiServices 除了有 toolProvider 属性，还有 tools 属性。而这个 tools 属性就是 Function Calling 用来配置 tool 的 看一下源码（dev.langchain4j.service.tool.ToolService#createContext） 123456789101112131415161718192021222324public ToolServiceContext createContext(Object memoryId, UserMessage userMessage) { if (this.toolProvider == null) { return this.toolSpecifications.isEmpty() ? new ToolServiceContext(null, null) : new ToolServiceContext(this.toolSpecifications, this.toolExecutors); } List&lt;ToolSpecification&gt; toolsSpecs = new ArrayList&lt;&gt;(this.toolSpecifications); Map&lt;String, ToolExecutor&gt; toolExecs = new HashMap&lt;&gt;(this.toolExecutors); ToolProviderRequest toolProviderRequest = new ToolProviderRequest(memoryId, userMessage); ToolProviderResult toolProviderResult = toolProvider.provideTools(toolProviderRequest); if (toolProviderResult != null) { for (Map.Entry&lt;ToolSpecification, ToolExecutor&gt; entry : toolProviderResult.tools().entrySet()) { if (toolExecs.putIfAbsent(entry.getKey().name(), entry.getValue()) == null) { toolsSpecs.add(entry.getKey()); } else { throw new IllegalConfigurationException( &quot;Duplicated definition for tool: &quot; + entry.getKey().name()); } } } return new ToolServiceContext(toolsSpecs, toolExecs);} 逻辑大概是 如果 toolProvider 为空，则只包装了 tools 来源的工具 toolSpecifications 和 toolExecutors 是 tools 属性处理得到的 否则，先将 toolSpecifications 和 toolExecutors 添加到容器中做准备 重点在于 provideTools 方法，它将 McpClient 的 tool 列举出来（通过 MCP 协议的实现 dev.langchain4j.mcp.client.McpClient#listTools）并返回了 ToolProviderResult dev.langchain4j.mcp.McpToolProvider#provideTools(dev.langchain4j.service.tool.ToolProviderRequest, java.util.function.BiPredicate&lt;dev.langchain4j.mcp.client.McpClient,dev.langchain4j.agent.tool.ToolSpecification&gt;) 源码如下 1234567891011121314151617181920protected ToolProviderResult provideTools(ToolProviderRequest request, BiPredicate&lt;McpClient, ToolSpecification&gt; mcpToolsFilter) { ToolProviderResult.Builder builder = ToolProviderResult.builder(); for (McpClient mcpClient : mcpClients) { try { mcpClient.listTools().stream().filter(tool -&gt; mcpToolsFilter.test(mcpClient, tool)) .forEach(toolSpecification -&gt; { builder.add(toolSpecification, (executionRequest, memoryId) -&gt; mcpClient.executeTool(executionRequest)); }); } catch (IllegalConfigurationException e) { throw e; } catch (Exception e) { if (failIfOneServerFails) { throw new RuntimeException(&quot;Failed to retrieve tools from MCP server&quot;, e); } else { log.warn(&quot;Failed to retrieve tools from MCP server&quot;, e); } } } return builder.build();} 这里就可以看出来，其实本质上和普通的 Function Calling 没有什么区别 将 ToolProviderResult 中的 tool 添加到第二步准备好的容器内 剩下就是和 Function Calling 一样，把 tool 的描述交给大模型，让大模型判断应该使用哪些工具来协助完成用户的提问 项目演示目标利用 langchain4j 的 MCP Client 能力，使用 高德地图 和 腾讯地图 的 MCP Server 来实现一个旅行规划 准备 deepseek api key：申请地址 高德地图 api key：申请地址 腾讯地图 api key：申请地址 大模型换用其它的国内模型也没问题，我习惯用 deepseek 了 其实百度地图也提供了它们的 MCP Server，不过它们的 key 申请需要认证开发者 编码pom 依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.wuhunyu.mcp&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-mcp-client-example&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring-boot.version&gt;3.4.0&lt;/spring-boot.version&gt; &lt;langchain4j.version&gt;1.0.1&lt;/langchain4j.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springboot 版本锁定 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;!-- langchain4j 版本锁定 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-bom&lt;/artifactId&gt; &lt;version&gt;${langchain4j.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j springboot 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j 响应式编程 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-reactor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j openai 接入 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j mcp 接入 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-mcp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml 配置1234567891011121314151617181920212223242526272829303132spring: application: name: langchain4j-mcp-client-examplelangchain4j: # 大模型 open-ai: chat-model: base-url: https://api.deepseek.com/v1 api-key: [替换成你的 deepseek api key] model-name: deepseek-chat log-requests: true log-responses: true # 流式大模型 streaming-chat-model: base-url: ${langchain4j.open-ai.chat-model.base-url} api-key: ${langchain4j.open-ai.chat-model.api-key} model-name: deepseek-chat log-requests: ${langchain4j.open-ai.chat-model.log-requests} log-responses: ${langchain4j.open-ai.chat-model.log-responses}mcp: # 高德地图 amap: sse-url: https://mcp.amap.com/sse?key=[替换成你的 高德地图 api key] client-name: amap-client client-version: 0.0.1 # 腾讯地图 qq: sse-url: https://mcp.map.qq.com/sse?key=[替换成你的 腾讯地图 api key] client-name: qq-client client-version: 0.0.1 组件配置123456public interface MapClientService { @SystemMessage(&quot;你是一个旅行规划专家，你可以根据用户的需求，为用户规划出旅行路线。&quot;) Result&lt;String&gt; plan(@MemoryId Long userId, @UserMessage String userMessage);} 12345678910111213141516171819202122232425262728// 手动构建 AiService@Bean(&quot;mapService&quot;)public MapClientService mapService( ChatModel chatModel, StreamingChatModel streamingChatModel, ChatMemoryProvider chatMemoryProvider, RetrievalAugmentor retrievalAugmentor, @Qualifier(&quot;amapMcpClient&quot;) McpClient amapMcpClient, @Qualifier(&quot;qqMcpClient&quot;) McpClient qqMcpClient, DateTool dateTool) { final var mcpToolProvider = new McpToolProvider.Builder() .failIfOneServerFails(false) .mcpClients(List.of( amapMcpClient, qqMcpClient )) .build(); return AiServices.builder(MapClientService.class) .chatModel(chatModel) .streamingChatModel(streamingChatModel) .chatMemoryProvider(chatMemoryProvider) .retrievalAugmentor(retrievalAugmentor) .toolProvider(mcpToolProvider) .tools(dateTool) .build();} 只贴出了最关键的部分 注意除了 toolProvider 配置 MCP Client 以外，还添加了一个 tools。这个日期工具只提供了一个基本的当前日期时间功能 1234567891011@Component(&quot;dateTool&quot;)public class DateTool { private final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); @Tool(&quot;查询当前的日期时间，以 yyyy-MM-dd HH:mm:ss 格式返回&quot;) public String now() { return LocalDateTime.now().format(dateTimeFormatter); }} 执行结果让我们调用 MapClientService#plan 看看效果。我现在想要知道这个周末在深圳的旅游规划，提示词如下 1请帮我规划一下这周周末深圳的两天旅行规划，要求精确到小时的安排 这是最后的效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697以下是深圳周末两天（2025年6月14日-15日）的详细旅行计划，具体到每小时的活动安排：---### **第一天：6月14日（星期六）**#### **上午**- **08:00-09:00**：早餐 推荐地点：深圳本地早茶店（如点都德、陶陶居） 活动：品尝广式早茶，如虾饺、叉烧包等。- **09:00-11:00**：深圳湾公园 活动：散步、骑行，欣赏深圳湾海景和红树林生态。- **11:00-12:00**：前往华侨城创意文化园 交通：打车或地铁（约20分钟） 活动：参观艺术展览、创意小店。#### **中午**- **12:00-13:30**：午餐 推荐地点：华侨城创意园内的特色餐厅（如“旧天堂书店”或“Gaga鲜语”） 活动：享用午餐，稍作休息。#### **下午**- **13:30-15:30**：世界之窗 交通：打车或地铁（约15分钟） 活动：参观世界著名景点的微缩模型，拍照打卡。- **15:30-17:00**：欢乐海岸 活动：购物、散步，欣赏水秀表演（如时间合适）。- **17:00-18:00**：前往深圳湾万象城 交通：步行或打车（约10分钟） 活动：购物或休闲。#### **晚上**- **18:00-19:30**：晚餐 推荐地点：深圳湾万象城的高端餐厅（如“炳胜品味”） 活动：享用晚餐。- **19:30-21:00**：深圳湾灯光秀（如开放） 活动：欣赏深圳湾夜景和灯光表演。- **21:00-22:00**：返回酒店 交通：打车或地铁 活动：休息。---### **第二天：6月15日（星期日）**#### **上午**- **08:00-09:00**：早餐 推荐地点：酒店早餐或附近咖啡馆。- **09:00-11:00**：大梅沙海滨公园 交通：打车或自驾（约40分钟） 活动：沙滩漫步、游泳（如天气允许）。- **11:00-12:00**：东部华侨城 活动：参观茶溪谷或大峡谷，体验自然风光。#### **中午**- **12:00-13:30**：午餐 推荐地点：东部华侨城内的餐厅 活动：享用午餐。#### **下午**- **13:30-15:30**：中英街 交通：打车（约30分钟） 活动：购物、了解历史。- **15:30-17:00**：盐田海滨栈道 活动：散步，欣赏海景。- **17:00-18:00**：返回市区 交通：打车或地铁 活动：休息。#### **晚上**- **18:00-19:30**：晚餐 推荐地点：市区内的海鲜餐厅（如“79号渔船”） 活动：享用晚餐。- **19:30-21:00**：深圳平安金融中心云际观景台 活动：俯瞰深圳夜景。- **21:00-22:00**：返回酒店或前往机场/车站 交通：打车或地铁 活动：结束行程。---### **注意事项**1. **交通**：深圳地铁覆盖广泛，建议使用地铁或打车。2. **天气**：提前查看天气，携带防晒或雨具。3. **门票**：部分景点（如世界之窗、东部华侨城）需提前购票。如果需要调整或补充，请告诉我！ 其他问题发现了一处 bug：okhttp 的响应流未关闭，控制台打印了警告日志 122025-06-10 17:37:01.957 [OkHttp ConnectionPool] WARN okhttp3.OkHttpClient - A connection to https://mcp.map.qq.com/ was leaked. Did you forget to close a response body? To see where this was allocated, set the OkHttpClient logger level to FINE: Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);2025-06-10 17:37:01.957 [OkHttp ConnectionPool] WARN okhttp3.OkHttpClient - A connection to https://mcp.map.qq.com/ was leaked. Did you forget to close a response body? To see where this was allocated, set the OkHttpClient logger level to FINE: Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE); 问题源码（dev.langchain4j.mcp.client.transport.http.HttpMcpTransport#execute）如下 12345678910111213141516171819202122232425private CompletableFuture&lt;JsonNode&gt; execute(Request request, Long id) { CompletableFuture&lt;JsonNode&gt; future = new CompletableFuture&lt;&gt;(); if (id != null) { messageHandler.startOperation(id, future); } client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { future.completeExceptionally(e); } @Override public void onResponse(Call call, Response response) throws IOException { int statusCode = response.code(); if (!isExpectedStatusCode(statusCode)) { future.completeExceptionally(new RuntimeException(&quot;Unexpected status code: &quot; + statusCode)); } // For messages with null ID, we don't wait for a response in the SSE channel if (id == null) { future.complete(null); } } }); return future;} Response 对象未在使用后调用其 close 方法关闭连接 修复成如下应该就可以了 123456789101112131415161718192021222324252627private CompletableFuture&lt;JsonNode&gt; execute(Request request, Long id) { CompletableFuture&lt;JsonNode&gt; future = new CompletableFuture&lt;&gt;(); if (id != null) { messageHandler.startOperation(id, future); } client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { future.completeExceptionally(e); } @Override public void onResponse(Call call, Response response) throws IOException { try (response) { int statusCode = response.code(); if (!isExpectedStatusCode(statusCode)) { future.completeExceptionally(new RuntimeException(&quot;Unexpected status code: &quot; + statusCode)); } // For messages with null ID, we don't wait for a response in the SSE channel if (id == null) { future.complete(null); } } } }); return future;} 提了一个 issue，本想要提一个 pr，但 langchain4j 的源码在我本地没跑起来，这个机会让给其他有缘人吧 项目代码GitHub 参考langchain4j 官网","link":"/ai/rag/2025/06/langchain4j-mcp-example/index.html"},{"title":"基于 langchain4j 的简易 RAG","text":"RAG 是什么langchain4j 的官网给了一段通俗易懂的描述 简单来说，RAG 是一种在发送给 LLM 之前，从你的数据中找到并注入相关信息片段到提示中的方法 RAG 分为两个阶段，索引和检索 关于检索部分，下面的项目中将分别使用 langchain4j 的原生组件以及高级用法分别实现 简单说明一下我对这两个阶段的理解 索引 上图是 langchain4j 官网给出的示意图 大概的过程就是 原始的文档（可以是 word，pdf，markdown等格式的文件，即图中的 Document）经过切割之后，得到了一个个的片段（即图中的 Segments） 一般走图中的右侧的流程，将片段经过内嵌模型（即图中的 Embedding Model）计算后，得到内嵌对象（图中的 Embedding），最后将内嵌对象保存到专门的数据库（图中的 Embedding Store）中 过程中出现了几个名词 Document：理解为包含内容的文档，比如 word，pdf，markdown等格式的文件 Segment：由 Document 拆分而来，具体的拆分规则可以自定义 至于为什么需要拆分，因为大模型一次能处理的上下文窗口是有限制的，如果直接把一个包含有 1百万 token 的文档喂给大模型，大模型也吃不消 将文档进行拆分，然后把一个个小的片段保存到数据库中，在需要用到这个文档时，只查询出相关性比较高的 topN 片段给大模型，这样大模型才能处理地过来，也能节省 token 的消耗，以及加快大模型的运行速度。缺点是根据拆分的规则，可能会丢失一部分信息 Embedding Model：内嵌模型。我理解为把自然语言转换成向量的一个模型 为什么要转换成向量？我们需要计算两句话的相关性高不高，需要特殊的算法。比如需要判断土豆和马铃薯的相关性高还是土豆和黄豆的相关性比较高 Embedding：内嵌对象。也就是内嵌模型的输出，也是内嵌数据库的输入 Embedding Store：内嵌数据库。用来保存内嵌对象的地方 许多我们熟悉的数据库也支持保存向量，比如 redis，postgresql。但它们在向量数据的处理方面毕竟没那么专业 检索 在索引完成之后，内嵌数据库中已经保存了一些文档数据 而检索的过程就是将用户的提问在内嵌数据库中查询相关性最高的片段，然后将这些片段和用户的提问聚合，再喂给大模型，由大模型做整合 在 langchain4j 给的图示中，对部分内容进行了省略。我尝试以代码的角度对这个流程进行完善 用户的提问信息被称为一个 Query Query 也可以像文档一样，先进行转换。在 langchain4j 目前的实现中，给出了三种转换 DefaultQueryTransformer：什么都不做 CompressingQueryTransformer：通过大模型对用户的提问进行压缩。这是给大模型的提示词 123456789101112Read and understand the conversation between the User and the AI. Then, analyze the new query from the User. Identify all relevant details, terms, and context from both the conversation and the new query. Reformulate this query into a clear, concise, and self-contained format suitable for information retrieval. Conversation:{{chatMemory}}User query: {{query}}It is very important that you provide only reformulated query and nothing else! Do not prepend a query with anything! 翻译一下是 123456789101112阅读并理解用户与AI之间的对话。然后，分析用户的新查询。从对话和新查询中识别所有相关细节、术语和上下文。将此查询重新表述为清晰、简洁且适合信息检索的独立格式。对话：{{chatMemory}}用户查询：{{query}}非常重要，您只能提供重新表述的查询，不得提供其他内容！不要在查询前添加任何内容！ ExpandingQueryTransformer：和 CompressingQueryTransformer 一样，通过大模型对原有的提问进行扩展。可以指定扩展的数量，默认是 3 条。提示词如下 1234567Generate {{n}} different versions of a provided user query. Each version should be worded differently, using synonyms or alternative sentence structures, but they should all retain the original meaning. These versions will be used to retrieve relevant documents. It is very important to provide each query version on a separate line, without enumerations, hyphens, or any additional formatting!User query: {{query}} 翻译 1234567生成提供的用户查询的{{n}}个不同版本。每个版本应使用不同的措辞，使用同义词或不同的句子结构，但它们都应该保留原始意义。这些版本将用于检索相关文档。非常重要，每个查询版本应单独一行提供，不要使用列举、破折号或任何其他格式化！用户查询：{{query}} 经过转换之后，得到的一个 Query 列表。接下来需要的对每个 Query 进行路由，以选择每个 Query 的检索方式 同样的，路由也有多个实现。langchain4j 中有如下两种 DefaultQueryRouter：按顺序执行全部的检索方式 LanguageModelQueryRouter：问一下大模型选择哪些检索方式 关于检索方式，可以有很多很多。比如查询关系型数据库，web搜索，查询内嵌数据库，查询es数据库等等 相对来说，对于自然语言的处理，内嵌数据库和web搜索是我觉得比较合适的搜索方式 有了路由选择，每个 Query 都能被安排到对应的检索方式去处理。而处理的结果就是一个个 Content 列表 再将这些 Content 列表进行聚合，按相关性倒序排。在 langchain4j 中也提供了两种实现 DefaultContentAggregator：有一个特殊的算法，可以计算每个 Content 的相关性分数 ReRankingContentAggregator：用专门的排序模型（ScoringModel）评分 把排序好的 Content 注入到用户的提问中。可以自定义注入的模板 最后将注入好的消息交给大模型，让大模型完成最后的总结 简单总结一下整个流程 括号中是 langchain4j 的组件接口 1用户提问 -&gt; 问题压缩/扩展(QueryTransformer) -&gt; 问题路由(QueryRouter) -&gt; 检索(ContentRetriever) -&gt; 聚合(ContentAggregator) -&gt; 注入(ContentInjector) -&gt; 交给llm 环境准备 在动手实现之前，需要准备一些环境 大模型的 api key。我这里使用的是 deepseek 的 key 内嵌模型的 api key。我用的是阿里云的内嵌模型 text-embedding-v3 内嵌数据库。自建的 milvus 数据库 tavily 搜索引擎的访问 key。申请网站是 https://app.tavily.com 也可以换用 谷歌搜索，区别不是很大 这里给出 milvus 环境的 docker compose 配置 注意事项：由于没有挂载数据卷，容器被销毁后，数据也会被删除 端口 19530：milvus 对外提供服务的端口 3000：milvus web 服务的访问端口 访问 3000 端口可以在网页端操作 milvus 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263services: etcd: container_name: milvus-etcd image: quay.io/coreos/etcd:v3.5.18 environment: - ETCD_AUTO_COMPACTION_MODE=revision - ETCD_AUTO_COMPACTION_RETENTION=1000 - ETCD_QUOTA_BACKEND_BYTES=4294967296 - ETCD_SNAPSHOT_COUNT=50000 command: etcd -advertise-client-urls=http://etcd:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd healthcheck: test: [&quot;CMD&quot;, &quot;etcdctl&quot;, &quot;endpoint&quot;, &quot;health&quot;] interval: 30s timeout: 20s retries: 3 minio: container_name: milvus-minio image: minio:latest environment: MINIO_ACCESS_KEY: minioadmin MINIO_SECRET_KEY: minioadmin command: minio server /minio_data --console-address &quot;:9001&quot; healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9000/minio/health/live&quot;] interval: 30s timeout: 20s retries: 3 milvus: container_name: milvus image: milvusdb/milvus:v2.5.10 command: [&quot;milvus&quot;, &quot;run&quot;, &quot;standalone&quot;] security_opt: - seccomp:unconfined environment: ETCD_ENDPOINTS: etcd:2379 MINIO_ADDRESS: minio:9000 healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:9091/healthz&quot;] interval: 30s start_period: 90s timeout: 20s retries: 3 ports: - &quot;19530:19530&quot; depends_on: - &quot;etcd&quot; - &quot;minio&quot; attu: container_name: milvus-attu image: zilliz/attu:v2.5.7 environment: MILVUS_URL: milvus:19530 ports: - &quot;3000:3000&quot; depends_on: - &quot;milvus&quot;networks: default: name: milvus 编码 要求 jdk 版本在 21 及以上，项目中有一处使用了虚拟线程 项目简介分别使用 langchain4j 的高级语法和低级组件来实现一个简单的 RAG 功能 外部知识库的来源有两个部分，也可自行扩展 内嵌数据库 tavily 搜索 其中，内嵌数据库的数据库将通过 function call 的方式写入。下面将提供一个简单的案列供参考 pom 依赖 maven 的中央仓库没有 langchain4j-milvus-spring-boot-starter 依赖 有两个处理方案 clone langchain4j-spring 仓库打包对应的版本(1.0.0-beta3)到本地仓库 修改成 langchain4j-milvus 依赖，自行编码构建 MilvusEmbeddingStore bean 对象 这里我选择的是方法一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.wuhunyu.rag&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-rag-example&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring-boot.version&gt;3.4.0&lt;/spring-boot.version&gt; &lt;langchain4j.version&gt;1.0.0-beta3&lt;/langchain4j.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springboot 版本锁定 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;!-- langchain4j 版本锁定 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-bom&lt;/artifactId&gt; &lt;version&gt;${langchain4j.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j springboot 启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j 响应式编程 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-reactor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j openai 接入 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- langchain4j milvus 接入 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-milvus-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${langchain4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- langchain4j tavily 搜索引擎接入 --&gt; &lt;dependency&gt; &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt; &lt;artifactId&gt;langchain4j-web-search-engine-tavily&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml123456789101112131415161718192021222324252627282930313233343536373839404142spring: application: name: langchain4j-rag-examplelangchain4j: open-ai: # 大模型 chat-model: base-url: https://api.deepseek.com/v1 api-key: [deepseek api key] model-name: deepseek-chat log-requests: true log-responses: true # 流式大模型 streaming-chat-model: base-url: https://api.deepseek.com/v1 api-key: [deepseek api key] model-name: deepseek-chat log-requests: true log-responses: true # 内嵌模型 embedding-model: base-url: https://dashscope.aliyuncs.com/compatible-mode/v1 api-key: [embedding api key] model-name: text-embedding-v3 max-segments-per-batch: 5 dimensions: 1024 # 内嵌数据库 milvus: host: [自建 milvus 数据库主机地址] port: 19530 database-name: rag collection-name: java dimension: 1024 # 最大搜索结果数 max-results: 10# 网络搜索引擎tavily: # 最大搜索结果数 max-results: 10 api-key: [tavily api key] 监听器 langchain4j 提供了一个监听器接口(dev.langchain4j.model.chat.listener.ChatModelListener)，可以让开发者监听与大模型的交互过程 下面的代码在请求和响应的时候打印了请求的消息对象。我们可以从中观察整个 RAG 过程和大模型交互的次数，以及中间过程的处理结果 123456789101112131415161718192021222324252627282930/** * 大模型交互监听器 * * @author wuhunyu * @date 2025/06/08 11:21 **/@Component(&quot;myChatModelListener&quot;)@Slf4jpublic class MyChatModelListener implements ChatModelListener { @Override public void onRequest(final ChatModelRequestContext requestContext) { final var chatRequest = requestContext.chatRequest(); var messages = chatRequest.messages(); log.debug(&quot;onRequest: {}&quot;, messages); } @Override public void onResponse(final ChatModelResponseContext responseContext) { final var chatResponse = responseContext.chatResponse(); var aiMessage = chatResponse.aiMessage(); log.debug(&quot;onResponse: {}&quot;, aiMessage); } @Override public void onError(final ChatModelErrorContext errorContext) { ChatModelListener.super.onError(errorContext); }} bean 配置 这个配置类注入了一些 langchain4j 的 bean，在高级语法和低级组件中都有用到 具体 bean 的作用可以看注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** * rag bean 配置 * * @author wuhunyu * @date 2025/06/08 10:44 **/@Configuration@EnableConfigurationProperties(RAGBeanConfig.TavilyProperties.class)public class RAGBeanConfig { // 消息存储，此处为内存存储 @Bean(&quot;chatMemoryStore&quot;) public ChatMemoryStore chatMemoryStore() { return new InMemoryChatMemoryStore(); } // 用于隔离不同的用户会话消息。也可使用 MessageWindowChatMemory 实现用来替换 TokenWindowChatMemory @Bean(&quot;chatMemoryProvider&quot;) public ChatMemoryProvider chatMemoryProvider(ChatMemoryStore chatMemoryStore) { return memoryId -&gt; TokenWindowChatMemory.builder() .chatMemoryStore(chatMemoryStore) .maxTokens(10240, new OpenAiTokenizer(OpenAiChatModelName.GPT_4)) .build(); } // Query 转换器。也可以换用 ExpandingQueryTransformer 进行 Query 扩展 @Bean(&quot;queryTransformer&quot;) public QueryTransformer queryTransformer(ChatLanguageModel chatLanguageModel) { return new CompressingQueryTransformer(chatLanguageModel); } @Data @NoArgsConstructor @AllArgsConstructor @ConfigurationProperties(&quot;tavily&quot;) public static class TavilyProperties { private Integer maxResults; private String apiKey; } // web 搜索引擎，此处选择的是 tavily 搜索引擎 @Bean(&quot;webSearchContentRetriever&quot;) public WebSearchContentRetriever webSearchContentRetriever(TavilyProperties tavilyProperties) { final var tavilyWebSearchEngine = TavilyWebSearchEngine.builder() .apiKey(tavilyProperties.getApiKey()) .build(); return WebSearchContentRetriever.builder() .maxResults(tavilyProperties.getMaxResults()) .webSearchEngine(tavilyWebSearchEngine) .build(); } // 内嵌数据库检索器，此处选择的是 milvus 数据库 @Bean(&quot;embeddingStoreContentRetriever&quot;) public EmbeddingStoreContentRetriever embeddingStoreContentRetriever( @Value(&quot;${langchain4j.milvus.max-results:50}&quot;) Integer maxResults, MilvusEmbeddingStore milvusEmbeddingStore, EmbeddingModel embeddingModel ) { return EmbeddingStoreContentRetriever.builder() .embeddingStore(milvusEmbeddingStore) .embeddingModel(embeddingModel) .maxResults(maxResults) .build(); } // Query 路由，让大模型决定选择哪一个检索器或者哪几个检索器。retrieverToDescription 属性的 key 为检索器，value 为检索器的描述 @Bean(&quot;queryRouter&quot;) public QueryRouter queryRouter( ChatLanguageModel chatLanguageModel, WebSearchContentRetriever webSearchContentRetriever, EmbeddingStoreContentRetriever embeddingStoreContentRetriever ) { return LanguageModelQueryRouter.builder() .chatLanguageModel(chatLanguageModel) .retrieverToDescription(Map.of( webSearchContentRetriever, &quot;Web Search&quot;, embeddingStoreContentRetriever, &quot;Embedding Database&quot; )) .build(); } // content 聚合器，如果有 ReRanking 模型，也可以选择使用 ReRankingContentAggregator 对检索结果进行排序 @Bean(&quot;contentAggregator&quot;) public ContentAggregator contentAggregator() { return new DefaultContentAggregator(); } // content 注入器，可以自定义注入内容的模型 @Bean(&quot;contentInjector&quot;) public ContentInjector contentInjector() { return new DefaultContentInjector(); } // 检索增强器，简单理解为把上面的几个组件联系到一起协作处理 Query，最终返回增强后的 ChatMessage @Bean(&quot;retrievalAugmentor&quot;) public RetrievalAugmentor retrievalAugmentor( QueryTransformer queryTransformer, QueryRouter queryRouter, ContentAggregator contentAggregator, ContentInjector contentInjector ) { // 自定义线程池 final var threadFactory = new CustomizableThreadFactory(&quot;retrievalAugmentor-&quot;); final var executorService = Executors.newThreadPerTaskExecutor(threadFactory); return DefaultRetrievalAugmentor.builder() .queryTransformer(queryTransformer) .queryRouter(queryRouter) .contentAggregator(contentAggregator) .contentInjector(contentInjector) .executor(executorService) .build(); }} 高级语法1234567891011121314151617181920/** * 高级 langchain4j 编程 * * @author wuhunyu * @date 2025/06/08 11:23 **/@AiService( wiringMode = AiServiceWiringMode.EXPLICIT, chatModel = &quot;openAiChatModel&quot;, streamingChatModel = &quot;openAiStreamingChatModel&quot;, chatMemoryProvider = &quot;chatMemoryProvider&quot;, retrievalAugmentor = &quot;retrievalAugmentor&quot;)public interface AdvanceLLMService { @SystemMessage(&quot;你是一个知识渊博的助手，请通俗易懂地回答我的问题。&quot;) TokenStream streamChat(@MemoryId Long userId, @UserMessage String userMessage);} 高级语法主要的配置在 @AiService 这个注解上 chatModel 和 streamingChatModel 分别表示非流式大模型对象和流式大模型对象。这么说可能会有一些歧义。大模型都是支持流式返回的，可以称为同步返回和异步一点一点返回，带 streaming 前缀的就是一步一点一点返回的 chatMemoryProvider 用来区别不同的会话 retrievalAugmentor 检索增强，RAG 的核心实现就是这个组件，后续低级写法中，也是对这个组件进行分解成多个基础组件并手动编码实现同样的效果 userId 参数是用来区别不同的会话使用的，通过同一个 id 值会讲历史的对话记录一并发送给大模型 userMessage 参数是实际用户的提问 方法顶上的 @SystemMessage 注解表示一个系统消息，在优先级上要高于普通的用户消息 TokenStream 类型的响应值表示这是一个流式的返回 那么，让我们试一下这个高级语法实现的 RAG 效果如何 我们新增一个请求路由来调用这个方法 请求路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * rag * * @author wuhunyu * @date 2025/06/08 11:35 **/@RestController@RequestMapping(&quot;/rag&quot;)@RequiredArgsConstructor@Slf4jpublic class RAGController { private final AdvanceLLMService advanceLLMService; @Data @NoArgsConstructor @AllArgsConstructor public static class UserMessageRequest implements Serializable { @Serial private static final long serialVersionUID = -8569299218617670092L; /** * 用户id */ private Long userId; /** * 消息 */ private String message; } @PostMapping(value = &quot;/advance&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public SseEmitter advance(@RequestBody UserMessageRequest userMessageRequest) { final var tokenStream = advanceLLMService.streamChat( userMessageRequest.getUserId(), userMessageRequest.getMessage() ); // 结果返回 final var sseEmitter = new SseEmitter(-1L); tokenStream.onPartialResponse(s -&gt; { try { sseEmitter.send( SseEmitter.event() .data(s) .build() ); } catch (IOException e) { throw new RuntimeException(e); } }) .onCompleteResponse(chatResponse -&gt; { log.info(&quot;chatResponse: {}&quot;, chatResponse.aiMessage().text()); sseEmitter.complete(); }) .onError(throwable -&gt; { sseEmitter.complete(); log.error(&quot;&quot;, throwable); }); tokenStream.start(); return sseEmitter; }} 这时候内嵌数据库还是没数据的状态，尝试询问大模型一个有关 jvm 的问题 发起一个 POST 请求，如下 123456curl --location --request POST 'http://localhost:8080/rag/advance' \\--header 'Content-Type: application/json' \\--data-raw '{ &quot;userId&quot;: 1, &quot;message&quot;: &quot;请简单地描述一下 jvm 是什么&quot;}' 此前我们配置了一个监听器，让我们来看看都和大模型交互了一些什么信息 问题路由 可以看到，发送了一个选择给大模型，选择的条件是我的问题本身 123452025-06-08 20:27:07.224 [http-nio-8080-exec-2] DEBUG top.wuhunyu.rag.listener.MyChatModelListener - onRequest: [UserMessage { name = null contents = [TextContent { text = &quot;Based on the user query, determine the most suitable data source(s) to retrieve relevant information from the following options:1: Web Search2: Embedding DatabaseIt is very important that your answer consists of either a single number or multiple numbers separated by commas and nothing else!User query: 请简单地描述一下 jvm 是什么&quot; }] }] 而此次询问大模型返回的结果是 12025-06-08 20:27:11.492 [http-nio-8080-exec-2] DEBUG top.wuhunyu.rag.listener.MyChatModelListener - onResponse: AiMessage { text = &quot;1,2&quot; toolExecutionRequests = null } 也就是大模型角色有必要从 Web Search 和 Embedding Database 两个数据来源中获取数据 接下来，便是分别从两个数据来源获取响应的结果，然后进行排序，注入，最后再发送给大模型，由大模型进行总结 最后的请求和响应日志都太长了，这里就不贴出来了 在请求调试工具中， SSE 的返回结果形如 1234567891011121314151617181920212223242526data:Jdata:VMdata:（data:Javadata: Virtualdata: Machinedata:，data:Javadata: data:虚拟机data:）data:是data: Java... function call 上面这次问题，在内嵌数据库中，并没有查询到任何数据。这点可以通过日志观察得出来，最后一次提问中，发送给大模型的提示词中，并没有包含 web 的数据来源，而来源于 web 搜索的数据都会有一个网站的来源。比如 12345深入理解HotSpot JVM 基本原理 - 腾讯云它保存所有被JVM加载的类和接口的运行时常量池，成员变量以及方法的信息，静态变量以及方法的字节码。JVM的提供者可以通过不同的方式来实现方法区。在Oracle 的HotSpot JVM里，方法区被称为永久区或者永久代（PermGen）。doocs/jvm: JVM 底层原理最全知识总结 - GitHub🤗 JVM 底层原理最全知识总结. Contribute to doocs/jvm development by creating an account on GitHub. 表明了这两条数据分别来源于 腾讯云 和 GitHub 现在让我们利用 tool 将文档向量化并写入内嵌数据库中，不过在使用 tool 之前，我们需要先声明 本地工具 LocalFileHandlerTool 这个工具属于 langchain4j 的高级语法，低级写法太麻烦了，个人也推荐使用注解的方式描述工具 只有两个功能 列出服务器指定的路径下的所有文件 将指定的文件索引到内嵌数据库中。这里的内嵌数据库指的是环境准备中的 milvus 数据库 实现中，代码有一个 PATH 常量，需要替换成自己机器上的路径，需要这个路径下有一些文档文件（比如 word，pdf，markdown等格式的文件），便于向量化然后写入到内嵌数据库中 其中标注了 @Tool 注解的便是一个 tool，可以通过 @P 注解对入参进行描述 最后给到大模型的是一个 json 格式的工具描述，可以自行断点观察 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 本地文件处理 * * @author wuhunyu * @date 2025/06/08 11:18 **/@Component(&quot;localFileHandlerTool&quot;)@RequiredArgsConstructor@Slf4jpublic class LocalFileHandlerTool { public static final String PATH = &quot;/Users/wuhunyu/WorkSpace/learn&quot;; private final EmbeddingModel embeddingModel; private final MilvusEmbeddingStore milvusEmbeddingStore; @Tool(&quot;列出目录下的所有文件&quot;) @SuppressWarnings(&quot;all&quot;) public List&lt;String&gt; listDir() { return Arrays.stream( new File(PATH).listFiles() ) .filter(File::isFile) .map(File::getName) .toList(); } @Tool(&quot;获取指定文件名的大小，单位：字节。当文件不存在或者不可读时，返回 -1&quot;) public Long fileSize(@P(&quot;文件名称&quot;) String fileName) { if (!this.isFile(fileName)) { return -1L; } return new File(this.getCompleteFileName(fileName)).length(); } private boolean isFile(String fileName) { fileName = this.getCompleteFileName(fileName); if (StringUtils.isBlank(fileName)) { return false; } final var file = new File(fileName); return file.exists() &amp;&amp; file.isFile() &amp;&amp; file.canRead(); } private String getCompleteFileName(String fileName) { return PATH + File.separator + fileName; } @Tool(&quot;将指定文件的内容存放至 embedding 数据库中。操作成功时，返回 success，其他返回都为错误信息&quot;) public String toEmbedding(@P(&quot;文件名称&quot;) String fileName) { if (!this.isFile(fileName)) { return &quot;文件不存在&quot;; } try { // 加载文档 final var document = FileSystemDocumentLoader.loadDocument( this.getCompleteFileName(fileName), new TextDocumentParser() ); // 文档拆分器 DocumentBySentenceSplitter documentBySentenceSplitter = new DocumentBySentenceSplitter( 300, 100, new OpenAiTokenizer(OpenAiEmbeddingModelName.TEXT_EMBEDDING_3_SMALL)); // 文档拆分，并添加 source 元数据 var textSegments = documentBySentenceSplitter.split(document) .stream() .peek(textSegment -&gt; { Metadata metadata = textSegment.metadata(); metadata.put(&quot;source&quot;, fileName); }) .toList(); // 添加到 内嵌数据库 中 var listResponse = embeddingModel.embedAll(textSegments); milvusEmbeddingStore.addAll(listResponse.content(), textSegments); // 返回成功 return &quot;success&quot;; } catch (Exception e) { log.error(&quot;读取本地文档 {} 到内嵌数据库失败: &quot;, fileName, e); return e.getMessage(); } }} 新增一个内嵌数据服务 EmbeddingService 不知道你看出来和 AdvanceLLMService 的区别了吗 本质区别就是少了 retrievalAugmentor 属性，多了 tools 属性 为什么要这么做呢，不能合并成一个吗？ 由于 retrievalAugmentor 内部会做各种动作对最初的提问进行增强，很可能会干扰大模型的判断，所以我们需要一个比较干净的上下文环境减少大模型的误判断 123456789101112131415161718192021/** * 内嵌数据准备 * * @author gongzhiqiang * @date 2025/06/08 20:45 **/@AiService( wiringMode = AiServiceWiringMode.EXPLICIT, chatModel = &quot;openAiChatModel&quot;, streamingChatModel = &quot;openAiStreamingChatModel&quot;, chatMemoryProvider = &quot;chatMemoryProvider&quot;, tools = { &quot;localFileHandlerTool&quot; })public interface EmbeddingService { Result&lt;String&gt; chat(@MemoryId Long userId, @UserMessage String userMessage);} 在请求路由上添加一个调用 12345@PostMapping(&quot;/embedding-tool&quot;)public String embeddingTool(@RequestBody UserMessageRequest userMessageRequest) { final var result = embeddingService.chat(userMessageRequest.getUserId(), userMessageRequest.getMessage()); return result.content();} 先要大模型列出路径下的全部文件 123456curl --location --request POST 'http://localhost:8080/rag/embedding-tool' \\--header 'Content-Type: application/json' \\--data-raw '{ &quot;userId&quot;: 2, &quot;message&quot;: &quot;列出全部的文件&quot;}' 结果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748当前目录下的文件列表如下：1. Kafka.md2. MyBatis.md3. ArchLinux.md4. Docker操作命令.md5. JVM类的加载过程.md6. Go.md7. Java程序员-xxx.md8. SpringMVC.md9. Zookeeper2.md10. Spring5.md11. JVM字节码与类的加载篇.md12. JUC.md13. 面试积累.md14. Redis.md15. SpringBoot.md16. 二叉树前中后序遍历.md17. nginx.md18. Java工程师-xxx.md19. JVM内存与垃圾回收篇.md20. Java8新特性.md21. SpringSecurity.md22. MySQL.md23. ITX主机计划.md24. JVM.md25. 面试小笔记.md26. Linux.md27. JVM性能调优.md28. Maven.md29. C语言.md30. JVM运行时参数.md31. Git.md32. 工作经历-xxx.md33. ElasticSearch.md34. RabbiMQ.md35. Docker.md36. SpringCloud.md37. 反射.md38. 面试学习.md39. 实战开发.md40. NIO.md41. Spring简单整合MyBatis(基于xml方式).md42. MySQL调优.md43. Zookeeper.md44. 个人笔记.md如果需要进一步操作（如获取文件大小或嵌入内容），请告诉我！ 将 19 号文件加载到内嵌数据库中 123456curl --location --request POST 'http://localhost:8080/rag/embedding-tool' \\--header 'Content-Type: application/json' \\--data-raw '{ &quot;userId&quot;: 2, &quot;message&quot;: &quot;将 19 号文件加载到内嵌数据库中&quot;}' 结果如下 再次询问 请简单地描述一下 jvm 是什么 123456curl --location --request POST 'http://localhost:8080/rag/advance' \\--header 'Content-Type: application/json' \\--data-raw '{ &quot;userId&quot;: 1, &quot;message&quot;: &quot;请简单地描述一下 jvm 是什么&quot;}' 可以在控制台观察到最后发送给大模型的消息中，除了标记由来源的消息，也有不携带消息来源的消息，这些不携带消息来源的消息就是来源于内嵌数据库中 低级写法 所谓低级写法，就是将 @AiService 注解实现的功能用编码的方式手动实现一遍 此处只给出代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * langchain4j 低级写法 * * @author wuhunyu * @date 2025/06/08 12:23 **/@Component(&quot;basicLLMService&quot;)@RequiredArgsConstructor@Slf4jpublic class BasicLLMService { private final ChatLanguageModel chatLanguageModel; private final QueryTransformer queryTransformer; private final ChatMemoryProvider chatMemoryProvider; private final QueryRouter queryRouter; private final ContentAggregator contentAggregator; private final ContentInjector contentInjector; public String chat(Long userId, String message) { Query query = Query.from( message, Metadata.from( UserMessage.from(message), userId, chatMemoryProvider.get(userId) .messages() ) ); // transform Collection&lt;Query&gt; queries = queryTransformer.transform(query); // query router Map&lt;Query, Collection&lt;List&lt;Content&gt;&gt;&gt; query2Contents = new HashMap&lt;&gt;(); for (Query curQuery : queries) { Collection&lt;ContentRetriever&gt; contentRetrievers = queryRouter.route(curQuery); List&lt;List&lt;Content&gt;&gt; contents = new ArrayList&lt;&gt;(); for (ContentRetriever contentRetriever : contentRetrievers) { contents.add(contentRetriever.retrieve(curQuery)); } query2Contents.put(curQuery, contents); } // content aggregator List&lt;Content&gt; finalContents = contentAggregator.aggregate(query2Contents); // content injector ChatMessage userMessage = contentInjector.inject( finalContents, UserMessage.from(message) ); // 系统消息 var systemMessage = SystemMessage.from( &quot;&quot;&quot; 你是一个知识渊博的助手，请通俗易懂地回答我的问题。 &quot;&quot;&quot; ); // 历史消息 final var messages = chatMemoryProvider.get(userId) .messages(); if (CollectionUtils.isEmpty(messages)) { // 第一次提问 messages.add(systemMessage); } messages.add(userMessage); // chat ChatRequest chatRequest = ChatRequest.builder() .messages(messages) .build(); // response return chatLanguageModel.chat(chatRequest) .aiMessage() .text(); }} 总结本文先按作者自己的理解讲述了对 langchain4j 框架的 RAG 实现流程以及各个组件的作用 然后通过编码的方式实现了一个简单的 RAG 例子，基本用上了 langchain4j 的大多组件 遇到的问题 超出最大窗口大小 项目中使用的对话记忆方案是 TokenWindowChatMemory，最大的 token 被设置为了 10240。如果把 langchain4j.milvus.max-results 和 tavily.max-results 都调整成 50，可以观察到一个很诡异的事情是明明网络搜索和内嵌数据库搜索一共 100 条记录，最后却没有发送给大模型 其实问题出在上图中的 chatMemory.add(userMessage) 代码(图中 175 行)。由于 100 条记录的长度超出了 10240 长度，因此被丢弃了这部分消息 在生产开发过程中，还是需要注意一下最大窗口问题 适配 OpenAI API OpenAI API 的官方文档地址是 https://platform.openai.com/docs/api-reference/chat/create 在 langchain4j-open-ai-spring-boot-starter 依赖中，提供了 dev.langchain4j.model.openai.internal.chat.ChatCompletionRequest 和 dev.langchain4j.model.openai.internal.chat.ChatCompletionResponse 作为请求体类型和响应类型 一切都很完美是不是，我们需要实现 OpenAI API 接口的话，可以直接利用这两个类而不需要自己编写又臭又长还可能出错的 VO 类 但我现在要给你拨一瓢冷水了，dev.langchain4j.model.openai.internal.chat.ChatCompletionRequest#messages 的类型是一个接口，这意味着网络请求在反序列化时不清楚到底应该使用哪一个实现，因此不对它进行改造是会出错的 你可以将这个接口替换为某个实现类以修复这个问题 高级语法无法传递 ChatRequestParameters 参数 12345678910111213141516171819202122232425262728293031@Experimentalpublic interface ChatRequestParameters { String modelName(); Double temperature(); Double topP(); Integer topK(); Double frequencyPenalty(); Double presencePenalty(); Integer maxOutputTokens(); List&lt;String&gt; stopSequences(); List&lt;ToolSpecification&gt; toolSpecifications(); ToolChoice toolChoice(); ResponseFormat responseFormat(); static DefaultChatRequestParameters.Builder&lt;?&gt; builder() { return new DefaultChatRequestParameters.Builder&lt;&gt;(); } ChatRequestParameters overrideWith(ChatRequestParameters parameters);} 如果你使用过 Gemini 网页版或者像是 Cherry Studio 这样的客户端，应该能注意到在和大模型对话时，是可以调整一些参数的，比如 temperature，maxOutputTokens 等 langchain4j 所谓的高级语法主要是基于 @AiService 这个注解。而这个注解的处理类是 dev.langchain4j.service.DefaultAiServices 以非流式对话为例（代码片段为 dev.langchain4j.service.DefaultAiServices 的 214 行到 224 行） 1234567891011ChatRequestParameters parameters = ChatRequestParameters.builder() .toolSpecifications(toolExecutionContext.toolSpecifications()) .responseFormat(responseFormat) .build();ChatRequest chatRequest = ChatRequest.builder() .messages(messages) .parameters(parameters) .build();ChatResponse chatResponse = context.chatModel.chat(chatRequest); 看出来了没，ChatRequestParameters 构建时就没有注入 temperature，maxOutputTokens 等这些参数 也就是说，使用高级语法时，是无法实现对这些参数进行调整的 同样，我在 langchain4j 仓库中找到了一个 issue 有一个评论是这样的 1Response&lt;AiMessage&gt; chat(@UserMessage String userMessage, @ChatRequestParams ChatRequestParameters params); @ChatRequestParams 在 langchain4j 中是不存在的，这位兄弟想要通过注解的方式实现自定义 ChatRequestParameters 但目前这个 issue 还是 open 状态，目前如果有微调参数的需要，还是只能使用低级语法 不过值得注意的是，并不是所有大模型都支持这些参数的调整 项目代码GitHub 参考langchain4j 官网","link":"/ai/rag/2025/06/langchain4j-rag-example/index.html"},{"title":"Langgraph4j Getting Started","text":"欢迎来到 LangGraph4j！本指南将帮助您理解 LangGraph4j 的核心概念、进行安装，并构建您的第一个应用程序。 引言LangGraph4j 是一个用于通过大型语言模型 (LLMs) 构建有状态、多代理应用的 Java 库。它受到 Python 库 LangGraph 的启发，并旨在与 Langchain4j 和 Spring AI 等流行的 Java LLM 框架无缝协作。 其核心在于，LangGraph4j 允许您定义循环图 (cyclical graphs)，在图中，不同的组件（代理、工具或自定义逻辑）可以以有状态的方式进行交互。这对于构建需要记忆、上下文以及不同“代理”之间协作或交接任务能力的复杂应用程序至关重要。 核心功能与优势LangGraph4j 提供了多项功能和优势： 有状态执行 (Stateful Execution): 在图节点之间管理和更新共享状态，从而实现记忆和上下文感知。 循环图 (Cyclical Graphs): 与传统的有向无环图 (DAGs) 不同，LangGraph4j 支持循环，这对于基于代理的架构至关重要，因为在这些架构中控制流可以回溯（例如，代理重试任务或请求澄清）。 显式控制流 (Explicit Control Flow): 清晰地定义图节点之间转换的路径和条件。 模块化 (Modularity): 使用更小的、可复用的组件（节点）来构建复杂的系统。 灵活性 (Flexibility): 可与各种 LLM 提供商和自定义 Java 逻辑集成。 可观测性与调试 (Observability &amp; Debugging): 检查点 (Checkpoints): 在任何时间点保存图的状态，以便后续重放或检查。这对于调试和理解复杂的交互非常有价值。 图可视化 (Graph Visualization): 使用 PlantUML 或 Mermaid 生成图的可视化表示，以理解其结构。 异步与流式支持 (Asynchronous &amp; Streaming Support): 通过非阻塞操作和从 LLMs 流式传输结果来构建响应迅速的应用程序。 Playground &amp; Studio: 一个 Web UI，用于可视化地检查、运行和调试您的图。 核心概念详解理解这些概念是有效使用 LangGraph4j 的关键： StateGraph&lt;S extends AgentState&gt;StateGraph 是您用来定义应用程序结构的主要类。您可以在其中添加节点和边来创建图。它由一个 AgentState 进行参数化。 AgentStateAgentState（或继承自它的类）代表图的共享状态。它本质上是一个在节点间传递的映射 (Map&lt;String, Object&gt;)。每个节点都可以从该状态中读取数据，并返回对状态的更新。 模式 (Schema): 状态的结构由一个“模式”定义，该模式是一个 Map&lt;String, Channel.Reducer&gt;。映射中的每个键对应状态中的一个属性。 Channel.Reducer: 归约器 (reducer) 定义了状态属性的更新方式。例如，新值可能会覆盖旧值，或者被添加到一个现有值的列表中。 Channel.Default: 为尚未设置的状态属性提供一个默认值。 Channel.Appender / MessageChannel.Appender: 一种常见的归约器类型，它将新值追加到与状态属性关联的列表中。这对于累积消息、工具调用或其他数据序列非常有用。MessageChannel.Appender 专为聊天消息设计，还可以通过 ID 处理消息删除。 节点 (Nodes)节点是图中执行操作的构建块。一个节点通常是一个函数（或实现 NodeAction&lt;S&gt; 或 AsyncNodeAction&lt;S&gt; 的类），它会： 接收当前的 AgentState 作为输入。 执行某些计算（例如，调用 LLM、执行工具、运行自定义业务逻辑）。 返回一个 Map&lt;String, Object&gt;，代表对状态的更新。这些更新随后会根据模式中定义的归约器应用到 AgentState 上。 节点可以是同步的或异步的 (CompletableFuture)。 边 (Edges)边定义了节点之间的控制流。 普通边 (Normal Edges): 从一个节点到另一个节点的无条件转换。在节点 A 完成后，控制权总是传递给节点 B。您可以使用 addEdge(sourceNodeName, destinationNodeName) 来定义它们。 条件边 (Conditional Edges): 下一个节点根据当前的 AgentState 动态确定。在一个源节点完成后，会执行一个 EdgeAction&lt;S&gt;（或 AsyncEdgeAction&lt;S&gt;）函数。该函数接收当前状态并返回下一个要执行的节点的名称。这允许实现分支逻辑（例如，如果一个代理决定使用工具，则转到 “execute_tool” 节点；否则，转到 “respond_to_user” 节点）。条件边通过 addConditionalEdges(...) 定义。 入口点 (Entry Points): 您也可以使用 addConditionalEntryPoint(...) 为您的图定义条件入口点。 编译 (Compilation)在 StateGraph 中定义了所有节点和边之后，您需要将其 compile() 成一个 CompiledGraph&lt;S extends AgentState&gt;。这个编译后的图是您的逻辑的一个不可变的、可运行的表示。编译过程会验证图的结构（例如，检查是否存在孤立节点）。 检查点 (Persistence)LangGraph4j 允许您在任何步骤保存（Checkpoint）图的状态。这对于以下场景极为有用： 调试: 检查不同时间点的状态以了解发生了什么。 恢复: 将图恢复到先前的状态并继续执行。 长时间运行的进程: 持久化长时间运行的代理交互的状态。 您通常会使用一个 CheckpointSaver 的实现（例如，用于内存存储的 MemorySaver，或者您可以为持久化存储实现自己的版本）。 安装要在您的项目中使用 LangGraph4j，您需要将其添加为依赖项。 Maven: 请确保您使用的是 Java 17 或更高版本。 最新稳定版 (推荐): 123456789101112131415161718192021222324&lt;properties&gt; &lt;langgraph4j.version&gt;1.6.2&lt;/langgraph4j.version&gt; &lt;!-- 请检查实际的最新版本 --&gt;&lt;/properties&gt;&lt;!-- 可选：添加物料清单 (BOM) 来管理 langgraph4j 模块版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.bsc.langgraph4j&lt;/groupId&gt; &lt;artifactId&gt;langgraph4j-bom&lt;/artifactId&gt; &lt;version&gt;${langgraph4j.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.bsc.langgraph4j&lt;/groupId&gt; &lt;artifactId&gt;langgraph4j-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 如果需要，添加其他 langgraph4j 模块，例如 langgraph4j-langchain4j --&gt;&lt;/dependencies&gt; (注意：请随时访问 Maven 中央仓库查询最新的版本号。) 开发快照版: 如果您想使用最新的未发布功能，可以使用快照版本。 12345&lt;dependency&gt; &lt;groupId&gt;org.bsc.langgraph4j&lt;/groupId&gt; &lt;artifactId&gt;langgraph4j-core&lt;/artifactId&gt; &lt;version&gt;1.6-SNAPSHOT&lt;/version&gt; &lt;!-- 或当前的快照版本号 --&gt;&lt;/dependency&gt; 您可能需要在 settings.xml 或 pom.xml 中配置 Sonatype OSS 快照仓库： 123456789&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;sonatype-oss-snapshots&lt;/id&gt; &lt;url&gt;https://central.sonatype.com/repository/maven-snapshots&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 您的第一个图 - 简单示例让我们创建一个非常简单的图，它有两个节点：greeter 和 responder。greeter 节点将向状态中添加一条问候消息。responder 节点将根据问候语添加一条响应消息。 1. 定义状态: 我们的状态将持有一个消息列表。 12345678910111213141516171819202122232425262728import org.bsc.langgraph4j.state.AgentState;import org.bsc.langgraph4j.state.Channels;import org.bsc.langgraph4j.state.Channel;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.Optional;// 为我们的图定义状态class SimpleState extends AgentState { public static final String MESSAGES_KEY = &quot;messages&quot;; // 定义状态的模式。 // MESSAGES_KEY 将持有一个字符串列表，新消息将被追加到其中。 public static final Map&lt;String, Channel&lt;?&gt;&gt; SCHEMA = Map.of( MESSAGES_KEY, Channels.appender(ArrayList::new) ); public SimpleState(Map&lt;String, Object&gt; initData) { super(initData); } public List&lt;String&gt; messages() { return this.&lt;List&lt;String&gt;&gt;value(&quot;messages&quot;) .orElse( List.of() ); }} 2. 定义节点: 12345678910111213141516171819202122232425import org.bsc.langgraph4j.action.NodeAction;import java.util.Collections;import java.util.Map;// 添加问候语的节点class GreeterNode implements NodeAction&lt;SimpleState&gt; { @Override public Map&lt;String, Object&gt; apply(SimpleState state) { System.out.println(&quot;GreeterNode 正在执行。当前消息: &quot; + state.messages()); return Map.of(SimpleState.MESSAGES_KEY, &quot;Hello from GreeterNode!&quot;); }}// 添加响应的节点class ResponderNode implements NodeAction&lt;SimpleState&gt; { @Override public Map&lt;String, Object&gt; apply(SimpleState state) { System.out.println(&quot;ResponderNode 正在执行。当前消息: &quot; + state.messages()); List&lt;String&gt; currentMessages = state.messages(); if (currentMessages.contains(&quot;Hello from GreeterNode!&quot;)) { return Map.of(SimpleState.MESSAGES_KEY, &quot;Acknowledged greeting!&quot;); } return Map.of(SimpleState.MESSAGES_KEY, &quot;No greeting found.&quot;); }} 3. 定义并编译图: 1234567891011121314151617181920212223242526272829303132333435363738import org.bsc.langgraph4j.StateGraph;import org.bsc.langgraph4j.GraphStateException;import static org.bsc.langgraph4j.action.AsyncNodeAction.node_async;import static org.bsc.langgraph4j.StateGraph.START;import static org.bsc.langgraph4j.StateGraph.END;import java.util.List;import java.util.Map;public class SimpleGraphApp { public static void main(String[] args) throws GraphStateException { // 初始化节点 GreeterNode greeterNode = new GreeterNode(); ResponderNode responderNode = new ResponderNode(); // 定义图的结构 var stateGraph = new StateGraph&lt;&gt;(SimpleState.SCHEMA, initData -&gt; new SimpleState(initData)) .addNode(&quot;greeter&quot;, node_async(greeterNode)) .addNode(&quot;responder&quot;, node_async(responderNode)) // 定义边 .addEdge(START, &quot;greeter&quot;) // 从 greeter 节点开始 .addEdge(&quot;greeter&quot;, &quot;responder&quot;) .addEdge(&quot;responder&quot;, END) // 在 responder 节点后结束 ; // 编译图 var compiledGraph = stateGraph.compile(); // 运行图 // `stream` 方法返回一个 AsyncGenerator。 // 为简单起见，我们将收集结果。在实际应用中，您可能会在结果到达时即时处理它们。 // 在这里，我们关心的是执行后的最终状态项。 for (var item : compiledGraph.stream( Map.of( SimpleState.MESSAGES_KEY, &quot;Let's, begin!&quot; ) ) ) { System.out.println( item ); } }} 解释: 我们定义了 SimpleState，其中 MESSAGES_KEY 使用 AppenderChannel 来累积字符串。 GreeterNode 添加了一条 “Hello” 消息。 ResponderNode 检查是否存在问候语并添加一条确认消息。 我们定义了 StateGraph，添加了节点，并用边指定了流程：START -&gt; greeter -&gt; responder -&gt; END。 stateGraph.compile() 创建了可运行的 CompiledGraph。 compiledGraph.stream(initialState) 执行该图。我们遍历流以获取最终状态。流中的每一项都代表一个节点执行后的状态。 这个例子展示了基本的工作流程：定义状态、定义节点、用边连接它们、编译并运行。 运行您的图如示例所示，您通常使用以下执行方法之一来运行一个编译后的图： stream(S initialState, RunnableConfig config): 执行图并返回一个 AsyncGenerator&lt;S&gt;。每个产生 (yield) 的项都是一个节点完成后的状态 S。这对于观察每一步的状态或流式处理部分结果很有用。 invoke(S initialState, RunnableConfig config): 执行图并返回一个 CompletableFuture&lt;S&gt;，该 Future 在图到达 END 节点后，以最终状态完成。 RunnableConfig 可用于传入运行时配置。 Studio 🤩 - 可视化运行您的图Langgraph4j Studio 是一个可嵌入的 Web 应用程序，用于可视化和实验图： 要探索 Langgraph4j Studio，请访问 Studio。 额外福利: 内置集成LangChain4j作为验证 LangChain4j 集成的默认用例，我们使用 LangGraph4j 实现了 AgentExecutor（即 ReACT 代理）。在项目的模块中，您可以找到带有测试的完整工作代码。欢迎随时检出并将其用作参考。以下是 AgentExecutor 的使用示例。 定义工具 (Define Tools) 12345678910111213public class TestTool { @Tool(&quot;tool for test AI agent executor&quot;) String execTest(@P(&quot;test message&quot;) String message) { return format( &quot;test tool ('%s') executed with result 'OK'&quot;, message); } @Tool(&quot;return current number of system thread allocated by application&quot;) int threadCount() { return Thread.getAllStackTraces().size(); }} 运行代理 (Run Agent) 12345678910111213141516171819var model = OllamaChatModel.builder() .modelName( &quot;qwen2.5:7b&quot; ) .baseUrl(&quot;http://localhost:11434&quot;) .supportedCapabilities(Capability.RESPONSE_FORMAT_JSON_SCHEMA) .logRequests(true) .logResponses(true) .maxRetries(2) .temperature(0.0) .build();var agent = AgentExecutor.builder() .chatModel(model) .toolsFromObject(new TestTool()) .build() .compile();for (var item : agent.stream( Map.of( &quot;messages&quot;, &quot;perform test twice and return number of current active threads&quot; ) ) ) { System.out.println( item );} Spring AI作为验证 Spring AI 集成的默认用例，我们使用 LangGraph4j 实现了 AgentExecutor（即 ReACT 代理）。在项目的模块中，您可以找到带有测试的完整工作代码。欢迎随时检出并将其用作参考。以下是 AgentExecutor 的使用示例。 定义工具 (Define Tools) 12345678910111213public class TestTool { @Tool(description = &quot;tool for test AI agent executor&quot;) String execTest( @ToolParam(description =&quot;test message&quot;) String message ) { return format( &quot;test tool ('%s') executed with result 'OK'&quot;, message); } @Tool(description = &quot;return current number of system thread allocated by application&quot;) int threadCount() { return Thread.getAllStackTraces().size(); }} 运行代理 (Run Agent) 123456789101112131415161718var model = OllamaChatModel.builder() .ollamaApi(OllamaApi.builder().baseUrl(&quot;http://localhost:11434&quot;).build()) .defaultOptions(OllamaOptions.builder() .model(&quot;qwen2.5:7b&quot;) .temperature(0.1) .build()) .build();var agent = AgentExecutor.builder() .chatModel(model) .toolsFromObject(new TestTool()) .build() .compile() ;for (var item : agent.stream( Map.of( &quot;messages&quot;, &quot;perform test twice and return number of current active threads&quot; ) ) ) { System.out.println( item );} 关键能力概览LangGraph4j 包含了构建复杂代理应用的丰富功能： 异步操作: 节点和边可以是异步的（返回 CompletableFuture），从而允许非阻塞的 I/O 操作，尤其是在处理 LLM 调用时。 流式处理: 原生支持通过节点从 LLM 流式传输响应，实现实时输出。请参阅 how-tos/llm-streaming.ipynb。 检查点 (持久化与时间旅行): 保存和加载图的状态。这使您可以恢复长时间运行的任务，通过检查中间状态进行调试，甚至“时间旅行”到先前的状态。请参阅 how-tos/persistence.ipynb 和 how-tos/time-travel.ipynb。 图可视化: 生成图的 PlantUML 或 Mermaid 图表以可视化其结构，这有助于理解和调试。请参阅 how-tos/plantuml.ipynb。 Playground &amp; Studio: LangGraph4j 自带一个可嵌入的 Web UI (Studio)，允许您实时可视化、运行和与您的图进行交互。这对于开发和调试非常出色。 子图 (Child Graphs): 通过在父图的节点内嵌套更小的、可复用的图来构建复杂的图。这促进了模块化和可复用性。请参阅 how-tos/subgraph-as-nodeaction.ipynb、how-tos/subgraph-as-compiledgraph.ipynb 和 how-tos/subgraph-as-stategraph.ipynb 示例。 并行执行: 配置图的某些部分以并行执行多个节点，从而提高可以并发运行的任务的性能。请参阅 how-tos/parallel-branch.ipynb。 线程 (多轮对话): 在单个图实例中管理不同的、并行的执行线程，每个线程都有自己的检查点历史。这对于同时处理多个用户会话或对话至关重要。 后续步骤既然您对 LangGraph4j 有了基本的了解，您可以按照以下方式继续您的学习之旅： 探索 how-tos: 仓库中的 how-tos/ 目录包含了 Jupyter notebooks（可使用 IJava 等 Java 内核运行），通过代码示例演示了各种功能。 研究示例: 查看 samples/ 目录，获取更完整的应用程序示例，包括与 Langchain4j 和 Spring AI 的集成。 查阅 Javadocs: 有关类和方法的详细信息，请参阅 API 文档 (Javadocs)。（如果官方项目文档网站发生变化，链接可能需要更新） 动手实践！ 学习的最佳方式是实践。尝试修改示例或构建您自己的简单图。 我们希望本指南能帮助您开始使用 LangGraph4j。祝您构建愉快！","link":"/ai/rag/2025/09/langgraph4j-get-starter/index.html"},{"title":"Built-in types","text":"Dart 语言为以下类型提供了特殊支持： 数字（int, double） 字符串（String） 布尔值（bool） 记录（(value1, value2)） 函数（Function） 列表（List，也被称为数组） 集合（Set） 映射（Map） Rune（Runes；通常被 characters API 替代） Symbol（Symbol） null 值（Null） 这种支持包括使用字面量创建对象的能力。例如，'this is a string' 是一个字符串字面量，而 true 是一个布尔字面量。 因为 Dart 中的每个变量都指向一个对象——即一个类的实例——所以你通常可以使用构造函数来初始化变量。一些内置类型有它们自己的构造函数。例如，你可以使用 Map() 构造函数来创建一个映射。 其他一些类型在 Dart 语言中也扮演着特殊的角色： Object：除 Null 之外所有 Dart 类的超类。 Enum：所有枚举的超类。 Future 和 Stream：用于异步编程。 Iterable：用于 for-in 循环和同步生成器函数。 Never：表示一个表达式永远无法成功完成求值。最常用于总是抛出异常的函数。 dynamic：表示你想要禁用静态检查。通常你应该使用 Object 或 Object? 来替代。 void：表示一个值永远不会被使用。通常用作返回类型。 Object、Object?、Null 和 Never 类在类继承体系中扮演着特殊的角色。请在 理解空安全 中了解这些角色的作用。 数字Dart 的数字有两种类型： int不大于 64 位的整数值，具体取决于平台。在原生平台上，值的范围是 -263 到 263 - 1。在 Web 平台上，整数值被表示为 JavaScript 数字（没有小数部分的 64 位浮点数值），范围是 -253 到 253 - 1。double64 位（双精度）浮点数，遵循 IEEE 754 标准。int 和 double 都是 num 的子类型。num 类型包含了 +、-、/ 和 * 等基本运算符，你也可以在该类型中找到 abs()、ceil() 和 floor() 等方法。（位运算符，如 &gt;&gt;，则定义在 int 类中。）如果 num 及其子类型没有你想要的功能，可以看看 dart:math 库。 整数是没有小数点的数字。以下是一些定义整数字面量的示例： 12var x = 1;var hex = 0xDEADBEEF; 如果一个数字包含小数点，它就是 double 类型。以下是一些定义双精度浮点数字面量的示例： 12var y = 1.1;var exponents = 1.42e5; 你也可以将一个变量声明为 num 类型。如果这样做，该变量可以同时持有整数和双精度浮点数值。 12num x = 1; // x 可以同时持有 int 和 double 值x += 2.5; 在必要时，整数字面量会自动转换为双精度浮点数： 1double z = 1; // 等价于 double z = 1.0。 以下是如何将字符串转换为数字，反之亦然： 123456789101112131415// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14'); int 类型支持传统的按位移位（&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;）、取反（~）、与（&amp;）、或（|）以及异或（^）运算符，这些对于操作和屏蔽位域中的标志位非常有用。例如： 123assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 | 4) == 7); // 0011 | 0100 == 0111assert((3 &amp; 4) == 0); // 0011 &amp; 0100 == 0000 更多示例，请参见位和移位运算符部分。 数字字面量是编译时常量。许多算术表达式也是编译时常量，只要它们的操作数是能求值为数字的编译时常量即可。 123const msPerSecond = 1000;const secondsUntilRetry = 5;const msUntilRetry = secondsUntilRetry * msPerSecond; 更多信息，请参见 Dart 中的数字。 你可以使用一个或多个下划线 (_)作为数字分隔符，以使较长的数字字面量更具可读性。多个数字分隔符允许更高层次的分组。 12345var n1 = 1_000_000;var n2 = 0.000_000_000_01;var n3 = 0x00_14_22_01_23_45; // MAC 地址var n4 = 555_123_4567; // 美国电话号码var n5 = 100__000_000__000_000; // 一百个百万的百万！ 版本说明使用数字分隔符需要语言版本至少为 3.6。 字符串一个 Dart 字符串（String 对象）持有一系列的 UTF-16 码元。你可以使用单引号或双引号来创建一个字符串： 1234var s1 = 'Single quotes work well for string literals.';var s2 = &quot;Double quotes work just as well.&quot;;var s3 = 'It\\'s easy to escape the string delimiter.';var s4 = &quot;It's even easier to use the other delimiter.&quot;; 你可以使用 ${expression} 将表达式的值放入字符串中。如果表达式是一个标识符，你可以省略 {}。为了获取一个对象对应的字符串，Dart 会调用该对象的 toString() 方法。 12345678910111213var s = 'string interpolation';assert( 'Dart has $s, which is very handy.' == 'Dart has string interpolation, ' 'which is very handy.',);assert( 'That deserves all caps. ' '${s.toUpperCase()} is very handy!' == 'That deserves all caps. ' 'STRING INTERPOLATION is very handy!',); 注意== 运算符测试两个对象是否相等。如果两个字符串包含相同的码元序列，那么它们就是相等的。 你可以使用相邻的字符串字面量或 + 运算符来连接字符串： 123456789101112var s1 = 'String ' 'concatenation' &quot; works even over line breaks.&quot;;assert( s1 == 'String concatenation works even over ' 'line breaks.',);var s2 = 'The + operator ' + 'works, as well.';assert(s2 == 'The + operator works, as well.'); 要创建多行字符串，请使用带有单引号或双引号的三重引号： 1234567var s1 = '''You can createmulti-line strings like this one.''';var s2 = &quot;&quot;&quot;This is also amulti-line string.&quot;&quot;&quot;; 你可以通过在字符串前加上 r 来创建一个“原始”字符串： 1var s = r'In a raw string, not even \\n gets special treatment.'; 有关如何在字符串中表示 Unicode 字符的详细信息，请参见 Rune 和字形簇。 字符串字面量是编译时常量，只要任何插值表达式是求值为 null 或数字、字符串、布尔值的编译时常量即可。 12345678910111213// 这些在 const 字符串中是有效的。const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';// 这些在 const 字符串中是无效的。var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3];const validConstString = '$aConstNum $aConstBool $aConstString';// const invalidConstString = '$aNum $aBool $aString $aConstList'; 有关使用字符串的更多信息，请查阅字符串和正则表达式。 布尔值为了表示布尔值，Dart 有一个名为 bool 的类型。只有两个对象是 bool 类型：布尔字面量 true 和 false，它们都是编译时常量。 Dart 的类型安全意味着你不能使用像 if (nonbooleanValue) 或 assert (nonbooleanValue) 这样的代码。相反，你应该明确地检查值，像这样： 123456789101112131415// 检查空字符串。var fullName = '';assert(fullName.isEmpty);// 检查零。var hitPoints = 0;assert(hitPoints == 0);// 检查 null。var unicorn = null;assert(unicorn == null);// 检查 NaN。var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); Rune 和字形簇在 Dart 中，Rune 用于公开字符串的 Unicode 码位。你可以使用 characters 包来查看或操作用户感知的字符，也称为 Unicode（扩展）字形簇。 Unicode 为世界上所有书写系统中使用的每个字母、数字和符号都定义了一个唯一的数值。因为 Dart 字符串是 UTF-16 码元的序列，所以在字符串中表示 Unicode 码位需要特殊的语法。表示一个 Unicode 码位的通常方式是 \\uXXXX，其中 XXXX 是一个 4 位的十六进制值。例如，心形字符 (♥) 是 \\u2665。要指定多于或少于 4 个十六进制数字，请将该值放在花括号中。例如，笑哭的表情符号 (😆) 是 \\u{1f606}。 如果你需要读取或写入单个 Unicode 字符，请使用由 characters 包在 String 上定义的 characters getter。返回的 Characters 对象是作为字形簇序列的字符串。以下是使用 characters API 的一个例子： 12345678import 'package:characters/characters.dart';void main() { var hi = 'Hi 🇩🇰'; print(hi); print('The end of the string: ${hi.substring(hi.length - 1)}'); print('The last character: ${hi.characters.last}');} 根据你的环境，输出大致如下： 1234dart run bin/main.dartHi 🇩🇰The end of the string: ???The last character: 🇩🇰 有关使用 characters 包操作字符串的详细信息，请参阅 characters 包的示例和 API 参考。 Symbol一个 Symbol 对象表示 Dart 程序中声明的运算符或标识符。你可能永远不需要使用 Symbol，但对于按名称引用标识符的 API 来说，它们是无价的，因为代码压缩会改变标识符的名称，但不会改变标识符的 Symbol。 要获取一个标识符的 Symbol，请使用 Symbol 字面量，它就是 # 后面跟着标识符： 12#radix#bar Symbol 字面量是编译时常量。","link":"/ai/dart/2025/09/built-in-types/index.html"},{"title":"Class modifiers for API maintainers","text":"Dart 3.0 增加了一些可以放置在类和 mixin 声明上的新修饰符。如果你是一个库包的作者，这些修饰符让你能更好地控制用户如何使用你的包所导出的类型。这可以使你的包更容易演进，也更容易知道对代码的更改是否会破坏用户。 Dart 3.0 还包含一个关于将类用作 mixin 的重大变更。这个变更可能不会破坏你的类，但可能会破坏你的类的用户。 本指南将带你了解这些变更，以便你知道如何使用新的修饰符，以及它们如何影响你的库的用户。 类上的 mixin 修饰符需要注意的最重要的修饰符是 mixin。在 Dart 3.0 之前的语言版本中，任何类都可以用在另一个类的 with 子句中作为 mixin，除非该类： 声明了任何非工厂构造函数。 继承了除 Object 之外的任何类。 这使得很容易意外地破坏别人的代码，因为你可能在为一个类添加构造函数或 extends 子句时，没有意识到其他人正在 with 子句中使用它。 Dart 3.0 不再默认允许类被用作 mixin。相反，你必须通过声明一个 mixin class 来显式地选择加入该行为： 1234mixin class Both {}class UseAsMixin with Both {}class UseAsSuperclass extends Both {} 如果你将你的包更新到 Dart 3.0 但不更改任何代码，你可能不会看到任何错误。但你可能会无意中破坏你包的用户，如果他们之前将你的类用作 mixin 的话。 迁移用作 mixin 的类如果一个类有非工厂构造函数、extends 子句或 with 子句，那么它已经不能被用作 mixin。其行为在 Dart 3.0 中不会改变；无需担心，也无需做任何事情。 实际上，这描述了大约 90% 的现有类。对于其余可以被用作 mixin 的类，你必须决定你想要支持什么。 这里有几个问题可以帮助你决定。第一个是 pragmatic 的： 你是否想冒着破坏任何用户的风险？ 如果答案是坚决的“不”，那么在所有可能被用作 mixin 的类前面加上 mixin。这完全保留了你的 API 的现有行为。 另一方面，如果你想借此机会重新思考你的 API 提供的功能，那么你可能不想把它变成一个 mixin class。考虑这两个设计问题： 你希望用户能够直接构造它的实例吗？ 换句话说，这个类是故意不设置为 abstract 的吗？ 你希望人们能够将该声明用作 mixin 吗？ 换句话说，你希望他们能够在 with 子句中使用它吗？ 如果两个问题的答案都是“是”，那么就把它变成一个 mixin class。如果第二个问题的答案是“否”，那么就让它保持为一个 class。如果第一个问题的答案是“否”而第二个是“是”，那么就把它从一个 class 改为一个 mixin 声明。 最后两个选项，即保持为 class 或将其变为纯 mixin，都是破坏性的 API 变更。如果你这样做，你需要提升你包的主版本号。 其他可选的修饰符处理用作 mixin 的类是 Dart 3.0 中唯一影响你包 API 的关键变更。到这里，如果你不想对你的包允许用户做什么进行其他更改，你就可以停下来了。 请注意，如果你继续并使用下面描述的任何修饰符，这都可能是对你包 API 的一个重大变更，需要增加主版本号。 interface 修饰符Dart 没有单独的语法来声明纯接口。相反，你声明一个恰好只包含抽象方法的 abstract class。当用户在你的包 API 中看到这个类时，他们可能不知道它是否包含可以通过继承来复用的代码，或者它是否意在用作接口。 你可以通过在类上加上 interface 修饰符来阐明这一点。这允许该类在 implements 子句中使用，但阻止它在 extends 中使用。 即使当类确实有非抽象方法时，你也可能希望阻止用户继承它。继承是软件中最强大的耦合之一，因为它能实现代码复用。但这种耦合也是危险和脆弱的。当继承跨越包边界时，要演进父类而不破坏子类可能会很困难。 将类标记为 interface 让用户可以构造它（除非它也被标记为 abstract）并实现该类的接口，但阻止他们复用它的任何代码。 当一个类被标记为 interface 时，在其声明所在的库内部，这个限制可以被忽略。在库内部，你可以自由地继承它，因为这都是你自己的代码，并且大概你知道你在做什么。该限制适用于其他包，甚至是你自己包内的其他库。 base 修饰符base 修饰符在某种程度上是 interface 的反面。它允许你在 extends 子句中使用该类，或在 with 子句中使用一个 mixin 或 mixin class。但是，它禁止类库之外的代码在 implements 子句中使用该类或 mixin。 这确保了你的类或 mixin 接口的每个实例都继承了你的实际实现。特别是，这意味着每个实例都将包含你的类或 mixin 声明的所有私有成员。这有助于防止可能发生的运行时错误。 考虑这个库： a.dart 123456789class A { void _privateMethod() { print('我继承自 A'); }}void callPrivateMethod(A a) { a._privateMethod();} 这段代码本身看起来没问题，但没有什么能阻止用户创建另一个像这样的库： b.dart 123456789import 'a.dart';class B implements A { // 没有实现 _privateMethod()！}main() { callPrivateMethod(B()); // 运行时异常！} 在类上添加 base 修饰符有助于防止这些运行时错误。与 interface 一样，你可以在 base 类或 mixin 声明的同一个库中忽略此限制。然后，同一库中的子类将被提醒去实现私有方法。但请注意，下一节的内容确实适用： Base 的传递性将一个类标记为 base 的目标是确保该类型的每个实例都具体地继承自它。为了维持这一点，base 的限制是“会传染的”。一个被标记为 base 的类型的每个子类型——无论是直接还是间接的——也必须阻止被实现。这意味着它必须被标记为 base（或 final 或 sealed，我们接下来会讲到）。 因此，将 base 应用于一个类型需要一些谨慎。它不仅影响用户能对你的类或 mixin 做什么，还影响他们的子类可以提供的功能。一旦你将 base 应用于一个类型，其下的整个层次结构都将被禁止实现。 这听起来很严格，但这是大多数其他编程语言一直以来的工作方式。大多数语言根本没有隐式接口，所以当你在 Java、C# 或其他语言中声明一个类时，你实际上也受到了同样的约束。 final 修饰符如果你想要 interface 和 base 的所有限制，你可以将一个类或 mixin class 标记为 final。这会阻止库外的任何人创建它的任何类型的子类型：不能在 implements、extends、with 或 on 子句中使用它。 这对类的用户来说是最具限制性的。他们能做的就只是构造它（除非它被标记为 abstract）。作为回报，作为类的维护者，你受到的限制最少。你可以添加新方法、将构造函数变为工厂构造函数等，而不用担心破坏任何下游用户。 sealed 修饰符最后一个修饰符 sealed 是特殊的。它主要用于在模式匹配中启用**穷尽性检查 (exhaustiveness checking)**。如果一个 switch 对一个被标记为 sealed 的类型的每个直接子类型都有 case，那么编译器就知道这个 switch 是穷尽的。 amigos.dart 12345678910111213sealed class Amigo {}class Lucky extends Amigo {}class Dusty extends Amigo {}class Ned extends Amigo {}String lastName(Amigo amigo) =&gt; switch (amigo) { Lucky _ =&gt; 'Day', Dusty _ =&gt; 'Bottoms', Ned _ =&gt; 'Nederlander',}; 这个 switch 对 Amigo 的每个子类型都有一个 case。编译器知道 Amigo 的每个实例都必须是这些子类型之一的实例，所以它知道这个 switch 是安全穷尽的，不需要任何最终的默认 case。 为了保证其健全性，编译器强制执行两个限制： sealed 类本身不能被直接构造。否则，你可能会有一个 Amigo 的实例，但它不是任何子类型的实例。所以每个 sealed 类也都是隐式 abstract 的。 sealed 类型的每个直接子类型都必须与 sealed 类型在同一个库中声明。这样，编译器才能找到它们全部。它知道没有其他隐藏的子类型会不匹配任何一个 case。 第二个限制类似于 final。像 final 一样，它意味着一个被标记为 sealed 的类不能在其声明的库之外被直接继承、实现或混入。但是，与 base 和 final 不同，它没有传递性限制： amigo.dart 1234sealed class Amigo {}class Lucky extends Amigo {}class Dusty extends Amigo {}class Ned extends Amigo {} other.dart 123456// 这是一个错误：class Bad extends Amigo {}// 但这两个都是可以的：class OtherLucky extends Lucky {}class OtherDusty implements Dusty {} 当然，如果你希望你的 sealed 类型的子类型也受到限制，你可以通过用 interface、base、final 或 sealed 来标记它们来实现。 sealed 与 final 的对比如果你有一个类，不希望用户能够直接对其进行子类型化，那么什么时候应该使用 sealed 而不是 final 呢？有几个简单的规则： 如果你希望用户能够直接构造该类的实例，那么它不能使用 sealed，因为 sealed 类型是隐式 abstract 的。 如果该类在你的库中没有子类型，那么使用 sealed 就没有意义，因为你无法从穷尽性检查中获益。 否则，如果该类确实有一些你定义的子类型，那么 sealed 很可能是你想要的。如果用户看到该类有几个子类型，那么能够将它们分别作为 switch 的 case 来处理，并让编译器知道整个类型都被覆盖了，会非常方便。 使用 sealed 确实意味着，如果你以后在库中添加另一个子类型，这将是一个破坏性的 API 变更。当一个新子类型出现时，所有那些现有的 switch 都会变得非穷尽，因为它们没有处理新的类型。这就像向一个枚举添加一个新值一样。 这些非穷尽的 switch 编译错误对用户很有用，因为它们能将用户的注意力引向他们代码中需要处理新类型的地方。 但这也意味着，每当你添加一个新的子类型，它都是一个重大变更。如果你希望能够以非破坏性的方式自由地添加新的子类型，那么最好用 final 而不是 sealed 来标记父类型。这意味着当用户对该父类型的值进行 switch 时，即使他们对所有已知的子类型都有 case，编译器也会强制他们添加一个默认的 case。这样，如果你以后添加更多的子类型，就会执行这个默认 case。 总结作为 API 设计者，这些新的修饰符让你能够控制用户如何使用你的代码，反过来，也让你能够演进你的代码而不破坏他们的代码。 但这些选项也带来了复杂性：作为 API 设计者，你现在有更多的选择要做。此外，由于这些功能是新的，我们仍然不知道最佳实践会是什么。每种语言的生态系统都不同，有不同的需求。 幸运的是，你不需要一次性把所有问题都搞清楚。我们特意选择了默认设置，这样即使你什么都不做，你的类也大多拥有与 3.0 之前相同的功能。如果你只是想保持你的 API 原样，就在那些已经支持混入的类上加上 mixin，然后就完成了。 随着时间的推移，当你感觉到你想要更精细的控制时，你可以考虑应用一些其他的修饰符： 使用 interface 来阻止用户复用你的类代码，同时允许他们重新实现其接口。 使用 base 来要求用户复用你的类代码，并确保你的类类型的每个实例都是该实际类或其子类的实例。 使用 final 来完全阻止一个类被继承。 使用 sealed 来选择对一个子类型家族进行穷尽性检查。 当你这样做时，发布你的包时请增加主版本号，因为这些修-符都意味着限制，而这些限制是重大变更。","link":"/ai/dart/2025/09/class-modifiers-for-apis/index.html"},{"title":"Class modifiers","text":"版本说明除了 abstract 之外，类修饰符需要 Dart 语言版本至少为 3.0。 类修饰符控制了类或 mixin 的使用方式，无论是在其自己的库内部，还是在其定义所在的库外部。 修饰符关键字位于类或 mixin 声明之前。例如，abstract class 定义了一个抽象类。可以出现在类声明之前的完整修饰符集合包括： abstract base final interface sealed mixin 只有 base 修饰符可以出现在 mixin 声明之前。这些修饰符不适用于其他声明，如 enum、typedef、extension 或 extension type。 在决定是否使用类修饰符时，请考虑类的预期用途以及该类需要依赖哪些行为。 提示如果你已经熟悉 Dart 的类修饰符，只想查看它们的组合行为大纲或复习一下，请查阅类修饰符参考。 如果你维护一个库，请阅读面向 API 维护者的类修饰符页面，以获取有关如何为你的库应对这些更改的指导。 无修饰符要允许在任何库中无限制地进行构造或子类型化，请使用不带修饰符的类或 mixin 声明。默认情况下，你可以： 构造类的新实例。 继承一个类以创建新的子类型。 实现一个类或 mixin 的接口。 混入一个 mixin 或 mixin class。 abstract要定义一个不需要为其整个接口提供完整、具体实现的类，请使用 abstract 修饰符。 抽象类不能在任何库中被构造，无论是其自己的库还是外部库。抽象类通常有抽象方法。 a.dart 123abstract class Vehicle { void moveForward(int meters);} b.dart 12345678910111213141516171819202122import 'a.dart';// 错误：`Vehicle` 不能被实例化，因为它被标记为 `abstract`。Vehicle myVehicle = Vehicle();// 可以被继承。class Car extends Vehicle { int passengers = 4; @override void moveForward(int meters) { // ... }}// 可以被实现。class MockVehicle implements Vehicle { @override void moveForward(int meters) { // ... }} 如果你希望你的抽象类看起来是可实例化的，请定义一个工厂构造函数。 base要强制继承一个类或 mixin 的实现，请使用 base 修饰符。base 类禁止在其自己的库之外被实现。这保证了： 每当创建该类的子类型的实例时，都会调用基类构造函数。 所有已实现的私有成员都存在于子类型中。 在基类中新增一个已实现的成员不会破坏子类型，因为所有子类型都会继承这个新成员。 除非子类型已经声明了一个同名且签名不兼容的成员。 你必须将任何实现或继承 base 类的类标记为 base、final 或 sealed。这可以防止外部库破坏 base 类的保证。 a.dart 12345base class Vehicle { void moveForward(int meters) { // ... }} b.dart 123456789101112131415161718import 'a.dart';// 可以被构造。Vehicle myVehicle = Vehicle();// 可以被继承。base class Car extends Vehicle { int passengers = 4; // ...}// 错误：`Vehicle` 不能在不同的库中被实现，因为它被标记为 `base`。base class MockVehicle implements Vehicle { @override void moveForward() { // ... }} interface要定义一个接口，请使用 interface 修饰符。接口定义库之外的库可以实现该接口，但不能继承它。这保证了： 当类的实例方法调用 this 上的另一个实例方法时，它将始终调用来自同一个库的已知方法实现。 其他库不能覆写 interface 类自己的方法后续可能以意想不到的方式调用的方法。这减少了脆弱基类问题。 a.dart 12345interface class Vehicle { void moveForward(int meters) { // ... }} b.dart 123456789101112131415161718import 'a.dart';// 可以被构造。Vehicle myVehicle = Vehicle();// 错误：`Vehicle` 不能在不同的库中被继承，因为它被标记为 `interface`。class Car extends Vehicle { int passengers = 4; // ...}// 可以被实现。class MockVehicle implements Vehicle { @override void moveForward(int meters) { // ... }} abstract interfaceinterface 修饰符最常见的用途是定义一个纯接口。将 interface 和 abstract 修饰符组合起来，可以得到一个**抽象接口类 (abstract interface class)**。 像 interface 类一样，其他库可以实现但不能继承一个纯接口。像 abstract 类一样，一个纯接口可以有抽象成员。 final要关闭类型层次结构，请使用 final 修饰符。这会阻止在当前库之外对类进行子类型化。同时禁止继承和实现，从而完全阻止了子类型化。这保证了： 你可以安全地对 API 进行增量更改。 你可以调用实例方法，并确信它们没有在第三方子类中被覆写。 final 类可以在同一个库中被继承或实现。final 修饰符包含了 base 的效果，因此任何子类也必须被标记为 base、final 或 sealed。 a.dart 12345final class Vehicle { void moveForward(int meters) { // ... }} b.dart 123456789101112131415161718import 'a.dart';// 可以被构造。Vehicle myVehicle = Vehicle();// 错误：`Vehicle` 不能在不同的库中被继承，因为它被标记为 `final`。class Car extends Vehicle { int passengers = 4; // ...}// 错误：`Vehicle` 不能在不同的库中被实现，因为它被标记为 `final`。class MockVehicle implements Vehicle { @override void moveForward(int meters) { // ... }} sealed要创建一个已知的、可枚举的子类型集合，请使用 sealed 修饰符。这允许你创建一个针对这些子类型的 switch 语句，并静态地确保其是**穷尽的 (exhaustive)**。 sealed 修饰符阻止一个类在其自己的库之外被继承或实现。密封类是隐式抽象的。 它们本身不能被构造。 它们可以有工厂构造函数。 它们可以为它们的子类定义构造函数。 然而，密封类的子类并不是隐式抽象的。 编译器知道所有可能的直接子类型，因为它们只能存在于同一个库中。这使得编译器能够在 switch 语句的 case 没有穷尽地处理所有可能的子类型时提醒你： 123456789101112131415161718192021222324252627sealed class Vehicle {}class Car extends Vehicle {}class Truck implements Vehicle {}class Bicycle extends Vehicle {}// 错误：`Vehicle` 不能被实例化，因为它被标记为 `sealed`，// 因此是隐式抽象的。Vehicle myVehicle = Vehicle();// sealed 类的子类可以被实例化，除非也受到限制。Vehicle myCar = Car();extension VehicleSounds on Vehicle { String get sound { // 错误：该 switch 语句没有穷尽地处理 // 所有可能的 `Vehicle` 类型对象。 // 在这个例子中，运行时类型为 `Bicycle` 的 `Vehicle` 对象 // 不会匹配任何一个 case。 return switch (this) { Car() =&gt; 'vroom', Truck() =&gt; 'VROOOOMM', }; }} 如果你不希望进行穷尽的 switch 检查，或者希望以后能够在不破坏 API 的情况下添加子类型，请使用 final 修饰符。更深入的比较，请阅读 sealed 与 final 的对比。 组合修饰符你可以组合一些修饰符以实现分层的限制。一个类声明可以按顺序包含： （可选）abstract，描述该类是否可以包含抽象成员并阻止实例化。 （可选）base、interface、final 或 sealed 之一，描述对其他库子类型化该类的限制。 （可选）mixin，描述该声明是否可以被混入。 class 关键字本身。 你不能组合某些修饰符，因为它们是矛盾的、冗余的或互斥的： abstract 和 sealed。一个 sealed 类是隐式抽象的。 interface、final 或 sealed 和 mixin。这些访问修饰符会阻止混入。 有关类修饰符如何组合的进一步指导，请查阅类修饰符参考。","link":"/ai/dart/2025/09/class-modifiers/index.html"},{"title":"Classes","text":"Dart 是一种面向对象的语言，拥有类和基于 mixin 的继承。每个对象都是一个类的实例，并且除了 Null 之外的所有类都派生自 Object。基于 mixin 的继承意味着尽管每个类（除了顶级类 Object?）都只有一个超类，但一个类的代码体可以在多个类层次结构中被复用。扩展方法是一种在不修改类或创建子类的情况下为类添加功能的方式。类修饰符允许你控制库如何对一个类进行子类型化。 使用类成员对象拥有由函数和数据组成的成员（分别为方法和实例变量）。当你调用一个方法时，你是在一个对象上调用 (invoke) 它：该方法可以访问该对象的函数和数据。 使用点号 (.) 来引用一个实例变量或方法： 1234567var p = Point(2, 2);// 获取 y 的值。assert(p.y == 2);// 在 p 上调用 distanceTo() 方法。double distance = p.distanceTo(Point(4, 4)); 当最左边的操作数可能为 null 时，使用 ?. 代替 . 来避免产生异常： 12// 如果 p 不为 null，则将其 y 值赋给一个变量。var a = p?.y; 使用构造函数你可以使用构造函数 (constructor) 来创建一个对象。构造函数的名称可以是 ClassName 或 ClassName.identifier。例如，下面的代码使用 Point() 和 Point.fromJson() 构造函数来创建 Point 对象： 12var p1 = Point(2, 2);var p2 = Point.fromJson({'x': 1, 'y': 2}); 下面的代码效果相同，但在构造函数名前使用了可选的 new 关键字： 12var p1 = new Point(2, 2);var p2 = new Point.fromJson({'x': 1, 'y': 2}); 有些类提供常量构造函数 (constant constructors)。要使用常量构造函数创建一个编译时常量，请在构造函数名前加上 const 关键字： 1var p = const ImmutablePoint(2, 2); 构造两个相同的编译时常量会产生一个单一的、规范的实例： 1234var a = const ImmutablePoint(1, 1);var b = const ImmutablePoint(1, 1);assert(identical(a, b)); // 它们是同一个实例！ 在常量上下文中，你可以省略构造函数或字面量之前的 const。例如，看这段创建了一个 const map 的代码： 12345// 这里有很多 const 关键字。const pointAndLine = const { 'point': const [const ImmutablePoint(0, 0)], 'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],}; 你可以省略掉除了第一个 const 关键字之外的所有 const： 12345// 只有一个 const，它建立了常量上下文。const pointAndLine = { 'point': [ImmutablePoint(0, 0)], 'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],}; 如果一个常量构造函数在常量上下文之外且未使用 const 调用，它会创建一个非常量对象： 1234var a = const ImmutablePoint(1, 1); // 创建一个常量var b = ImmutablePoint(1, 1); // 不会创建一个常量assert(!identical(a, b)); // 不是同一个实例！ 获取对象的类型要在运行时获取一个对象的类型，你可以使用 Object 的 runtimeType 属性，它会返回一个 Type 对象。 1print('The type of a is ${a.runtimeType}'); 警告使用类型测试操作符而不是 runtimeType 来测试对象的类型。在生产环境中，测试 object is Type 比测试 object.runtimeType == Type 更稳定。 到目前为止，你已经了解了如何使用类。本节的其余部分将展示如何实现类。 实例变量下面是你如何声明实例变量的方式： 12345class Point { double? x; // 声明实例变量 x，初始值为 null。 double? y; // 声明 y，初始值为 null。 double z = 0; // 声明 z，初始值为 0。} 一个使用可空类型声明但未初始化的实例变量，其值为 null。不可空的实例变量必须在声明时初始化。 所有实例变量都会生成一个隐式的 getter 方法。非 final 的实例变量和没有初始化器的 late final 实例变量还会生成一个隐式的 setter 方法。详情请查阅 Getters and setters。 1234567891011class Point { double? x; // 声明实例变量 x，初始值为 null。 double? y; // 声明 y，初始值为 null。}void main() { var point = Point(); point.x = 4; // 使用 x 的 setter 方法。 assert(point.x == 4); // 使用 x 的 getter 方法。 assert(point.y == null); // 值默认为 null。} 在声明处初始化一个非 late 的实例变量，会在实例创建时、在构造函数及其初始化列表执行之前设置该值。因此，一个非 late 实例变量的初始化表达式（= 之后的部分）不能访问 this。 123456789101112131415double initialX = 1.5;class Point { // OK，可以访问不依赖 `this` 的声明： double? x = initialX; // 错误，不能在非 `late` 的初始化器中访问 `this`： // double? y = this.x; // OK，可以在 `late` 初始化器中访问 `this`： late double? z = this.x; // OK，`this.x` 和 `this.y` 是参数声明，不是表达式： Point(this.x, this.y);} 实例变量可以是 final 的，这种情况下它们必须且只能被设置一次。请在声明时、使用构造函数参数、或使用构造函数的初始化列表来初始化 final、非 late 的实例变量： 1234567class ProfileMark { final String name; final DateTime start = DateTime.now(); ProfileMark(this.name); ProfileMark.unnamed() : name = '';} 如果你需要在构造函数体开始之后才为一个 final 实例变量赋值，你可以使用以下方法之一： 使用一个工厂构造函数。 使用 late final，但要小心：一个没有初始化器的 late final 变量会向 API 中添加一个 setter。 隐式接口每个类都隐式地定义了一个接口，该接口包含了该类的所有实例成员以及它所实现的任何接口的成员。如果你想创建一个支持类 B 的 API 但不继承 B 的实现的类 A，那么类 A 应该实现 (implement) B 接口。 一个类通过在 implements 子句中声明一个或多个接口，然后提供这些接口所需的 API，来实现这些接口。例如： 12345678910111213141516171819202122232425// 一个 Person。隐式接口包含了 greet()。class Person { // 在接口中，但仅在此库中可见。 final String _name; // 不在接口中，因为这是一个构造函数。 Person(this._name); // 在接口中。 String greet(String who) =&gt; 'Hello, $who. I am $_name.';}// Person 接口的一个实现。class Impostor implements Person { String get _name =&gt; ''; String greet(String who) =&gt; 'Hi $who. Do you know who I am?';}String greetBob(Person person) =&gt; person.greet('Bob');void main() { print(greetBob(Person('Kathy'))); print(greetBob(Impostor()));} 下面是一个指定一个类实现多个接口的例子： 123class Point implements Comparable, Location { // ...} 类变量和方法使用 static 关键字来实现类级别的变量和方法。 静态变量静态变量（类变量）对于类级别的状态和常量很有用： 12345678class Queue { static const initialCapacity = 16; // ···}void main() { assert(Queue.initialCapacity == 16);} 静态变量在使用前不会被初始化。 注意本页遵循风格指南的建议，对常量名优先使用小驼峰命名法 (lowerCamelCase)。 静态方法静态方法（类方法）不操作于实例上，因此无法访问 this。然而，它们可以访问静态变量。如下例所示，你可以直接在类上调用静态方法： 1234567891011121314151617181920import 'dart:math';class Point { double x, y; Point(this.x, this.y); static double distanceBetween(Point a, Point b) { var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); }}void main() { var a = Point(2, 2); var b = Point(4, 4); var distance = Point.distanceBetween(a, b); assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9); print(distance);} 注意对于通用或广泛使用的工具和功能，考虑使用顶级函数，而不是静态方法。 你可以将静态方法用作编译时常量。例如，你可以将一个静态方法作为参数传递给一个常量构造函数。","link":"/ai/dart/2025/09/classes/index.html"},{"title":"Collections","text":"Dart 对列表、集合和映射集合提供了内置支持。要了解更多关于配置集合所包含类型的信息，请查阅泛型。 列表也许在几乎所有编程语言中最常见的集合就是数组，即对象的有序组。在 Dart 中，数组是 List 对象，所以大多数人直接称它们为列表。 Dart 列表字面量由方括号 [] 包围的、逗号分隔的元素列表表示。每个元素通常是一个表达式。这是一个简单的 Dart 列表： 1var list = [1, 2, 3]; 注意Dart 推断 list 的类型为 List&lt;int&gt;。如果你尝试向此列表添加非整数对象，分析器或运行时会引发错误。更多信息，请阅读类型推断。 你可以在 Dart 集合字面量的最后一个元素后面添加一个逗号。这个尾随逗号不影响集合，但有助于防止复制粘贴错误。 1var list = ['Car', 'Boat', 'Plane']; 列表使用从零开始的索引，其中 0 是第一个元素的索引，list.length - 1 是最后一个元素的索引。你可以使用 .length 属性获取列表的长度，并使用下标运算符 [] 访问列表的元素： 123456var list = [1, 2, 3];assert(list.length == 3);assert(list[1] == 2);list[1] = 1;assert(list[1] == 1); 要创建一个编译时常量的列表，请在列表字面量前添加 const： 12var constantList = const [1, 2, 3];// constantList[1] = 1; // 这一行将导致错误。 有关列表的更多信息，请参阅 dart:core 文档的列表部分。 集合Dart 中的集合是唯一元素的无序集合。Dart 通过集合字面量和 Set 类型来支持集合。 这是一个简单的 Dart 集合，使用集合字面量创建： 1var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'}; 注意Dart 推断 halogens 的类型为 Set&lt;String&gt;。如果你尝试向集合中添加错误类型的元素，分析器或运行时会引发错误。更多信息，请阅读类型推断。 要创建一个空集合，请在 {} 前面使用类型参数，或将 {} 赋值给 Set 类型的变量： 123var names = &lt;String&gt;{};// Set&lt;String&gt; names = {}; // 这也有效。// var names = {}; // 这会创建一个映射，而不是集合。 是集合还是映射？映射字面量的语法与集合字面量的语法相似。因为映射字面量出现得更早，所以 {} 默认表示 Map 类型。如果你忘记了在 {} 或其赋值变量上添加类型注解，那么 Dart 会创建一个 Map&lt;dynamic, dynamic&gt; 类型的对象。 使用 add() 或 addAll() 方法向现有集合添加项： 123var elements = &lt;String&gt;{};elements.add('fluorine');elements.addAll(halogens); 使用 .length 获取集合中的项数： 1234var elements = &lt;String&gt;{};elements.add('fluorine');elements.addAll(halogens);assert(elements.length == 5); 要创建一个编译时常量的集合，请在集合字面量前添加 const： 12345678final constantSet = const { 'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine',};// constantSet.add('helium'); // 这一行将导致错误。 有关集合的更多信息，请参阅 dart:core 文档的集合部分。 映射在映射中，每个元素都是一个键值对。每对中的键都与一个值相关联，键和值都可以是任何类型的对象。每个键只能出现一次，但同一个值可以与多个不同的键相关联。Dart 通过映射字面量和 Map 类型来支持映射。 这里有几个简单的 Dart 映射，使用映射字面量创建： 12345678var gifts = { // 键: 值 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings',};var nobleGases = {2: 'helium', 10: 'neon', 18: 'argon'}; 注意Dart 推断 gifts 的类型为 Map&lt;String, String&gt;，nobleGases 的类型为 Map&lt;int, String&gt;。如果你尝试向任一映射添加错误类型的值，分析器或运行时会引发错误。更多信息，请阅读类型推断。 你可以使用 Map 构造函数创建相同的对象： 123456789var gifts = Map&lt;String, String&gt;();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';var nobleGases = Map&lt;int, String&gt;();nobleGases[2] = 'helium';nobleGases[10] = 'neon';nobleGases[18] = 'argon'; 注意如果你来自像 C# 或 Java 这样的语言，你可能期望看到 new Map() 而不仅仅是 Map()。在 Dart 中，new 关键字是可选的。有关详细信息，请参阅使用构造函数。 使用下标赋值运算符 []= 向现有映射添加新的键值对： 12var gifts = {'first': 'partridge'};gifts['fourth'] = 'calling birds'; // 添加一个键值对 使用下标运算符 [] 从映射中检索值： 12var gifts = {'first': 'partridge'};assert(gifts['first'] == 'partridge'); 如果你查找的键不在映射中，你会得到 null： 12var gifts = {'first': 'partridge'};assert(gifts['fifth'] == null); 使用 .length 获取映射中键值对的数量： 123var gifts = {'first': 'partridge'};gifts['fourth'] = 'calling birds';assert(gifts.length == 2); 要创建一个编译时常量的映射，请在映射字面量前添加 const： 123final constantMap = const {2: 'helium', 10: 'neon', 18: 'argon'};// constantMap[2] = 'Helium'; // 这一行将导致错误。 有关映射的更多信息，请参阅 dart:core 文档的映射部分。 集合元素集合字面量包含一系列元素。在运行时，每个元素都会被求值，产生零个或多个值，然后插入到结果集合中。这些元素分为两大类：叶元素和控制流元素。 叶元素：将单个项插入到集合字面量中。 表达式元素：求值单个表达式，并将结果值插入集合。 映射条目元素：求值一对键和值表达式，并将结果条目插入集合。 控制流元素：有条件地或迭代地向周围的集合中添加零个或多个值。 空感知元素：求值一个表达式，如果结果不为 null，则将该值插入到周围的集合中。 展开元素：遍历给定的序列（集合表达式），并将所有结果值插入到周围的集合中。 空感知展开元素：与展开元素类似，但允许集合为 null，如果为 null 则不插入任何内容。 if 元素：根据给定的条件表达式有条件地求值内部元素，并且如果条件为假，可以选择性地求值另一个 else 元素。 for 元素：迭代并重复求值给定的内部元素，插入零个或多个结果值。 要了解更多关于集合元素的信息，请参阅以下部分。 表达式元素表达式元素求值单个表达式，并将结果值插入集合。这个表达式可以包含各种结构，如字面量、变量、运算符、函数调用和构造函数调用。 表达式元素在集合中的语法如下： 1&lt;expression&gt; 映射条目元素映射条目元素求值一对键和值表达式，并将结果条目插入集合。这对中的键和值都可以是表达式。 映射条目元素在集合中的语法如下： 1&lt;key_expression&gt;: &lt;value_expression&gt; 空感知元素空感知元素求值一个表达式，如果结果不为 null，则将该值插入到周围的集合中。 版本说明空感知集合元素需要语言版本至少为 3.8。 空感知元素在表达式元素中的语法如下： 1?&lt;expression&gt; 空感知元素在映射条目元素中的语法如下： 12// 键是空感知元素?&lt;key_expression&gt;: &lt;value_expression&gt; 12// 值是空感知元素&lt;key_expression&gt;: ?&lt;value_expression&gt; 12// 键和值都是空感知元素?&lt;key_expression&gt;: ?&lt;value_expression&gt; 在下面的例子中，空感知元素 ?a 的结果没有被添加到名为 items 的列表中，因为 a 是 null： 123456789int? absentValue = null;int? presentValue = 3;var items = [ 1, ?absentValue, ?presentValue, absentValue, 5,]; // [1, 3, null, 5] 下面的例子说明了在映射条目元素中可以使用空感知元素的各种方式： 1234567891011121314String? presentKey = 'Apple';String? absentKey = null;int? presentValue = 3;int? absentValue = null;var itemsA = {presentKey: absentValue}; // {Apple: null}var itemsB = {presentKey: ?absentValue}; // {}var itemsC = {absentKey: presentValue}; // {null: 3}var itemsD = {?absentKey: presentValue}; // {}var itemsE = {absentKey: absentValue}; // {null: null}var itemsF = {?absentKey: ?absentValue}; // {} 展开元素展开元素遍历给定的序列，并将所有结果值插入到周围的集合中。 展开元素在集合中的语法如下。序列表达式可以是任何求值为实现了 Iterable 对象的表达式： 1...&lt;sequence_expression&gt; 在下面的例子中，名为 a 的列表中的元素被添加到了名为 items 的列表中。 12var a = [1, 2, null, 4];var items = [0, ...a, 5]; // [0, 1, 2, null, 4, 5] 如果你展开的表达式可能求值为 null，并且你希望忽略 null（并且不插入任何元素），请使用空感知展开元素。 要了解更多关于展开运算符的信息，请参阅展开运算符。 空感知展开元素空感知展开元素与展开元素类似，但它允许集合为 null，如果为 null 则不插入任何内容。 空感知展开元素在集合中的语法如下： 1...?&lt;sequence_expression&gt; 在下面的例子中，名为 a 的列表被忽略了，因为它是 null，但名为 b 的列表中的元素被添加到了名为 items 的列表中。请注意，如果集合本身不为 null，但它包含 null 元素，那么这些 null 元素仍然会被添加到结果中。 123List&lt;int&gt;? a = null;var b = [1, null, 3];var items = [0, ...?a, ...?b, 4]; // [0, 1, null, 3, 4] 由于空安全，你不能对可能为 null 的值执行展开操作 (...)。下面的例子会产生编译时错误，因为 extraOptions 参数是可空的，并且用在 extraOptions 上的展开运算符不是空感知的。 1234567891011121314151617✗ static analysis: failureList&lt;String&gt; buildCommandLine( String executable, List&lt;String&gt; options, [ List&lt;String&gt;? extraOptions,]) { return [ executable, ...options, ...extraOptions, // &lt;-- 错误 ];}// 用法:// buildCommandLine('dart', ['run', 'my_script.dart'], null);// 结果:// 编译时错误 如果你想展开一个可空的集合，请使用空感知展开元素。下面的例子是有效的，因为在 extraOptions 上使用了空感知展开运算符。 12345678910111213141516List&lt;String&gt; buildCommandLine( String executable, List&lt;String&gt; options, [ List&lt;String&gt;? extraOptions,]) { return [ executable, ...options, ...?extraOptions, // &lt;-- 现在 OK 了。 ];}// 用法:// buildCommandLine('dart', ['run', 'my_script.dart'], null);// 结果:// [dart, run, my_script.dart] 要了解更多关于空感知展开运算符的信息，请参阅展开运算符。 if 元素if 元素根据给定的条件表达式有条件地求值内部元素，并且如果条件为假，可以选择性地求值另一个 else 元素。 if 元素有几种语法变体： 12// 如果布尔表达式为真，则包含结果。if (&lt;bool_expression&gt;) &lt;result&gt; 12// 如果表达式匹配模式，则包含结果。if (&lt;expression&gt; case &lt;pattern&gt;) &lt;result&gt; 12// 如果操作解析为真，则包含第一个结果，否则包含第二个结果。if (&lt;bool_expression&gt;) &lt;result&gt; else &lt;result&gt; 12// 如果操作解析为真，则包含第一个结果，否则包含第二个结果。if (&lt;expression&gt; case &lt;pattern&gt;) &lt;result&gt; else &lt;result&gt; 下面的例子说明了在集合中使用带有布尔表达式的 if 元素的各种方式： 12var includeItem = true;var items = [0, if (includeItem) 1, 2, 3]; // [0, 1, 2, 3] 12var includeItem = true;var items = [0, if (!includeItem) 1, 2, 3]; // [0, 2, 3] 12var name = 'apple';var items = [0, if (name == 'orange') 1 else 10, 2, 3]; // [0, 10, 2, 3] 1234567var name = 'apple';var items = [ 0, if (name == 'kiwi') 1 else if (name == 'pear') 10, 2, 3,]; // [0, 2, 3] 下面的例子说明了在集合中使用带有 case 部分的 if 元素的各种方式： 1234567Object data = 123;var typeInfo = [ if (data case int i) 'Data is an integer: $i', if (data case String s) 'Data is a string: $s', if (data case bool b) 'Data is a boolean: $b', if (data case double d) 'Data is a double: $d',]; // [Data is an integer: 123, Data is a double: 123] 123456var word = 'hello';var items = [ 1, if (word case String(length: var wordLength)) wordLength, 3,]; // [1, 5, 3] 123456789var orderDetails = ['Apples', 12, ''];var summary = [ 'Product: ${orderDetails[0]}', if (orderDetails case [_, int qty, _]) 'Quantity: $qty', if (orderDetails case [_, _, '']) 'Delivery: Not Started' else 'Delivery: In Progress',]; // [Product: Apples, Quantity: 12, Delivery: Not Started] 你可以将不同的 if 操作与 else if 部分混合使用。例如： 12345678910var a = 'apple';var b = 'orange';var c = 'mango';var items = [ 0, if (a == 'apple') 1 else if (a case 'mango') 10, if (b case 'pear') 2 else if (b == 'mango') 20, if (c case 'apple') 3 else if (c case 'mango') 30, 4,]; // [0, 1, 30, 4] 要了解更多关于 if 条件语句的信息，请参阅 if 语句。要了解更多关于 if-case 条件语句的信息，请参阅 if-case 语句。 for 元素for 元素迭代并重复求值给定的内部元素，插入零个或多个结果值。 for 元素在集合中的语法如下： 1for (&lt;expression&gt; in &lt;collection&gt;) &lt;result&gt; 1for (&lt;initialization_clause&gt;; &lt;condition_clause&gt;; &lt;increment_clause&gt;) &lt;result&gt; 下面的例子说明了在集合中使用 for 元素的各种方式： 12var numbers = [2, 3, 4];var items = [1, for (var n in numbers) n * n, 7]; // [1, 4, 9, 16, 7] 1var items = [1, for (var x = 5; x &gt; 2; x--) x, 7]; // [1, 5, 4, 3, 7] 1var items = [1, for (var x = 2; x &lt; 4; x++) x, 7]; // [1, 2, 3, 7] 要了解更多关于 for 循环的信息，请参阅 for 循环。 嵌套控制流元素你可以将控制流元素相互嵌套。这是其他语言中列表推导式的一个强大替代方案。 在下面的例子中，只有 numbers 中的偶数被包含在 items 中。 1234567var numbers = [1, 2, 3, 4, 5, 6, 7];var items = [ 0, for (var n in numbers) if (n.isEven) n, 8,]; // [0, 2, 4, 6, 8] 在 if 或 for 元素内部立即对集合字面量使用展开是常见且地道的用法。例如： 1234var items = [ if (condition) oneThing(), if (condition) ...[multiple(), things()],]; // [oneThing, multiple_a, multiple_b, things] 你可以任意深度地嵌套各种元素。在下面的例子中，if、for 和展开元素在集合中相互嵌套： 123456789var nestItems = true;var ys = [1, 2, 3, 4];var items = [ if (nestItems) ...[ for (var x = 0; x &lt; 3; x++) for (var y in ys) if (x &lt; y) x + y * 10, ],]; // [10, 20, 30, 40, 21, 31, 41, 32, 42]","link":"/ai/dart/2025/09/collections/index.html"},{"title":"Constructors","text":"构造函数是创建类实例的特殊函数。 Dart 实现了多种类型的构造函数。除了默认构造函数，这些函数的名称都与其所属的类名相同。 生成式构造函数 (Generative constructors)创建新实例并初始化实例变量。 默认构造函数 (Default constructors)当没有指定构造函数时，用于创建新实例。它不接受参数，也没有名称。 命名构造函数 (Named constructors)阐明构造函数的用途，或允许为同一个类创建多个构造函数。 常量构造函数 (Constant constructors)将实例创建为编译时常量。 工厂构造函数 (Factory constructors)创建子类型的新实例或从缓存中返回现有实例。 重定向构造函数 (Redirecting constructor)将调用转发给同一类中的另一个构造函数。 构造函数的类型生成式构造函数要实例化一个类，请使用生成式构造函数。 12345678class Point { // 用于存储点坐标的实例变量。 double x; double y; // 带有初始化形参的生成式构造函数： Point(this.x, this.y);} 默认构造函数如果你没有声明构造函数，Dart 会使用默认构造函数。默认构造函数是一个没有参数、没有名称的生成式构造函数。 命名构造函数使用命名构造函数可以为一个类实现多个构造函数，或为构造函数提供更清晰的语义： 1234567891011121314const double xOrigin = 0;const double yOrigin = 0;class Point { final double x; final double y; // 在构造函数体运行之前， // 设置 x 和 y 实例变量。 Point(this.x, this.y); // 命名构造函数 Point.origin() : x = xOrigin, y = yOrigin;} 子类不会继承父类的命名构造函数。要在子类中创建一个在父类中定义的同名构造函数，必须在子类中实现该构造函数。 常量构造函数如果你的类创建的对象是不可变的，可以将这些对象设为编译时常量。为此，需要定义一个 const 构造函数，并确保所有实例变量都是 final 的。 1234567class ImmutablePoint { static const ImmutablePoint origin = ImmutablePoint(0, 0); final double x, y; const ImmutablePoint(this.x, this.y);} 常量构造函数并不总是创建常量。它们也可能在非 const 上下文中被调用。要了解更多信息，请参阅关于使用构造函数的部分。 重定向构造函数一个构造函数可以重定向到同一个类中的另一个构造函数。重定向构造函数没有函数体，在冒号 (:) 之后使用 this 关键字而不是类名。 123456789class Point { double x, y; // 这个类的主构造函数。 Point(this.x, this.y); // 委托给主构造函数。 Point.alongXAxis(double x) : this(x, 0);} 工厂构造函数当实现一个构造函数时遇到以下两种情况之一，请使用 factory 关键字： 构造函数并不总是创建其类的新实例。虽然工厂构造函数不能返回 null，但它可能返回： 一个从缓存中获取的现有实例，而不是创建一个新实例。 一个子类型的新实例。 在构造实例之前需要执行一些复杂的逻辑。这可能包括检查参数或执行任何无法在初始化列表中处理的逻辑。 提示你也可以使用 late final (请谨慎使用！) 来处理 final 变量的延迟初始化。 以下示例包含两个工厂构造函数。 Logger 工厂构造函数从缓存中返回对象。 Logger.fromJson 工厂构造函数从一个 JSON 对象初始化一个 final 变量。 12345678910111213141516171819202122class Logger { final String name; bool mute = false; // _cache 是库级私有的，因为 // 它的名称前面有下划线 _。 static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{}; factory Logger(String name) { return _cache.putIfAbsent(name, () =&gt; Logger._internal(name)); } factory Logger.fromJson(Map&lt;String, Object&gt; json) { return Logger(json['name'].toString()); } Logger._internal(this.name); void log(String msg) { if (!mute) print(msg); }} 警告工厂构造函数无法访问 this。 像使用任何其他构造函数一样使用工厂构造函数： 12345var logger = Logger('UI');logger.log('Button clicked');var logMap = {'name': 'UI'};var loggerJson = Logger.fromJson(logMap); 重定向工厂构造函数重定向工厂构造函数指定了对另一个类构造函数的调用，每当有人调用该重定向构造函数时，都会使用这个指定的构造函数。 1factory Listenable.merge(List&lt;Listenable&gt; listenables) = _MergingListenable 看起来普通的工厂构造函数似乎也能创建并返回其他类的实例，这使得重定向工厂变得不必要。但重定向工厂有几个优点： 一个抽象类可以提供一个常量构造函数，该构造函数使用另一个类的常量构造函数。 重定向工厂构造函数避免了转发器（forwarders）需要重复形参及其默认值。 构造函数引用 (Tear-offs)Dart 允许你在不调用的情况下，将构造函数作为参数传递。这种方式称为“引用（Tear-off）”（就像把括号撕掉一样），它就像一个闭包，可以用相同的参数调用该构造函数。 如果这个构造函数引用的签名和返回类型与方法接受的参数相匹配，你就可以将该引用作为参数或变量使用。 引用与 lambda 或匿名函数不同。Lambda 是对构造函数的包装，而引用本身就是构造函数。 使用引用 (Tear-Offs) 推荐 12345// 使用命名构造函数的引用：var strings = charCodes.map(String.fromCharCode);// 使用未命名构造函数的引用：var buffers = charCodes.map(StringBuffer.new); 不要使用 Lambda 不推荐 12345// 不要为命名构造函数使用 lambda：var strings = charCodes.map((code) =&gt; String.fromCharCode(code));// 不要为未命名构造函数使用 lambda：var buffers = charCodes.map((code) =&gt; StringBuffer(code)); 更多讨论，请观看关于 tear-offs 的 Decoding Flutter 视频。 播放视频：Dart Tear-offs | Decoding Flutter 实例变量的初始化Dart 可以通过三种方式初始化变量。 在声明中初始化实例变量在声明实例变量时就进行初始化。 123456789101112class PointA { double x = 1.0; double y = 2.0; // 隐式的默认构造函数将这些变量设置为 (1.0, 2.0) // PointA(); @override String toString() { return 'PointA($x,$y)'; }} 使用初始化形参为了简化将构造函数参数赋值给实例变量这一常见模式，Dart 提供了初始化形参。 在构造函数声明中，包含 this.&lt;propertyName&gt; 并省略函数体。this 关键字指向当前实例。 当存在名称冲突时，使用 this。否则，Dart 风格建议省略 this。一个例外是生成式构造函数，你必须在初始化形参名称前加上 this 前缀。 正如本指南前面提到的，某些构造函数和构造函数的某些部分无法访问 this。这些包括： 工厂构造函数 初始化列表的右侧 父类构造函数的参数 初始化形参也允许你初始化非空或 final 的实例变量。这两种类型的变量都需要初始化或一个默认值。 1234567891011class PointB { final double x; final double y; // 在构造函数体运行之前， // 设置 x 和 y 实例变量。 PointB(this.x, this.y); // 初始化形参也可以是可选的。 PointB.optional([this.x = 0.0, this.y = 0.0]);} 私有字段不能用作命名的初始化形参。 123456789class PointB {// ... PointB.namedPrivate({required double x, required double y}) : _x = x, _y = y;// ...} 这也适用于命名变量。 123456789101112131415class PointC { double x; // 必须在构造函数中设置 double y; // 必须在构造函数中设置 // 带有默认值的初始化形参的生成式构造函数 PointC.named({this.x = 1.0, this.y = 1.0}); @override String toString() { return 'PointC.named($x,$y)'; }}// 使用命名变量的构造函数。final pointC = PointC.named(x: 2.0, y: 2.0); 所有通过初始化形参引入的变量都是 final 的，并且只在被初始化的变量的作用域内有效。 要执行无法在初始化列表中表达的逻辑，可以创建一个工厂构造函数或静态方法来处理该逻辑，然后将计算出的值传递给一个普通的构造函数。 构造函数参数可以设置为可空类型，并且不进行初始化。 123456789101112class PointD { double? x; // 如果构造函数中未设置，则为 null double? y; // 如果构造函数中未设置，则为 null // 带有初始化形参的生成式构造函数 PointD(this.x, this.y); @override String toString() { return 'PointD($x,$y)'; }} 使用初始化列表在构造函数体运行之前，你可以初始化实例变量。用逗号分隔多个初始化表达式。 12345// 初始化列表在构造函数体运行前// 设置实例变量。Point.fromJson(Map&lt;String, double&gt; json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)');} 警告初始化列表的右侧无法访问 this。 要在开发期间验证输入，可以在初始化列表中使用 assert。 123Point.withAssert(this.x, this.y) : assert(x &gt;= 0) { print('In Point.withAssert(): ($x, $y)');} 初始化列表有助于设置 final 字段。 以下示例在初始化列表中初始化了三个 final 字段。要执行代码，请点击“运行”。 构造函数的继承子类不会继承其父类（即直接父类）的构造函数。如果一个类没有声明构造函数，它只能使用默认构造函数。 一个类可以继承父类的参数。这些被称为 **父类参数 (super parameters)**。 构造函数的运作方式与调用一连串静态方法有些相似。每个子类都可以调用其父类的构造函数来初始化一个实例，就像子类可以调用父类的静态方法一样。这个过程不会“继承”构造函数的函数体或签名。 非默认的父类构造函数Dart 按以下顺序执行构造函数： 初始化列表 父类的未命名、无参数的构造函数 主类的无参数构造函数 如果父类没有未命名、无参数的构造函数，则必须调用父类中的一个构造函数。在构造函数体（如果有）之前，用冒号 (:) 指定父类构造函数。 在下面的例子中，Employee 类的构造函数调用了其父类 Person 的命名构造函数。要执行以下代码，请点击“运行”。 由于 Dart 在调用父类构造函数之前会先计算其参数，因此参数可以是一个表达式，比如一个函数调用。 1234class Employee extends Person { Employee() : super.fromJson(fetchDefaultData()); // ···} 警告传递给父类构造函数的参数无法访问 this。例如，参数可以调用静态方法，但不能调用实例方法。 父类参数 (Super parameters)为了避免将每个参数都传递到构造函数的 super 调用中，可以使用父类初始化形参将参数转发给指定的或默认的父类构造函数。此功能不能与重定向构造函数一起使用。父类初始化形参的语法和语义与初始化形参类似。 版本说明使用父类初始化形参需要 Dart 语言版本至少为 2.17。如果你使用的是更早的语言版本，则必须手动传入所有父类构造函数的参数。 如果父类构造函数的调用包含位置参数，则父类初始化形参不能是位置参数。 1234567891011121314class Vector2d { final double x; final double y; Vector2d(this.x, this.y);}class Vector3d extends Vector2d { final double z; // 像这样将 x 和 y 参数转发给默认的父类构造函数： // Vector3d(final double x, final double y, this.z) : super(x, y); Vector3d(super.x, super.y, this.z);} 为了进一步说明，请看以下示例。 123// 如果你用任何位置参数调用了父类构造函数 (`super(0)`)，// 再使用父类参数 (`super.x`) 将会导致错误。Vector3d.xAxisError(super.x): z = 0, super(0); // 错误 这个命名构造函数试图设置 x 值两次：一次在父类构造函数中，一次作为位置父类参数。由于两者都指向 x 这个位置参数，因此会导致错误。 当父类构造函数有命名参数时，你可以将它们分散在命名父类参数（下一个例子中的 super.y）和传递给父类构造函数调用的命名参数（super.named(x: 0)）之间。 12345678910111213class Vector2d { // ... Vector2d.named({required this.x, required this.y});}class Vector3d extends Vector2d { final double z; // 像这样将 y 参数转发给命名的父类构造函数： // Vector3d.yzPlane({required double y, required this.z}) // : super.named(x: 0, y: y); Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);}","link":"/ai/dart/2025/09/constructors/index.html"},{"title":"Generics","text":"如果您查看基础的列表类型 List 的 API 文档，您会看到其类型实际上是 List&lt;E&gt;。&lt;...&gt; 符号将 List 标记为一种泛型（或参数化）类型——即一个拥有形式类型参数的类型。按照约定，大多数类型变量都使用单字母名称，例如 E、T、S、K 和 V。 为什么要使用泛型？泛型通常是类型安全所必需的，但它们的好处不仅仅是让您的代码能够运行： 正确地指定泛型可以产生质量更高的生成代码。 您可以使用泛型来减少代码重复。 如果您希望一个列表只包含字符串，您可以将其声明为 List&lt;String&gt;（读作“字符串列表”）。这样，您、您的同事以及您的工具都能检测到将一个非字符串赋值给该列表可能是一个错误。下面是一个例子： 1234✗ static analysis: failurevar names = &lt;String&gt;[];names.addAll(['Seth', 'Kathy', 'Lars']);names.add(42); // 错误 使用泛型的另一个原因是为了减少代码重复。泛型让您可以在多种类型之间共享同一个接口和实现，同时仍然能利用静态分析的优势。例如，假设您创建了一个用于缓存对象的接口： 1234abstract class ObjectCache { Object getByKey(String key); void setByKey(String key, Object value);} 然后您发现需要一个专门针对字符串的版本，于是您创建了另一个接口： 1234abstract class StringCache { String getByKey(String key); void setByKey(String key, String value);} 后来，您又决定需要一个专门针对数字的版本……以此类推。 泛型可以省去您创建所有这些接口的麻烦。您可以只创建一个接受类型参数的接口： 1234abstract class Cache&lt;T&gt; { T getByKey(String key); void setByKey(String key, T value);} 在这段代码中，T 是一个待定类型。它是一个占位符，您可以将其理解为稍后由开发者定义的类型。 使用集合字面量List、set 和 map 的字面量可以是参数化的。参数化字面量与您已经见过的字面量一样，只是您需要在开括号前添加 &lt;type&gt;（对于 list 和 set）或 &lt;keyType, valueType&gt;（对于 map）。以下是使用类型化字面量的示例： 1234567var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];var uniqueNames = &lt;String&gt;{'Seth', 'Kathy', 'Lars'};var pages = &lt;String, String&gt;{ 'index.html': 'Homepage', 'robots.txt': 'Hints for web robots', 'humans.txt': 'We are people, not machines',}; 结合构造函数使用参数化类型在使用构造函数时，要指定一个或多个类型，请将类型放在类名后面的尖括号（&lt;...&gt;）中。例如： 1var nameSet = Set&lt;String&gt;.of(names); 以下代码创建了一个 SplayTreeMap，其键为整数，值为 View 类型： 1var views = SplayTreeMap&lt;int, View&gt;(); 泛型集合及其包含的类型Dart 的泛型是实化的（reified），这意味着它们在运行时会携带自己的类型信息。例如，您可以测试一个集合的类型： 123var names = &lt;String&gt;[];names.addAll(['Seth', 'Kathy', 'Lars']);print(names is List&lt;String&gt;); // true 注意相比之下，Java 中的泛型使用了擦除（erasure）技术，这意味着泛型类型参数在运行时会被移除。在 Java 中，您可以测试一个对象是否是 List，但您无法测试它是否是 List&lt;String&gt;。 限制参数化类型在实现泛型类型时，您可能希望限制那些可以作为参数提供的类型，使其必须是某个特定类型的子类型。这种限制被称为类型约束 (bound)。您可以使用 extends 关键字来实现这一点。 一个常见的用例是通过使其成为 Object 的子类型（而不是默认的 Object?）来确保一个类型是不可空的。 123class Foo&lt;T extends Object&gt; { // 提供给 Foo 的任何 T 类型都必须是不可空的。} 除了 Object，您也可以使用 extends 关键字与其他类型一起进行约束。下面是一个扩展 SomeBaseClass 的例子，这样 SomeBaseClass 的成员就可以在类型为 T 的对象上被调用： 12345678class Foo&lt;T extends SomeBaseClass&gt; { // 实现代码... String toString() =&gt; &quot;Instance of 'Foo&lt;$T&gt;'&quot;;}class Extender extends SomeBaseClass { ...} 使用 SomeBaseClass 或其任何子类型作为泛型参数都是可以的： 12var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();var extenderFoo = Foo&lt;Extender&gt;(); 不指定泛型参数也是可以的： 12var foo = Foo();print(foo); // Instance of 'Foo&lt;SomeBaseClass&gt;' 指定任何非 SomeBaseClass 的类型都会导致错误： 12✗ static analysis: failurevar foo = Foo&lt;Object&gt;(); 自引用类型参数约束（F-bounds）当使用类型约束来限制参数类型时，您可以将约束引用回类型参数自身。这就创建了一个自引用约束，即 F-bound。例如： 12345678910111213abstract interface class Comparable&lt;T&gt; { int compareTo(T o);}int compareAndOffset&lt;T extends Comparable&lt;T&gt;&gt;(T t1, T t2) =&gt; t1.compareTo(t2) + 1;class A implements Comparable&lt;A&gt; { @override int compareTo(A other) =&gt; /*...实现...*/ 0;}int useIt = compareAndOffset(A(), A()); F-bound T extends Comparable&lt;T&gt; 意味着 T 必须能与它自己进行比较。因此，A 只能与相同类型的其他实例进行比较。 使用泛型方法方法和函数也允许使用类型参数： 123456T first&lt;T&gt;(List&lt;T&gt; ts) { // 做一些初始工作或错误检查，然后... T tmp = ts[0]; // 做一些额外的检查或处理... return tmp;} 在这里，first 方法上的泛型类型参数（&lt;T&gt;）允许您在多个地方使用类型参数 T： 在函数的返回类型中（T）。 在参数的类型中（List&lt;T&gt;）。 在局部变量的类型中（T tmp）。","link":"/ai/dart/2025/09/generics/index.html"},{"title":"Records","text":"版本说明记录（Record）需要语言版本至少为 3.0。 记录是一种匿名的、不可变的、聚合的类型。像其他集合类型一样，它们允许你将多个对象捆绑到一个对象中。与其他集合类型不同，记录是固定大小、异构且类型化的。 记录是真实的值；你可以将它们存储在变量中、嵌套它们、作为函数的参数传递或从函数返回，以及将它们存储在诸如列表、映射和集合等数据结构中。 记录语法记录表达式是由逗号分隔的命名或位置字段列表，并用圆括号括起来： 1var record = ('first', a: 2, b: true, 'last'); 记录类型注解是由逗号分隔的类型列表，并用圆括号括起来。你可以使用记录类型注解来定义返回类型和参数类型。例如，下面 (int, int) 语句就是记录类型注解： 1234(int, int) swap((int, int) record) { var (a, b) = record; return (b, a);} 记录表达式和类型注解中的字段反映了函数中参数和实参的工作方式。位置字段直接放在圆括号内： 12345// 变量声明中的记录类型注解：(String, int) record;// 使用记录表达式初始化它：record = ('A string', 123); 在记录类型注解中，命名字段位于所有位置字段之后，放在一个由花括号分隔的类型和名称对的区域内。在记录表达式中，名称位于每个字段值之前，并后跟一个冒号： 12345// 变量声明中的记录类型注解：({int a, bool b}) record;// 使用记录表达式初始化它：record = (a: 123, b: true); 记录类型中命名字段的名称是记录类型定义（或其形状）的一部分。两个具有不同名称的命名字段的记录属于不同的类型： 12345({int a, int b}) recordAB = (a: 1, b: 2);({int x, int y}) recordXY = (x: 3, y: 4);// 编译错误！这些记录的类型不同。// recordAB = recordXY; 在记录类型注解中，你也可以为位置字段命名，但这些名称纯粹用于文档说明，不影响记录的类型： 1234(int a, int b) recordAB = (1, 2);(int x, int y) recordXY = (3, 4);recordAB = recordXY; // OK. 这与函数声明或函数类型定义（typedef）中的位置参数可以有名称，但这些名称不影响函数签名（signature）的方式类似。 更多信息和示例，请查阅记录类型和记录相等性。 记录字段记录字段可以通过内置的 getter 访问。记录是不可变的，因此字段没有 setter。 命名字段公开了同名的 getter。位置字段公开了名为 $&lt;position&gt; 的 getter，并跳过命名字段： 123456var record = ('first', a: 2, b: true, 'last');print(record.$1); // 输出 'first'print(record.a); // 输出 2print(record.b); // 输出 trueprint(record.$2); // 输出 'last' 要进一步简化记录字段的访问，请查看关于模式（Patterns）的页面。 记录类型单个记录类型没有类型声明。记录是根据其字段的类型进行结构化类型定义的。一个记录的形状（其字段集合、字段的类型以及它们的名称（如果有的话））唯一地决定了记录的类型。 记录中的每个字段都有自己的类型。同一记录内的字段类型可以不同。类型系统在任何地方访问记录字段时都知道每个字段的类型： 1234(num, Object) pair = (42, 'a');var first = pair.$1; // 静态类型是 `num`，运行时类型是 `int`。var second = pair.$2; // 静态类型是 `Object`，运行时类型是 `String`。 假设两个不相关的库创建了具有相同字段集的记录。类型系统会认为这些记录是相同的类型，即使这两个库彼此之间没有耦合。 提示虽然你不能为记录的形状声明一个唯一的类型，但你可以创建类型别名以提高可读性和复用性。要了解如何以及何时这样做，请查阅记录与类型定义（typedef）。 记录相等性如果两个记录具有相同的形状（字段集），并且它们对应的字段具有相同的值，那么这两个记录就是相等的。由于命名字段的顺序不属于记录形状的一部分，因此命名字段的顺序不影响相等性。 例如： 1234(int x, int y, int z) point = (1, 2, 3);(int r, int g, int b) color = (1, 2, 3);print(point == color); // 输出 'true'。 1234({int x, int y, int z}) point = (x: 1, y: 2, z: 3);({int r, int g, int b}) color = (r: 1, g: 2, b: 3);print(point == color); // 输出 'false'。Linter 提示：对不相关的类型进行相等比较。 记录会根据其字段的结构自动定义 hashCode 和 == 方法。 多返回值记录允许函数返回捆绑在一起的多个值。要从返回值中检索记录值，可以使用模式匹配将这些值解构到局部变量中。 123456789101112131415// 在记录中返回多个值：(String name, int age) userInfo(Map&lt;String, dynamic&gt; json) { return (json['name'] as String, json['age'] as int);}final json = &lt;String, dynamic&gt;{'name': 'Dash', 'age': 10, 'color': 'blue'};// 使用带有位置字段的记录模式进行解构：var (name, age) = userInfo(json);/* 等价于： var info = userInfo(json); var name = info.$1; var age = info.$2;*/ 你也可以使用命名字段来解构一个记录，这需要使用冒号 : 语法，你可以在模式类型页面上阅读更多相关内容： 1234({String name, int age}) userInfo(Map&lt;String, dynamic&gt; json)// ···// 使用带有命名字段的记录模式进行解构：final (:name, :age) = userInfo(json); 你也可以在不使用记录的情况下从函数返回多个值，但其他方法有其缺点。例如，创建一个类会更冗长，而使用像 List 或 Map 这样的其他集合类型会失去类型安全。 注意记录的多返回值和异构类型特性使得不同类型的 future 可以并行化，你可以在 dart:async 文档中阅读相关内容。 记录作为简单数据结构记录只持有数据。当这就是你所需要的全部功能时，它们立即可用且易于使用，无需声明任何新类。对于一个所有元素都具有相同形状的简单数据元组列表，使用记录列表是最直接的表示方法。 以这个“按钮定义”列表为例： 123456789101112final buttons = [ ( label: &quot;Button I&quot;, icon: const Icon(Icons.upload_file), onPressed: () =&gt; print(&quot;Action -&gt; Button I&quot;), ), ( label: &quot;Button II&quot;, icon: const Icon(Icons.info), onPressed: () =&gt; print(&quot;Action -&gt; Button II&quot;), )]; 这段代码可以直接编写，无需任何额外的声明。 记录与类型定义（typedef）你可以选择使用类型定义（typedef）为记录类型本身命名，然后使用该名称而不是写出完整的记录类型。这种方法允许你声明某些字段可以为 null (?)，即使列表中当前没有任何条目具有 null 值。 1234typedef ButtonItem = ({String label, Icon icon, void Function()? onPressed});final List&lt;ButtonItem&gt; buttons = [ // ...]; 因为记录类型是结构化类型，所以像 ButtonItem 这样的命名只是引入了一个别名，使其更容易引用结构化类型 ({String label, Icon icon, void Function()? onPressed})。 让所有代码都通过别名引用记录类型，可以让你在以后更容易地更改记录的实现，而无需更新每个引用。 代码可以像处理简单的类实例一样处理给定的按钮定义： 1234567891011List&lt;Container&gt; widget = [ for (var button in buttons) Container( margin: const EdgeInsets.all(4.0), child: OutlinedButton.icon( onPressed: button.onPressed, icon: button.icon, label: Text(button.label), ), ),]; 你甚至可以决定稍后将记录类型更改为类类型以添加方法： 1234567class ButtonItem { final String label; final Icon icon; final void Function()? onPressed; ButtonItem({required this.label, required this.icon, this.onPressed}); bool get hasOnpressed =&gt; onPressed != null;} 或者更改为扩展类型： 12345678extension type ButtonItem._(({String label, Icon icon, void Function()? onPressed}) _) { String get label =&gt; _.label; Icon get icon =&gt; _.icon; void Function()? get onPressed =&gt; _.onPressed; ButtonItem({required String label, required Icon icon, void Function()? onPressed}) : this._((label: label, icon: icon, onPressed: onPressed)); bool get hasOnpressed =&gt; _.onPressed != null;} 然后使用该类型的构造函数创建按钮定义列表： 123456789101112final List&lt;ButtonItem&gt; buttons = [ ButtonItem( label: &quot;Button I&quot;, icon: const Icon(Icons.upload_file), onPressed: () =&gt; print(&quot;Action -&gt; Button I&quot;), ), ButtonItem( label: &quot;Button II&quot;, icon: const Icon(Icons.info), onPressed: () =&gt; print(&quot;Action -&gt; Button II&quot;), )]; 同样，所有这些操作都无需更改使用该列表的代码。 更改任何类型都要求使用它的代码非常小心，不要做任何假设。对于使用别名作为引用的代码来说，类型别名并不能提供任何保护或保证，来确保被别名的值是一个记录。同样，扩展类型提供的保护也很少。只有类才能提供完全的抽象和封装。","link":"/ai/dart/2025/09/records/index.html"},{"title":"The Dart type system","text":"Dart 语言是类型安全的：它结合了静态类型检查和运行时检查，以确保变量的值始终与其静态类型相匹配，这有时被称为类型健全性（sound typing）。尽管类型是强制性的，但由于有类型推断，类型注解是可选的。 静态类型检查的一个好处是能够使用 Dart 的静态分析器在编译时发现错误。 您可以通过为泛型类添加类型注解来修复大多数静态分析错误。最常见的泛型类是集合类型 List&lt;T&gt; 和 Map&lt;K,V&gt;。 例如，在以下代码中，printInts() 函数打印一个整数列表，而 main() 函数创建一个列表并将其传递给 printInts()。 123456789✗ 静态分析：失败void printInts(List&lt;int&gt; a) =&gt; print(a);void main() { final list = []; list.add(1); list.add('2'); printInts(list);} 上述代码在调用 printInts(list) 时，会对 list（如上高亮所示）产生一个类型错误： 12error - The argument type 'List&lt;dynamic&gt;' can't be assigned to the parameter type 'List&lt;int&gt;'. - argument_type_not_assignable错误 - 参数类型 'List&lt;dynamic&gt;' 不能赋值给参数类型 'List&lt;int&gt;'。 - argument_type_not_assignable 这个错误指出了一个从 List&lt;dynamic&gt; 到 List&lt;int&gt; 的不健全的隐式转换。list 变量的静态类型是 List&lt;dynamic&gt;。这是因为初始化声明 var list = [] 没有为分析器提供足够的信息来推断出比 dynamic 更具体的类型参数。printInts() 函数期望一个 List&lt;int&gt; 类型的参数，从而导致了类型不匹配。 当在创建列表时添加类型注解（&lt;int&gt;）（如下高亮所示），分析器会抱怨一个字符串参数不能赋值给一个 int 参数。移除 list.add('2') 中的引号后，代码将通过静态分析，并且运行时没有任何错误或警告。 123456789✔ 静态分析：成功void printInts(List&lt;int&gt; a) =&gt; print(a);void main() { final list = &lt;int&gt;[]; list.add(1); list.add(2); printInts(list);} 在 DartPad 中尝试一下。 什么是健全性？健全性（Soundness）是为了确保您的程序不会进入某些无效状态。一个健全的类型系统意味着您永远不会进入这样一种状态：一个表达式的计算结果值与其静态类型不匹配。例如，如果一个表达式的静态类型是 String，那么在运行时，当您对它求值时，可以保证只会得到一个字符串。 Dart 的类型系统，就像 Java 和 C# 中的类型系统一样，是健全的。它通过结合静态检查（编译时错误）和运行时检查来强制实现这种健全性。例如，将 String 赋值给 int 是一个编译时错误。如果一个对象不是 String，使用 as String 将其转换为 String 会在运行时失败并抛出错误。 健全性的好处一个健全的类型系统有几个好处： 在编译时揭示与类型相关的错误。 一个健全的类型系统强制代码对其类型 unambiguous（清晰明确），因此那些在运行时可能难以发现的与类型相关的错误会在编译时被揭示出来。 代码更具可读性。 代码更容易阅读，因为您可以信赖一个值确实具有其指定的类型。在健全的 Dart 中，类型不会说谎。 代码更易于维护。 有了一个健全的类型系统，当您更改一部分代码时，类型系统可以警告您哪些其他部分的代码因此而被破坏了。 更好的预先（AOT）编译。 虽然没有类型也可以进行 AOT 编译，但生成的代码效率会低得多。 通过静态分析的技巧大多数静态类型的规则都很容易理解。以下是一些不太明显的规则： 重写方法时使用健全的返回类型。 重写方法时使用健全的参数类型。 不要将 dynamic 列表用作类型化列表。 让我们通过使用以下类型层次结构的示例来详细了解这些规则： 重写方法时使用健全的返回类型子类中方法的返回类型必须与其超类中方法的返回类型相同，或者是其子类型。考虑 Animal 类中的 getter 方法： 123456class Animal { void chase(Animal a) { ... } Animal get parent =&gt; ...} parent getter 方法返回一个 Animal。在 HoneyBadger 子类中，您可以将 getter 的返回类型替换为 HoneyBadger（或 Animal 的任何其他子类型），但不允许使用不相关的类型。 12345678910✔ 静态分析：成功class HoneyBadger extends Animal { @override void chase(Animal a) { ... } @override HoneyBadger get parent =&gt; ...} 123456789101112✗ 静态分析：失败class Root {}class HoneyBadger extends Animal { @override void chase(Animal a) { ... } @override Root get parent =&gt; ... // 错误：返回类型 'Root' 不是 'Animal' 的子类型} 重写方法时使用健全的参数类型被重写方法的参数必须具有与其超类中相应参数相同的类型或超类型。不要通过将类型替换为原始参数的子类型来“收紧”（tighten）参数类型。 注意如果您有正当理由使用子类型，您可以使用 covariant 关键字。 考虑 Animal 类的 chase(Animal) 方法： 123456class Animal { void chase(Animal a) { ... } Animal get parent =&gt; ...} chase() 方法接受一个 Animal。HoneyBadger（蜜獾）会追逐任何东西。因此可以重写 chase() 方法使其接受任何东西（Object）。 12345678910✔ 静态分析：成功class HoneyBadger extends Animal { @override void chase(Object a) { ... } @override Animal get parent =&gt; ...} 以下代码将 chase() 方法的参数从 Animal 收紧为 Mouse（Animal 的一个子类）。 1234567891011✗ 静态分析：失败class Mouse extends Animal { ...}class Cat extends Animal { @override void chase(Mouse a) { // 错误：参数类型 'Mouse' 不是 'Animal' 的超类型 ... }} 这段代码不是类型安全的，因为这样一来，就可以定义一只猫，然后派它去追一只鳄鱼： 12Animal a = Cat();a.chase(Alligator()); // 既不类型安全，也不对猫安全。 不要将 dynamic 列表用作类型化列表当您希望一个列表中包含不同类型的东西时，dynamic 列表是很好的选择。但是，您不能将 dynamic 列表用作类型化列表。 这条规则也适用于泛型类型的实例。 以下代码创建了一个 Dog 的 dynamic 列表，并将其赋值给一个类型为 Cat 的列表，这会在静态分析期间产生错误。 12345678✗ 静态分析：失败class Dog {}class Cat {}void main() { List&lt;Cat&gt; foo = &lt;dynamic&gt;[Dog()]; // 错误 List&lt;dynamic&gt; bar = &lt;dynamic&gt;[Dog(), Cat()]; // OK} 运行时检查运行时检查处理那些在编译时无法检测到的类型安全问题。 例如，以下代码在运行时会抛出异常，因为将一个 Dog 的列表转换为 Cat 的列表是错误的： 123456789✗ 运行时：失败class Animal {}class Dog extends Animal {}class Cat extends Animal {}void main() { List&lt;Animal&gt; animals = &lt;Dog&gt;[Dog()]; List&lt;Cat&gt; cats = animals as List&lt;Cat&gt;; // 抛出运行时异常} 从 dynamic 进行的隐式向下转型静态类型为 dynamic 的表达式可以被隐式转换为更具体的类型。如果实际类型不匹配，该转换会在运行时抛出错误。考虑下面的 assumeString 方法： 12345✔ 静态分析：成功int assumeString(dynamic object) { String string = object; // 在运行时检查 `object` 是否为 `String`。 return string.length;} 在这个例子中，如果 object 是一个 String，转换会成功。如果它不是 String 的子类型，比如 int，则会抛出 TypeError： 12✗ 运行时：失败final length = assumeString(1); // 抛出 TypeError 提示为了防止从 dynamic 进行隐式向下转型并避免此问题，可以考虑启用分析器的严格转型模式。 1234# analysis_options.yamlanalyzer: language: strict-casts: true 要了解更多关于自定义分析器行为的信息，请查看 自定义静态分析。 类型推断分析器可以为字段、方法、局部变量和大多数泛型类型参数推断类型。当分析器没有足够的信息来推断一个特定类型时，它会使用 dynamic 类型。 以下是类型推断如何与泛型协同工作的一个例子。在这个例子中，一个名为 arguments 的变量持有一个 Map，该 Map 将字符串键与各种类型的值配对。 如果您显式地为变量指定类型，您可能会这样写： 1Map&lt;String, Object?&gt; arguments = {'argA': 'hello', 'argB': 42}; 或者，您可以使用 var 或 final 让 Dart 推断类型： 1var arguments = {'argA': 'hello', 'argB': 42}; // 推断为 Map&lt;String, Object&gt; Map 字面量会从其条目中推断出自己的类型，然后变量再从 Map 字面量的类型中推断出自己的类型。在这个 Map 中，键都是字符串，但值的类型不同（String 和 int，它们的共同上界是 Object）。因此，Map 字面量的类型是 Map&lt;String, Object&gt;，arguments 变量的类型也是如此。 字段和方法的类型推断 一个没有指定类型并且重写了超类中字段或方法的方法或字段，会继承超类方法或字段的类型。 一个没有声明或继承类型但用初始值声明的字段，会根据初始值获得一个推断的类型。 静态字段的类型推断静态字段和变量的类型是从它们的初始化器中推断出来的。请注意，如果遇到循环（即，推断一个变量的类型依赖于知道该变量的类型），推断会失败。 局部变量的类型推断局部变量的类型是从它们的初始化器（如果有的话）中推断出来的。后续的赋值不会被考虑在内。这可能意味着推断出的类型可能过于精确。如果是这样，您可以添加类型注解。 123✗ 静态分析：失败var x = 3; // x 被推断为 int。x = 4.0; // 错误：double 类型的值不能赋给 int 类型的变量。 123✔ 静态分析：成功num y = 3; // num 可以是 double 或 int。y = 4.0; 类型参数的类型推断构造函数调用和泛型方法调用的类型参数是根据上下文的向下信息和构造函数或泛型方法参数的向上信息的组合来推断的。如果推断的结果不符合您的期望，您可以随时显式指定类型参数。 123456789✔ 静态分析：成功// 推断为 &lt;int&gt;[]List&lt;int&gt; listOfInt = [];// 推断为 &lt;double&gt;[3.0]var listOfDouble = [3.0];// 推断为 Iterable&lt;int&gt;var ints = listOfDouble.map((x) =&gt; x.toInt()); 在最后一个例子中，x 使用向下信息被推断为 double。闭包的返回类型使用向上信息被推断为 int。Dart 使用这个返回类型作为向上信息来推断 map() 方法的类型参数：&lt;int&gt;。 基于类型约束的推断版本说明基于类型约束的推断需要语言版本至少为 3.7.0。 通过基于类型约束的推断功能，Dart 的类型推断算法通过将现有约束与声明的类型边界相结合来生成约束，而不仅仅是尽力而为的近似值。 这对于 F-bounded 类型尤其重要，在这种情况下，基于类型约束的推断可以正确推断出，在下面的例子中，X 可以被约束为 B。如果没有这个功能，类型参数必须显式指定：f&lt;B&gt;(C())： 1234567891011121314151617class A&lt;X extends A&lt;X&gt;&gt; {}class B extends A&lt;B&gt; {}class C extends B {}void f&lt;X extends A&lt;X&gt;&gt;(X x) {}void main() { f(B()); // OK. // OK. 如果不使用类型约束，依赖于尽力而为近似值的推断 // 会在检测到 `C` 不是 `A&lt;C&gt;` 的子类型后失败。 f(C()); f&lt;B&gt;(C()); // OK.} 这里有一个更现实的例子，使用了 Dart 中的日常类型，如 int 或 num： 123456X max&lt;X extends Comparable&lt;X&gt;&gt;(X x1, X x2) =&gt; x1.compareTo(x2) &gt; 0 ? x1 : x2;void main() { // 有了该功能，推断为 `max&lt;num&gt;(3, 7)`，没有则会失败。 max(3, 7);} 通过基于类型约束的推断，Dart 可以解构类型参数，从泛型类型参数的边界中提取类型信息。这使得像下面例子中的 f 这样的函数能够同时保留具体的可迭代类型（List 或 Set）和元素类型。在基于类型约束的推断出现之前，这在不丢失类型安全或特定类型信息的情况下是不可能实现的。 123456789(X, Y) f&lt;X extends Iterable&lt;Y&gt;, Y&gt;(X x) =&gt; (x, x.first);void main() { var (myList, myInt) = f([1]); myInt.whatever; // 编译时错误，`myInt` 的类型是 `int`。 var (mySet, myString) = f({'Hello!'}); mySet.union({}); // 可行，`mySet` 的类型是 `Set&lt;String&gt;`。} 如果没有基于类型约束的推断，myInt 的类型将是 dynamic。之前的推断算法不会在编译时捕获到不正确的表达式 myInt.whatever，而是在运行时抛出错误。相反，如果没有基于类型约束的推断，mySet.union({}) 将是一个编译时错误，因为之前的算法无法保留 mySet 是一个 Set 的信息。 要了解更多关于基于类型约束的推断算法的信息，请阅读设计文档。 类型替换当您重写一个方法时，您正在用可能具有新类型的东西（在新方法中）替换具有某种类型的东西（在旧方法中）。同样，当您将一个参数传递给一个函数时，您正在用具有另一种类型的东西（实际参数）替换具有一种类型的东西（声明了类型的形参）。那么，什么时候可以用一个子类型或超类型来替换具有某种类型的东西呢？ 在替换类型时，从消费者（consumers）和生产者（producers）的角度思考会有所帮助。消费者吸收一种类型，而生产者生成一种类型。 你可以用一个超类型替换消费者的类型，用一个子类型替换生产者的类型。 让我们看看简单类型赋值和泛型类型赋值的例子。 简单类型赋值当将对象赋值给对象时，什么时候可以用一个不同的类型替换另一个类型？答案取决于对象是消费者还是生产者。 考虑以下类型层次结构： 考虑以下简单的赋值，其中 Cat c 是一个消费者，而 Cat() 是一个生产者： 1Cat c = Cat(); 在一个消费位置，用一个能消费任何东西（Animal）的东西来替换一个消费特定类型（Cat）的东西是安全的，所以用 Animal c 替换 Cat c 是允许的，因为 Animal 是 Cat 的超类型。 12✔ 静态分析：成功Animal c = Cat(); 但是用 MaineCoon c 替换 Cat c 会破坏类型安全，因为超类可能会提供一个具有不同行为的 Cat 类型，比如 Lion： 12✗ 静态分析：失败MaineCoon c = Cat(); // 错误 在一个生产位置，用一个更具体的类型（MaineCoon）替换一个生产某种类型（Cat）的东西是安全的。所以，以下是允许的： 12✔ 静态分析：成功Cat c = MaineCoon(); 泛型类型赋值对于泛型类型，规则是否相同？是的。考虑动物列表的层次结构——Cat 的列表是 Animal 列表的子类型，是 MaineCoon 列表的超类型： 在下面的例子中，您可以将一个 MaineCoon 列表赋值给 myCats，因为 List&lt;MaineCoon&gt; 是 List&lt;Cat&gt; 的子类型： 123✔ 静态分析：成功List&lt;MaineCoon&gt; myMaineCoons = ...List&lt;Cat&gt; myCats = myMaineCoons; 那么反过来呢？您可以将一个 Animal 列表赋值给一个 List&lt;Cat&gt; 吗？ 123✗ 静态分析：失败List&lt;Animal&gt; myAnimals = ...List&lt;Cat&gt; myCats = myAnimals; // 错误 这个赋值无法通过静态分析，因为它创建了一个隐式向下转型，而从非 dynamic 类型（如 Animal）进行隐式向下转型是不允许的。 要使这类代码通过静态分析，您可以使用显式转型。 12List&lt;Animal&gt; myAnimals = ...List&lt;Cat&gt; myCats = myAnimals as List&lt;Cat&gt;; 不过，显式转型仍然可能在运行时失败，这取决于被转型的列表（myAnimals）的实际类型。 方法在重写方法时，生产者和消费者的规则仍然适用。例如： 对于消费者（如 chase(Animal) 方法），您可以用一个超类型替换参数类型。对于生产者（如 parent getter 方法），您可以用一个子类型替换返回类型。 更多信息，请参阅 重写方法时使用健全的返回类型 和 重写方法时使用健全的参数类型。 协变参数一些（很少使用的）编码模式依赖于通过用子类型重写参数类型来收紧类型，这是无效的。在这种情况下，您可以使用 covariant 关键字告诉分析器您是有意为之。这会移除静态错误，而是在运行时检查无效的参数类型。 以下展示了如何使用 covariant： 1234567891011121314151617✔ 静态分析：成功class Animal { void chase(Animal x) { ... }}class Mouse extends Animal { ...}class Cat extends Animal { @override void chase(covariant Mouse x) { ... }} 虽然这个例子展示了在子类中使用 covariant，但 covariant 关键字可以放在超类或子类的方法中。通常，超类方法是放置它的最佳位置。covariant 关键字应用于单个参数，并且也支持在 setter 和字段上使用。 其他资源以下资源提供了关于健全 Dart 的更多信息： Fixing type promotion failures - 理解并学习如何修复类型提升失败。 Sound null safety - 学习如何编写具有健全空安全的代码。 Customizing static analysis - 如何使用分析选项文件来设置和自定义分析器和 linter。","link":"/ai/dart/2025/09/type-system/index.html"},{"title":"Typedefs","text":"类型别名——由于使用 typedef 关键字声明，它常被称为 typedef——是引用类型的一种简洁方式。下面是一个声明和使用名为 IntList 的类型别名的示例： 12typedef IntList = List&lt;int&gt;;IntList il = [1, 2, 3]; 类型别名也可以拥有类型参数： 123typedef ListMapper&lt;X&gt; = Map&lt;X, List&lt;X&gt;&gt;;Map&lt;String, List&lt;String&gt;&gt; m1 = {}; // 冗长。ListMapper&lt;String&gt; m2 = {}; // 含义相同，但更短、更清晰。 版本说明在 2.13 版本之前，typedef 仅限于函数类型。使用新的 typedef 功能要求语言版本至少为 2.13。 在大多数情况下，我们建议对函数使用内联函数类型，而不是函数 typedef。然而，函数 typedef 仍然可能有用： 1234567typedef Compare&lt;T&gt; = int Function(T a, T b);int sort(int a, int b) =&gt; a - b;void main() { assert(sort is Compare&lt;int&gt;); // True!}","link":"/ai/dart/2025/09/typedefs/index.html"},{"title":"自组折叠自行车","text":"前言前几个月对折叠自行车比较感兴趣,通过视频,网络好友,配件卖家等渠道了解到了一些自组折叠自行车的相关知识 写一篇博客记录分享一下 这部分知识和组装折叠自行车强相关 知识比较偏向于理论,并没有实践来验证 强烈建议想要了解自组折叠车的朋友转到附表-配件简图先认识一下各个配件的样子 什么是折叠自行车折叠自行车肯定是要能折叠的,不过也因为折叠属性,我目前没见过大轮径的折叠车 折叠也分多种,两折叠比较常见,一般在大梁的位置可以折叠一次;也有三折叠,在一些小众名牌中 只要能折叠,是自行车.我认为它被称作折叠自行车就是没有毛病的 下面我着重介绍的折叠自行车是指带变速的类型 以下两张图并非我的组装成果,来自山东某位网友 术语碳纤维碳纤维是一种新工艺,其主要的成份是碳材料.制作好的成品一般具有不错的滤震能力,且重量相比于铝制来说也要轻不少,刚性也不错 碳纤维在自行车领域在我看来是一种高级材料,你可以将车身的许多配件都找到它的制品.比如碳车架,碳前叉,碳车把,碳坐管,碳轮组,甚至碳坐垫,碳脚踏和碳盘片 碳纤维的特点是轻和滤震,也具有不错的强度,但它比较脆,不像金属一样具有一定的延展性,受到强力的挤压会导致碳制零件断裂报废 另外一点就是,碳纤维技术虽然在90年代就被发明了,但在工业化的现在,其成本依然高于钢制铝制材料 钛合金钛制品在很多领域都具有一种特殊的光环.比如钛制水杯 基于钛金属本身的一些特性(耐腐蚀,重量相对钢制品较轻,强度高),在一小部分人群中,会追求钛车架 但钛本身滤震性并不如碳,基于它的成本和碳都不是普通人愿意接受的价格,不推荐普通人接触这个东西 刚性 指的是自行车车架和各个部件在受力时抵抗形变（弯曲、扭曲）的能力 以上发言来自 ai Gemini 2.5 pro 什么是刚性呢?我简单理解为稳定性 折叠车由于需要折叠,整个车架并不是一体的,比起传统的一体式车架,更需要考虑在暴力骑行中是否会出现车身晃动甚至散架的问题 折叠车的刚性和车架的结构和材质关系比较大 比如,大行 P8为了增加稳定性,在中轴和碗组的位置安装了一根叫马甲线的线材 比如,蚂蚁腿车架使用了铬钼钢作为车架材料 整车品牌 虽然主要介绍的是组装,但了解一下整车也是很有必要的 有一些不那么爱折腾的朋友,有一种途径是买整车然后再替换部分配件 换下来的旧配件可以放闲鱼上卖.事实上也不少人是这么做的 大行(DAHON)这是个美国的品牌,在国内的折叠车领域也算得上是一把手了,比较有名的型号是大行 P8 只看线上电商平台的渲染图,我更喜欢大行的另一个车型大行 K3 Plus 我在线下试骑过这个,但车店只有一辆二手的车型,车子骑起来特别软,刚性很差,导致我放弃了这个车型 燕鸥(Tern)这是牌子是从大行出来的员工新创立的牌子 配件按重要性来排序,各个大件我会这样排序 车架 变速套件 内外胎 坐管 头管 刹车 轮组 车把 坐垫 其它 车架 折叠车的车架一般都是带前叉的 自行车圈子有一句调侃的话是 穷玩车架,富玩轮 车架作为联通自行车各个部件的中间人,地位就像是电脑中的主板一样.有些人狠狠加料,有些人觉得够用就行 前面有说到,有部分朋友是买的整车然后改装,然后闲鱼出售旧的配件 既然有出售配件的,当然也有平台车车架的.你也可以选择在闲鱼蹲一辆大行的拆车车架 不过,二手产品的稳定性不那么好保证,如果有洁癖还是选择新购入吧 车架方面,国内比较知名一些的车架平台有风行,科瑞斯(Crius),犀牛(EIOSIX) 这里面,名声最大的是风行,这个品牌早期是给整车品牌大行做车架代工的.所以也有人会说风行的车架是盗版的 车架也有几种不同的大类,我比较熟悉的有 K架 Y架 海豚架 蚂蚁架(蚂蚁腿) 以上都是风行的几款车架,你更喜欢哪一款呢 K架作为大行P8经典车型的同款车架,算是老大哥了 Y架多一条横梁,是这四款车架中刚性最好的 什么是刚性呢?我简单理解为稳定性 折叠车由于折叠的特性,稳定性不如一体式车架 对于大体重的人来说,骑折叠车或许不是一个好选择 海豚架是最有特点的一个车架,整个车身像是一个已经跃出海面的海豚 蚂蚁腿是我个人认为最漂亮的一款车架,电商平台把它归类到了复古风格的车架 材质再说说车架的材质 风行的上述四个车架,除了蚂蚁腿是铬钼钢,其它的三款都是铝合金材质 在自行车领域,材质比较多为铝合金材质,这个材质在工业化的现在易加工成本比较低,有较好的稳定性 如果资金富裕,可以尝试进军碳纤维领域.富玩轮的轮说的就是碳纤维的轮组 碳纤维有很好的避震性能,它本身也具有不错的刚性,更重要的是,相比于铝,碳纤维可以大大降低整车的重量 还有钢架.一般而言,钢材是比较重的,折叠车为了加强车架的刚性,有些车型会选择铬钼钢作为车架材质,比如风行的蚂蚁腿车架 最后还有一种很小众的车架,钛金属车架.这个材质的车架成本和高级碳纤维应该是大差不差的.都是有钱人的玩具.据车友自述,钛架的避震性能很差,而且重,普通玩家不建议入手 尺码 先下一个结论,折叠车并没有尺码这个说法,至少我没没见到同一款车型可以选择不同尺码的折叠车 尺码在公路车,山地车,瓜车中出现的比较多 下图是瓜车 骁风真挚 的车架尺码 但折叠车也不是完全没有尺码,只不过折叠车的尺码不同于公路车的尺码 比如风行蚂蚁腿这个车架,有 FGD2018 和 FGD1618 两种 FGD2018 安装 20 英寸和 21 英寸的轮组,一般安装 20 英寸 FGD1618 安装 16 英寸和 17 英寸的轮组,一般安装 16 英寸 这个尺码会直接影响你的其它配件 变速套件 分类套件分为大中小大类 它们包含的配件不一样,但具体包含了哪些配件没有统一的规定,甚至每个店家对于小中大套件的定义也是不一样的 购买的时候需要注意套件中包含的配件 下面给出一个示例,不一定标准 套件 配件 小套件 前拨 + 后拨 + 变速器 + 链条 + 飞轮 中套件 小套件 + 曲柄 + 牙盘 + 中轴 大套件 中套件 + 刹车碟片 + 刹把 自行车套件逃不过的一个品牌是禧玛诺(SHIMANO),国内还有顺泰,蓝图等厂商 不过,据广大网友评价的结论,禧玛诺依旧还是第一梯队 接下来只简单说说禧玛诺 在公路车领域,禧玛诺有 CLARIS SORA TIAGRA 105 ULTEGRA DURA-ACE 这六个等级,品质级别从低到高,普通骑友的套件天花板是105.理由是105摸到了ULTEGRA的绝大多数体验,但性价比比ULTEGRA高很多,被称为专业入门的套件 作为折叠车,我觉得上TIAGRA就行了 如果你去自行车店购买自行车,店家宣称自己的车是禧玛诺的变速套件.希望你能询问老板自行车的哪些配件是禧玛诺,以及使用的是那个级别的禧玛诺套件 为了有一个直观的感觉,我贴一个大概的价格 价格表来源为淘宝,时间为 2025.09.14 禧玛诺套件 价格 / ¥ TIAGRA 4700 小套件(中腿后拨 + 变速器 + 链条 + 飞轮) 410 TIAGRA 4700 中套件(中腿后拨 + 变速器 + 链条 + 飞轮 + 曲柄 + 牙盘(1 x 10速) + 中轴) 880 105 R7120 小套件(前拨 + 后拨 + 手变 + 夹器) 1,720 105 R7120 中套件(前拨 + 后拨 + 手变 + 夹器 + 链条 + 飞轮 + 曲柄 + 牙盘(2 x 12速)) 2,350 内外胎其实主要讲的是外胎,内胎可讲的不多 内胎我知道的内胎材质有两种 传统的几丁质材料 和 TPU塑料材质 它们两的主要区别是 对比参数 几丁质 TPU 重量 重 很轻 气密性 好 很差 稳定性 好 很差 外胎先说说品牌 世文(SCHWALBE): 在防刺方面做的比较出色. 大行P8 用到的大苹果胎(Big Apple)就出自这个平台 德国马牌: 相对比较综合一些,防刺和竞速方面都不错 对于公路车而言,为了竞速,公路车的外胎通常会做的比较细,且胎面较薄,轮胎的胎压也会比较高,这么做是为了降低轮胎的滚阻,让自行车的气动性更佳 对于山地车而言,情况就不一样了,它们的轮胎一般又大又宽,胎面有很明显的花纹用来增加与地面的摩擦力,这么做是为了适应不同的路面环境 公路车为了速度,轮胎会做的细窄且胎压较高,但代价是公路车的轮胎更适合在路况良好的路面,对于路况差的路面来说,公路车的轮胎往往更容易出现爆胎,避震性差的问题 山地车为了适应性,轮胎做的又大又宽,代价是轮胎更重,滚阻更高 对于折叠车如何选择,我想这因人而异 但就像是在公路车和山地车之间,还有一种瓜车一样,多数折叠车的轮胎选择既不会像公路车那样激进,也不会像是山地车那样被要求适应复杂路况.所以我的选择是世文的马拉松plus系列 坐管 坐管是 ai 强烈推荐我换成碳纤维的配件之一,理由是它能低成本避震 不过说是低成本,其实也是相对于碳前叉和碳车架来说 不过说到碳坐管,除了它避震和重量轻的优点,也有个缺点,碳纤维坐管更容易出现滑落的问题.所以你可能要加配双层坐管夹以及增加摩擦性的止滑剂 个人推荐折叠车使用铝坐管即可 头管 折叠车的头管也是可以折叠的 折叠方式按照折叠方式可以分为两种内折和外折 据说外折头管会更不容易磕碰到车架 拆卸方式按照拆卸方式,可以分为快拆,T型和双钉 快拆: 上图左一,左二,右三,右一都是快拆,意思是顶部有一个折叠扣可以徒手取下车把 T型: 这个了解的不多 双钉: 需要借助内六角扳手才能取下来车把,与它的安装和拆卸麻烦相比,稳定性要比快拆头管好不少 形状主要有两种形状,一种是上图这样弯弯的,叫鹅颈头管 还有一种更常见的直立头管 高度折叠自行车的坐管是很长的,可以自由调节,但头管的高度是不可变的,建议有条件可以先去一些自行车线下店(比如大行,迪卡侬等等)实际体验一下它们的整车并观察其头管的长度,寻找合适自己的高度 与头管一样,车把的长度我也是推荐在线下实际体验之后再确定 刹车圈刹 共享单车的刹车使用的就是这个 相对于碟刹来说,无论是购买成本还是维护成本都更低,缺点是刹车的制动性能一般都是不如碟刹的 碟刹圈刹的刹车位置在轮组的轮圈上,碟刹的刹车位置在轮组轴承的碟片上 碟刹也分多种 线拉碟刹车的制动力通过拉动钢线来传导,有小部分人认为线拉碟调教得好甚至不逊于油碟 油碟刹车的制动力通过压迫线管中的油来传导 除了安装难度高,维护成本高,算是自行车领域刹车的王者 油碟刹车会比圈刹制动更短,意味着捏刹车不能一下捏死,不然在快速行驶时容易轮胎抱死摔车 推荐折叠车上推荐使用禧玛诺的 MT200油压碟刹 + 禧玛诺RT56油刹碟片 至于为什么,问就是大家都这么选,性价比和功用性在折叠车上都拉满了,甚至性能过剩 网上有传言说,折叠车上油刹维护成本高,因为折叠更容易导致油管漏油 关于这个问题,我咨询过一个五年骑友,他自组的折叠车都是油压碟刹,我想问题应该没那么大 轮组轮组我了解的不多 需要注意的是,根据车架的尺寸(20英寸,16英寸比较常见)以及刹车系统(圈刹或者碟刹)的不同,选择的轮组也是不同的 有一个有意思的轮组叫星芒轮组(下图左) 说是辐条的形状像是一个五芒星一样,辐条的减少可见降低风阻,但也一定程度上降低轮组的可靠性 另一个问题是星芒轮组会更贵一些 车把 和坐管一样, ai 认为这是低成本换碳车把,可以在避震和重量上带来很大收益的配件 我的建议是有钱可以上碳纤车把,预算吃紧还是用铝的吧 坐垫 很多坐垫都做了中空处理,女士我不清楚.对于男士而言,骑行的姿势使得前列腺一直处于压迫状态 有过长时间骑车经验的男士小伙伴,应该都会感觉到下体发麻甚至短时间内没有知觉 骑行圈处理这个问题主要是四大措施 坐垫.像是图中的坐垫一样中间留空,减少压迫 骑行裤.貌似是在裆部加了一层垫子 铁锭.多骑多练,让身体慢慢适应 换避震性能好的配件.比如碳车架,碳前叉甚至避震前叉等 其它脚踏脚踏按材质分类,有普通塑料的,尼龙塑料的,金属的 我个人比较推荐尼龙塑料,金属虽然质感好,但折叠之后容易剐蹭到车身导致掉漆 还有一种是快拆类型的脚踏,也就是说脚踏可以徒手拆卸下来 不过这种脚踏会更重一些 B柱前转换座 如果安装的是圈刹,就不需要这个小配件 折叠车的车架前叉如果安装碟刹需要一个金属垫来垫高碟刹夹器 注意后轮一般不需要 刹车线管套保护套(非必须) 用来束缚刹车线和变速线管的保护套,起到一个美观和保护的作用,可不用 安装工具内六角扳手(必备) 内六角属于是必备的工具,无论是安装还是维护,是比较常用的工具 对于常用的工具,推荐买一套材质比较好的,避免滑丝或者断裂 苹果酱润滑脂(必备) 业内人士称它为苹果酱大概率是因为颜色吧 功效就如同图里说的,几乎所有金属零件的连接出处都可以来上一点,可以达到防水,润滑的作用 如果配件中还有碳纤维制品,还需要额外购买止滑剂增加摩擦力 打气筒(必备)无须解释,有压力表显示的更佳 链条截链器(必备) 购买的链条一般都是偏长的,需要链条截链器截断几节链条之后通过魔术扣连接 魔术扣钳子(非必备) 链条使用魔术扣连接之后,需要通过这个工具来夹紧 或者你也可以省略这个工具,通过大力踩踏脚踏让链条自然拉紧 卡飞套筒(必备) 安装飞轮的工具,需要配合扳手一起使用 活动扳手(必备) 这家伙应该不会有人不认识吧 卡飞扳手(非必备) 这个工具需要配合卡飞套筒一起使用 作用是用来固定飞轮.看到上面的链条了吗,使用链条卡住飞轮的齿轮以固定飞轮不转动 这个工具在拆卸飞轮时才需要,安装飞轮的时候必须 中轴扳手(必备) 中轴扳手顾名思义是用来安装中轴的 禧玛诺和浩盟的许多中轴都只需要这个工具就可以完成安装 小部分中轴还需要用到中轴套筒,关于这一点可以向中轴的店家咨询是否需要中轴套筒 碗组压入工具(非必备) 购买车架的时候可以询问店家是否可以帮忙压入碗组(当然,你也需要在同一家店铺购买碗组),同意帮忙的话可以省下这个工具 也有人大力出奇迹暴力压入碗组,只能说风险有点大,可能导致车架或者碗组报废 电工胶带(非必备) 电工胶带的作用有很多 在安装刹车把和变速车把的时候,可以现在车把上缠一两圈胶带再固定安装刹车把和变速车把会更佳 个人组装配置单 配置单具有时效性,可能当你看到时已经过时,或者已经有更合适的配置 同时也具有强主观性,选择某一个配件只因我的喜好 折叠自行车配置单 参考价格均来自 淘宝,时间为 2025.09.14 配件名称 规格 备注 参考价格 / ¥ 车架 风行FGD2018碟刹 蚂蚁架 黑金 1247 变速套件 TIAGRA 4700小套件 395 - 飞轮 - 指拨 - 后拨 28T飞轮短腿 - 链条 内外胎 数量 * 2 213.4 * 2 - 世文马拉松PLUS 20*1.35 - AV6美嘴内胎 坐管 MaxtroN美壮 Tower5 黑色 86.2 头管 黑色-双钉外折(31.5cm) 鹅颈头管 172.66 刹车 - 碟片 禧玛诺 RT56 160mm * 2 80 - 油刹 禧玛诺MT200油压碟刹 油管长100-170cm 购买前请咨询店家油管长度,避免不必要的截管 185 轮组 EIOSIX犀牛 中刀碟刹 406 全黑色 * 2 406 代表轮组的轮径,表示20英寸; 451 表示 21 英寸 466.98 车把 MaxtroN美壮Needle5 黑色 25.4*500mm短直把 车把长度建议线下体验之后解决 74.8 坐垫 SELLE ROYAL 自行车座垫 treking旅行款 77.4 脚踏 尼龙脚踏 三培林脚踏 橘色 62.74 中轴 + 曲柄 + 盘片 + 盘钉 prowheel浩盟 有没有盘钉需要执行咨询店家,没有需要额外购买 189.38 - 中轴 中空 - 曲柄 170曲柄 - 盘片 52T盘片 - 盘钉 碗组 MaxtroN美壮 红色 也可以换成景晔的碗组.买前咨询店家是否可以帮忙压入碗组再发货 68.6 把套 美国ODI橡胶肉球 红色 18.25 碟刹转换座 禧玛诺 160MM-B柱前转换座 10 脚撑 20寸黑色 非必须 48 折叠自行车磁铁 非必须,折叠之后避免车架散开 11.13 刹车线管套保护套 12mm红色 2米 非必须,固定,美观刹车和变速线管 24.1 合计 3644.04 折叠自行车组装工具配置单 参考价格均来自 淘宝,时间为 2025.09.14 配件名称 规格 备注 参考价格 / ¥ 内六角扳手 S2钢材 35 苹果酱润滑脂 50克 17.91 打气筒 气压表 + 多功能气针 脚踩式 30.9 中轴扳手 TL-BB01扳手 注意与中轴的适配,请在购买前咨询店家是否适配你所购买的中轴 25 魔术扣钳子 8.8 链条截链器 + 卡飞套筒 + 卡飞扳手 只是安装可以不需要卡飞扳手,卡飞扳手只在拆卸时有用 32 碗组压入工具 简约款 非必须.购买车架时,请咨询店家是否可以帮忙压入碗组.可省略此工具 28 活动扳手 10寸开口35mm 13.6 电工胶带 黑色1卷30米 非必须 3.9 总计 195.11 附表配件简图 配件 简图 车架 前叉 车把 把套 头管 碗组 坐管 坐垫 脚撑 脚踏 曲柄 链条 飞轮 后拨 指拨 油刹 刹车片 外胎 内胎 轮组 碟刹转换座 折叠自行车磁铁","link":"/bike/2025/09/14/bike/index.html"},{"title":"postgres using explain","text":"14.1. 使用 EXPLAIN PostgreSQL 会为其接收的每个查询设计一个查询计划。选择正确的计划以匹配查询结构和数据属性对于获得良好性能至关重要，因此系统包含一个复杂的规划器，该规划器尝试选择好的计划。您可以使用 EXPLAIN 命令查看规划器为任何查询创建的查询计划。计划解读是一门艺术，需要一定的经验才能掌握，但本节旨在涵盖其基础知识。 本节中的示例取自执行 VACUUM ANALYZE 后的回归测试数据库，并使用了 v17 开发版本。如果您自己尝试这些示例，应该能获得类似的结果，但您的估计成本和行数可能会略有不同，因为 ANALYZE 的统计数据是随机抽样而非精确的，并且成本本身在某种程度上依赖于平台。 这些示例使用 EXPLAIN 默认的“文本”输出格式，该格式紧凑且方便人类阅读。如果您想将 EXPLAIN 的输出提供给程序进行进一步分析，则应改用其机器可读的输出格式之一（XML、JSON 或 YAML）。 14.1.1. EXPLAIN 基础知识 查询计划的结构是计划节点的树形结构。树的最底层节点是扫描节点：它们从表中返回原始行。针对不同的表访问方法，有不同类型的扫描节点：顺序扫描、索引扫描和位图索引扫描。此外，还有非表行源，例如 VALUES 子句和 FROM 子句中的集合返回函数，它们拥有自己的扫描节点类型。如果查询需要对原始行进行连接、聚合、排序或其他操作，那么扫描节点上方将有额外的节点来执行这些操作。同样，执行这些操作通常有不止一种可能的方法，因此这里也可以出现不同类型的节点。EXPLAIN 的输出为计划树中的每个节点提供一行，显示基本的节点类型以及规划器对该计划节点执行的成本估计。可能会出现额外的行，从节点的摘要行缩进，以显示节点的附加属性。第一行（最顶层节点的摘要行）是计划的估计总执行成本；规划器致力于将这个数字最小化。 这是一个简单的例子，只为展示输出的样式： 12345EXPLAIN SELECT * FROM tenk1; QUERY PLAN------------------------------------------------------------- Seq Scan on tenk1 (cost=0.00..445.00 rows=10000 width=244) 由于此查询没有 WHERE 子句，它必须扫描表的所有行，因此规划器选择了使用简单的顺序扫描计划。括号中引用的数字（从左到右）是： 估计启动成本（Estimated start-up cost）。这是输出阶段开始前所花费的时间，例如，在排序节点中执行排序所需的时间。 估计总成本（Estimated total cost）。这是基于计划节点运行完成的假设得出的，即所有可用行都已检索。实际上，节点的父节点可能在读取所有可用行之前停止（请参阅下面的 LIMIT 示例）。 此计划节点输出的估计行数（Estimated number of rows output by this plan node）。同样，假定该节点已运行完成。 此计划节点输出的行的估计平均宽度（以字节为单位）（Estimated average width of rows output by this plan node (in bytes)）。 成本以规划器的成本参数（参见 Section 19.7.2）确定的任意单位衡量。传统做法是以磁盘页面获取为单位衡量成本；也就是说，seq_page_cost 通常设置为 1.0，其他成本参数相对于它进行设置。本节中的示例使用默认的成本参数运行。 理解上层节点的成本包含其所有子节点的成本是很重要的。同样重要的是要认识到，成本只反映规划器关心的事情。特别是，成本不考虑将输出值转换为文本形式或将其传输到客户端所花费的时间，这在实际经过的时间中可能是重要因素；但规划器忽略这些成本，因为它无法通过更改计划来改变它们。（我们相信，每个正确的计划都将输出相同的行集。） rows 值有点棘手，因为它不是计划节点处理或扫描的行数，而是节点发出的行数。由于在节点处应用了任何 WHERE 子句条件进行过滤，这通常少于扫描的行数。理想情况下，顶层 rows 估计将近似于查询实际返回、更新或删除的行数。 回到我们的例子： 12345EXPLAIN SELECT * FROM tenk1; QUERY PLAN------------------------------------------------------------- Seq Scan on tenk1 (cost=0.00..445.00 rows=10000 width=244) 这些数字的推导非常直接。如果您执行： 1SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1'; 您会发现 tenk1 有 345 个磁盘页面和 10000 行。估计成本计算为 (读取的磁盘页面 * seq_page_cost) + (扫描的行数 * cpu_tuple_cost)。默认情况下，seq_page_cost 是 1.0，cpu_tuple_cost 是 0.01，所以估计成本是 (345 * 1.0) + (10000 * 0.01) = 445。 现在让我们修改查询以添加一个 WHERE 条件： 123456EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000; QUERY PLAN------------------------------------------------------------ Seq Scan on tenk1 (cost=0.00..470.00 rows=7000 width=244) Filter: (unique1 &lt; 7000) 请注意，EXPLAIN 输出显示 WHERE 子句作为附加到 Seq Scan 计划节点的“过滤器”条件。这意味着计划节点检查它扫描的每一行的条件，并只输出通过条件的行。由于 WHERE 子句，输出行数的估计已减少。但是，扫描仍然需要访问所有 10000 行，因此成本没有降低；事实上，它略有上升（准确地说是增加了 10000 * cpu_operator_cost）以反映检查 WHERE 条件所花费的额外 CPU 时间。 这个查询实际选择的行数是 7000，但行数估计只是近似值。如果您尝试重复此实验，您很可能会得到一个略有不同的估计；此外，它可以在每个 ANALYZE 命令之后改变，因为 ANALYZE 生成的统计数据是从表的随机样本中获取的。 现在，让我们使条件更具限制性： 12345678EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100; QUERY PLAN------------------------------------------------------------------------------ Bitmap Heap Scan on tenk1 (cost=5.06..224.98 rows=100 width=244) Recheck Cond: (unique1 &lt; 100) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) Index Cond: (unique1 &lt; 100) 这里规划器决定使用两步计划：子计划节点访问索引以查找匹配索引条件的行位置，然后上层计划节点实际上从表本身获取这些行。单独获取行的成本比顺序读取它们昂贵得多，但由于不必访问表的所有页面，这仍然比顺序扫描便宜。（使用两个计划级别的原因是上层计划节点在读取它们之前，将索引识别的行位置按物理顺序排序，以最小化单独获取的成本。“位图”在节点名称中提到的机制是执行排序的机制。） 现在，让我们在 WHERE 子句中添加另一个条件： 123456789EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx'; QUERY PLAN------------------------------------------------------------------------------ Bitmap Heap Scan on tenk1 (cost=5.04..225.20 rows=1 width=244) Recheck Cond: (unique1 &lt; 100) Filter: (stringu1 = 'xxx'::name) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) Index Cond: (unique1 &lt; 100) 添加的条件 stringu1 = 'xxx' 减少了输出行数估计，但没有减少成本，因为我们仍然需要访问相同的行集。这是因为 stringu1 子句不能作为索引条件应用，因为此索引只在 unique1 列上。相反，它被作为过滤器应用于使用索引检索的行。因此，成本实际上略有上升，以反映这种额外的检查。 在某些情况下，规划器会选择“简单”索引扫描计划： 123456EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42; QUERY PLAN----------------------------------------------------------------------------- Index Scan using tenk1_unique1 on tenk1 (cost=0.29..8.30 rows=1 width=244) Index Cond: (unique1 = 42) 在这种类型的计划中，表行按索引顺序获取，这使得读取它们更加昂贵，但由于行数很少，排序行位置的额外成本不值得。对于只获取单行的查询，您最常会看到这种计划类型。它也常用于具有匹配索引顺序的 ORDER BY 条件的查询，因为这样就不需要额外的排序步骤来满足 ORDER BY。在此示例中，添加 ORDER BY unique1 将使用相同的计划，因为索引已经隐式提供了请求的排序。 规划器可以通过多种方式实现 ORDER BY 子句。上面的示例显示这种排序子句可以隐式实现。规划器也可能添加一个显式的 Sort 步骤： 1234567EXPLAIN SELECT * FROM tenk1 ORDER BY unique1; QUERY PLAN------------------------------------------------------------------- Sort (cost=1109.39..1134.39 rows=10000 width=244) Sort Key: unique1 -&gt; Seq Scan on tenk1 (cost=0.00..445.00 rows=10000 width=244) 如果计划的一部分保证了所需排序键前缀上的排序，那么规划器可能会决定改用增量排序步骤： 123456789EXPLAIN SELECT * FROM tenk1 ORDER BY hundred, ten LIMIT 100; QUERY PLAN------------------------------------------------------------------------------------------------ Limit (cost=19.35..39.49 rows=100 width=244) -&gt; Incremental Sort (cost=19.35..2033.39 rows=10000 width=244) Sort Key: hundred, ten Presorted Key: hundred -&gt; Index Scan using tenk1_hundred on tenk1 (cost=0.29..1574.20 rows=10000 width=244) 与常规排序相比，增量排序允许在整个结果集排序完成之前返回元组，这尤其有利于 LIMIT 查询的优化。它还可以减少内存使用和将排序溢出到磁盘的可能性，但这需要以增加将结果集分成多个排序批次的开销为代价。 如果在 WHERE 子句中引用的多个列上有单独的索引，规划器可能会选择使用索引的 AND 或 OR 组合： 1234567891011EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000; QUERY PLAN------------------------------------------------------------------------------------- Bitmap Heap Scan on tenk1 (cost=25.07..60.11 rows=10 width=244) Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000)) -&gt; BitmapAnd (cost=25.07..25.07 rows=10 width=0) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) Index Cond: (unique1 &lt; 100) -&gt; Bitmap Index Scan on tenk1_unique2 (cost=0.00..19.78 rows=999 width=0) Index Cond: (unique2 &gt; 9000) 但这需要访问两个索引，因此与仅使用一个索引并将另一个条件作为过滤器处理相比，不一定有优势。如果您更改涉及的范围，您会看到计划相应地更改。 这是一个显示 LIMIT 效果的示例： 12345678EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2; QUERY PLAN------------------------------------------------------------------------------------- Limit (cost=0.29..14.28 rows=2 width=244) -&gt; Index Scan using tenk1_unique2 on tenk1 (cost=0.29..70.27 rows=10 width=244) Index Cond: (unique2 &gt; 9000) Filter: (unique1 &lt; 100) 这与上面的查询相同，但我们添加了 LIMIT，这样就不需要检索所有行，规划器也改变了它的做法。请注意，Index Scan 节点的总成本和行数显示为如果它运行完成。但是，Limit 节点预计在检索到五分之一的行后停止，因此其总成本仅为五分之一，这就是查询的实际估计成本。此计划优于向先前计划添加 Limit 节点，因为 Limit 无法避免支付位图扫描的启动成本，因此该方法总成本将超过 25 个单位。 让我们尝试连接两个表，使用我们一直在讨论的列： 12345678910111213EXPLAIN SELECT *FROM tenk1 t1, tenk2 t2WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2; QUERY PLAN-------------------------------------------------------------------------------------- Nested Loop (cost=4.65..118.50 rows=10 width=488) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.36..39.38 rows=10 width=244) Recheck Cond: (unique1 &lt; 10) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.36 rows=10 width=0) Index Cond: (unique1 &lt; 10) -&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.29..7.90 rows=1 width=244) Index Cond: (unique2 = t1.unique2) 在此计划中，我们有一个嵌套循环连接节点，其输入或子节点是两个表扫描。节点摘要行的缩进反映了计划树结构。连接的第一个或“外部”子节点是位图扫描，类似于我们之前看到的那些。它的成本和行数与我们从 SELECT ... WHERE unique1 &lt; 10 获得的结果相同，因为我们在该节点应用 WHERE 子句 unique1 &lt; 10。t1.unique2 = t2.unique2 子句尚未相关，因此它不影响外部扫描的行数。嵌套循环连接节点将为其从外部子节点获得的每一行运行其第二个或“内部”子节点一次。当前外部行中的列值可以插入到内部扫描中；在这里，外部行中的 t1.unique2 值可用，因此我们得到了一个计划和成本，类似于我们上面为简单 SELECT ... WHERE t2.unique2 = constant 情况所看到的。（估计成本实际上比上面看到的略低，这是由于在 t2 上重复索引扫描期间预期的缓存所致。）然后根据外部扫描的成本，加上每个外部行内部扫描的一次重复（这里是 10 * 7.90），再加上一点用于连接处理的 CPU 时间来设置循环节点的成本。 在本例中，连接的输出行数与两次扫描的行数乘积相同，但这并非在所有情况下都如此，因为可能存在提及两个表的额外 WHERE 子句，因此只能在连接点而不是任何输入扫描处应用。下面是一个例子： 123456789101112131415EXPLAIN SELECT *FROM tenk1 t1, tenk2 t2WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred; QUERY PLAN--------------------------------------------------------------------------------------------- Nested Loop (cost=4.65..49.36 rows=33 width=488) Join Filter: (t1.hundred &lt; t2.hundred) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.36..39.38 rows=10 width=244) Recheck Cond: (unique1 &lt; 10) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.36 rows=10 width=0) Index Cond: (unique1 &lt; 10) -&gt; Materialize (cost=0.29..8.51 rows=10 width=244) -&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.29..8.46 rows=10 width=244) Index Cond: (unique2 &lt; 10) 条件 t1.hundred &lt; t2.hundred 无法在 tenk2_unique2 索引中测试，因此它在连接节点应用。这减少了连接节点的估计输出行数，但没有改变任何输入扫描。 请注意，这里规划器选择通过在连接上放置一个 Materialize 计划节点来“具体化”连接的内部关系。这意味着 t2 索引扫描只会执行一次，即使嵌套循环连接节点需要读取该数据十次，即对于外部关系的每一行一次。Materialize 节点在读取数据时将其保存在内存中，然后在每次后续通过时从内存中返回数据。 在处理外连接时，您可能会看到附加了“Join Filter”和纯“Filter”条件的连接计划节点。Join Filter 条件来自外连接的 ON 子句，因此未能通过 Join Filter 条件的行仍然可以作为空扩展行发出。但纯 Filter 条件在外连接规则之后应用，因此可以无条件地删除行。在内连接中，这些过滤器类型之间没有语义差异。 如果我们稍微改变查询的选择性，我们可能会得到一个非常不同的连接计划： 1234567891011121314EXPLAIN SELECT *FROM tenk1 t1, tenk2 t2WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2; QUERY PLAN------------------------------------------------------------------------------------------ Hash Join (cost=226.23..709.73 rows=100 width=488) Hash Cond: (t2.unique2 = t1.unique2) -&gt; Seq Scan on tenk2 t2 (cost=0.00..445.00 rows=10000 width=244) -&gt; Hash (cost=224.98..224.98 rows=100 width=244) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=5.06..224.98 rows=100 width=244) Recheck Cond: (unique1 &lt; 100) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) Index Cond: (unique1 &lt; 100) 这里，规划器选择使用哈希连接，其中一个表的行被输入到内存中的哈希表，然后扫描另一个表，并探测哈希表以查找与每行的匹配项。再次注意缩进如何反映计划结构：tenk1 上的位图扫描是 Hash 节点的输入，该节点构造哈希表。然后将其返回到 Hash Join 节点，该节点从其外部子计划读取行并为每行搜索哈希表。 另一种可能的连接类型是合并连接，示例如下： 1234567891011EXPLAIN SELECT *FROM tenk1 t1, onek t2WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2; QUERY PLAN------------------------------------------------------------------------------------------ Merge Join (cost=0.56..233.49 rows=10 width=488) Merge Cond: (t1.unique2 = t2.unique2) -&gt; Index Scan using tenk1_unique2 on tenk1 t1 (cost=0.29..643.28 rows=100 width=244) Filter: (unique1 &lt; 100) -&gt; Index Scan using onek_unique2 on onek t2 (cost=0.28..166.28 rows=1000 width=244) 合并连接要求其输入数据按连接键排序。在本例中，每个输入都通过使用索引扫描按正确顺序访问行进行排序；但也可以使用顺序扫描和排序。（由于索引扫描所需的非顺序磁盘访问，顺序扫描和排序通常在排序多行时优于索引扫描。） 一种查看变体计划的方法是强制规划器不考虑它认为最便宜的策略，使用 Section 19.7.1 中描述的启用/禁用标志。（这是一个粗糙但有用的工具。另请参阅 Section 14.3）。例如，如果我们不相信合并连接是上一个示例的最佳连接类型，我们可以尝试 12345678910111213141516SET enable_mergejoin = off;EXPLAIN SELECT *FROM tenk1 t1, onek t2WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2; QUERY PLAN------------------------------------------------------------------------------------------ Hash Join (cost=226.23..344.08 rows=10 width=488) Hash Cond: (t2.unique2 = t1.unique2) -&gt; Seq Scan on onek t2 (cost=0.00..114.00 rows=1000 width=244) -&gt; Hash (cost=224.98..224.98 rows=100 width=244) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=5.06..224.98 rows=100 width=244) Recheck Cond: (unique1 &lt; 100) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) Index Cond: (unique1 &lt; 100) 这表明规划器认为在这种情况下哈希连接会比合并连接贵近 50%。当然，下一个问题是它是否正确。我们可以使用 EXPLAIN ANALYZE 来调查这一点，如下所述。 有些查询计划涉及子计划，它们源自原始查询中的子 SELECT。此类查询有时可以转换为普通的连接计划，但当它们无法转换时，我们会得到如下计划： 12345678910111213EXPLAIN VERBOSE SELECT unique1FROM tenk1 tWHERE t.ten &lt; ALL (SELECT o.ten FROM onek o WHERE o.four = t.four); QUERY PLAN------------------------------------------------------------------------- Seq Scan on public.tenk1 t (cost=0.00..586095.00 rows=5000 width=4) Output: t.unique1 Filter: (ALL (t.ten &lt; (SubPlan 1).col1)) SubPlan 1 -&gt; Seq Scan on public.onek o (cost=0.00..116.50 rows=250 width=4) Output: o.ten Filter: (o.four = t.four) 这个相当人为的例子说明了几点：外部计划级别的值可以向下传递到子计划（这里，t.four 被向下传递），并且子选择的结果可用于外部计划。EXPLAIN 用 (subplan_name).colN 这样的表示法显示这些结果值，它指的是子 SELECT 的第 N 个输出列。 在上面的示例中，ALL 运算符为外部查询的每一行再次运行子计划（这解释了其高估计成本）。一些查询可以使用哈希子计划来避免这种情况： 1234567891011EXPLAIN SELECT *FROM tenk1 tWHERE t.unique1 NOT IN (SELECT o.unique1 FROM onek o); QUERY PLAN-------------------------------------------------------------------------------------------- Seq Scan on tenk1 t (cost=61.77..531.77 rows=5000 width=244) Filter: (NOT (ANY (unique1 = (hashed SubPlan 1).col1))) SubPlan 1 -&gt; Index Only Scan using onek_unique1 on onek o (cost=0.28..59.27 rows=1000 width=4)(4 rows) 在这里，子计划只运行一次，其输出被加载到内存中的哈希表，然后由外部 ANY 运算符进行探测。这要求子 SELECT 不引用外部查询的任何变量，并且 ANY 的比较运算符适合哈希。 如果除了不引用外部查询的任何变量之外，子 SELECT 不能返回多于一行，那么它可能被实现为 initplan： 1234567891011EXPLAIN VERBOSE SELECT unique1FROM tenk1 t1 WHERE t1.ten = (SELECT (random() * 10)::integer); QUERY PLAN-------------------------------------------------------------------- Seq Scan on public.tenk1 t1 (cost=0.02..470.02 rows=1000 width=4) Output: t1.unique1 Filter: (t1.ten = (InitPlan 1).col1) InitPlan 1 -&gt; Result (cost=0.00..0.02 rows=1 width=4) Output: ((random() * '10'::double precision))::integer initplan 在外部计划的每次执行中只运行一次，其结果被保存以供外部计划的后续行重复使用。因此，在这个例子中，random() 只评估一次，并且 t1.ten 的所有值都与相同的随机选择的整数进行比较。这与没有子 SELECT 构造时发生的情况大不相同。 14.1.2. EXPLAIN ANALYZE 可以使用 EXPLAIN 的 ANALYZE 选项检查规划器估计的准确性。使用此选项，EXPLAIN 实际上会执行查询，然后显示在每个计划节点中累积的真实行数和真实运行时间，以及普通 EXPLAIN 显示的相同估计值。例如，我们可能会得到这样的结果： 12345678910111213141516EXPLAIN ANALYZE SELECT *FROM tenk1 t1, tenk2 t2WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2; QUERY PLAN--------------------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=4.65..118.50 rows=10 width=488) (actual time=0.017..0.051 rows=10 loops=1) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=4.36..39.38 rows=10 width=244) (actual time=0.009..0.017 rows=10 loops=1) Recheck Cond: (unique1 &lt; 10) Heap Blocks: exact=10 -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..4.36 rows=10 width=0) (actual time=0.004..0.004 rows=10 loops=1) Index Cond: (unique1 &lt; 10) -&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.29..7.90 rows=1 width=244) (actual time=0.003..0.003 rows=1 loops=10) Index Cond: (unique2 = t1.unique2) Planning Time: 0.485 ms Execution Time: 0.073 ms 请注意，“actual time”值以毫秒为单位（实时时间），而成本估计以任意单位表示；因此它们不太可能匹配。通常最重要的是查看估计的行数是否与实际情况合理接近。在这个例子中，估计值都非常准确，但实际上这很不常见。 在某些查询计划中，子计划节点可能会多次执行。例如，在上述嵌套循环计划中，内部索引扫描将每外部行执行一次。在这种情况下，loops 值报告节点的总执行次数，显示的实际时间和行值是每次执行的平均值。这样做是为了使数字与成本估计的显示方式保持可比性。乘以 loops 值以获得节点中实际花费的总时间。在上面的例子中，我们在 tenk2 上执行索引扫描总共花费了 0.030 毫秒。 在某些情况下，EXPLAIN ANALYZE 除了计划节点执行时间和行数外，还会显示额外的执行统计信息。例如，Sort 和 Hash 节点提供了额外的信息： 123456789101112131415161718192021EXPLAIN ANALYZE SELECT *FROM tenk1 t1, tenk2 t2WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous; QUERY PLAN-------------------------------------------------------------------------------------------------------------------------------------------- Sort (cost=713.05..713.30 rows=100 width=488) (actual time=2.995..3.002 rows=100 loops=1) Sort Key: t1.fivethous Sort Method: quicksort Memory: 74kB -&gt; Hash Join (cost=226.23..709.73 rows=100 width=488) (actual time=0.515..2.920 rows=100 loops=1) Hash Cond: (t2.unique2 = t1.unique2) -&gt; Seq Scan on tenk2 t2 (cost=0.00..445.00 rows=10000 width=244) (actual time=0.026..1.790 rows=10000 loops=1) -&gt; Hash (cost=224.98..224.98 rows=100 width=244) (actual time=0.476..0.477 rows=100 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 35kB -&gt; Bitmap Heap Scan on tenk1 t1 (cost=5.06..224.98 rows=100 width=244) (actual time=0.030..0.450 rows=100 loops=1) Recheck Cond: (unique1 &lt; 100) Heap Blocks: exact=90 -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) (actual time=0.013..0.013 rows=100 loops=1) Index Cond: (unique1 &lt; 100) Planning Time: 0.187 ms Execution Time: 3.036 ms Sort 节点显示使用的排序方法（特别是排序是在内存中还是在磁盘上）以及所需的内存或磁盘空间量。Hash 节点显示哈希桶和批次的数量以及哈希表使用的峰值内存量。（如果批次数量超过一个，还将涉及磁盘空间使用，但未显示。） 另一种额外信息类型是被过滤条件删除的行数： 123456789EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7; QUERY PLAN--------------------------------------------------------------------------------------------------------- Seq Scan on tenk1 (cost=0.00..470.00 rows=7000 width=244) (actual time=0.030..1.995 rows=7000 loops=1) Filter: (ten &lt; 7) Rows Removed by Filter: 3000 Planning Time: 0.102 ms Execution Time: 2.145 ms 这些计数对于在连接节点应用的过滤器条件特别有价值。“Rows Removed”行仅在至少有一行被扫描（或者在连接节点的情况下，潜在的连接对）被过滤器条件拒绝时才出现。 与过滤条件类似的情况发生在“有损”索引扫描中。例如，考虑以下搜索包含特定点的多边形： 123456789EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)'; QUERY PLAN------------------------------------------------------------------------------------------------------ Seq Scan on polygon_tbl (cost=0.00..1.09 rows=1 width=85) (actual time=0.023..0.023 rows=0 loops=1) Filter: (f1 @&gt; '((0.5,2))'::polygon) Rows Removed by Filter: 7 Planning Time: 0.039 ms Execution Time: 0.033 ms 规划器认为（非常正确地）这个样本表太小，不值得使用索引扫描，所以我们有一个普通的顺序扫描，其中所有行都被过滤条件拒绝。但如果我们强制使用索引扫描，我们会看到： 1234567891011SET enable_seqscan TO off;EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)'; QUERY PLAN-------------------------------------------------------------------------------------------------------------------------- Index Scan using gpolygonind on polygon_tbl (cost=0.13..8.15 rows=1 width=85) (actual time=0.074..0.074 rows=0 loops=1) Index Cond: (f1 @&gt; '((0.5,2))'::polygon) Rows Removed by Index Recheck: 1 Planning Time: 0.039 ms Execution Time: 0.098 ms 这里我们可以看到索引返回了一个候选行，然后该行被索引条件的重新检查拒绝了。发生这种情况是因为 GiST 索引对于多边形包含测试是“有损的”：它实际上返回与目标重叠的多边形的行，然后我们必须对这些行进行精确的包含测试。 EXPLAIN 有一个 BUFFERS 选项，可以与 ANALYZE 结合使用以获取更多运行时统计信息： 1234567891011121314151617181920EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000; QUERY PLAN--------------------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on tenk1 (cost=25.07..60.11 rows=10 width=244) (actual time=0.105..0.114 rows=10 loops=1) Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000)) Heap Blocks: exact=10 Buffers: shared hit=14 read=3 -&gt; BitmapAnd (cost=25.07..25.07 rows=10 width=0) (actual time=0.100..0.101 rows=0 loops=1) Buffers: shared hit=4 read=3 -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) (actual time=0.027..0.027 rows=100 loops=1) Index Cond: (unique1 &lt; 100) Buffers: shared hit=2 -&gt; Bitmap Index Scan on tenk1_unique2 (cost=0.00..19.78 rows=999 width=0) (actual time=0.070..0.070 rows=999 loops=1) Index Cond: (unique2 &gt; 9000) Buffers: shared hit=2 read=3 Planning: Buffers: shared hit=3 Planning Time: 0.162 ms Execution Time: 0.143 ms BUFFERS 提供的数据有助于识别查询中哪些部分是 I/O 密集型。 请记住，由于 EXPLAIN ANALYZE 实际运行查询，任何副作用都会照常发生，即使查询可能输出的任何结果都被丢弃以利于打印 EXPLAIN 数据。如果您想分析数据修改查询而不更改表，您可以在之后回滚命令，例如： 12345678910111213141516BEGIN;EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; 100; QUERY PLAN-------------------------------------------------------------------------------------------------------------------------------- Update on tenk1 (cost=5.06..225.23 rows=0 width=0) (actual time=1.634..1.635 rows=0 loops=1) -&gt; Bitmap Heap Scan on tenk1 (cost=5.06..225.23 rows=100 width=10) (actual time=0.065..0.141 rows=100 loops=1) Recheck Cond: (unique1 &lt; 100) Heap Blocks: exact=90 -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..5.04 rows=100 width=0) (actual time=0.031..0.031 rows=100 loops=1) Index Cond: (unique1 &lt; 100) Planning Time: 0.151 ms Execution Time: 1.856 msROLLBACK; 如本例所示，当查询是 INSERT、UPDATE、DELETE 或 MERGE 命令时，应用表更改的实际工作由顶层 Insert、Update、Delete 或 Merge 计划节点完成。该节点下的计划节点执行定位旧行和/或计算新数据的工作。因此，上面我们看到了与我们已经看到的位图表扫描相同的类型，其输出被馈送到一个 Update 节点，该节点存储更新的行。值得注意的是，尽管数据修改节点可能占用相当多的运行时间（这里它消耗了大部分时间），但规划器目前没有为该工作添加任何成本估计。那是因为要完成的工作对于每个正确的查询计划都是相同的，因此它不影响规划决策。 当 UPDATE、DELETE 或 MERGE 命令影响分区表或继承层次结构时，输出可能如下所示： 123456789101112131415EXPLAIN UPDATE gtest_parent SET f1 = CURRENT_DATE WHERE f2 = 101; QUERY PLAN---------------------------------------------------------------------------------------- Update on gtest_parent (cost=0.00..3.06 rows=0 width=0) Update on gtest_child gtest_parent_1 Update on gtest_child2 gtest_parent_2 Update on gtest_child3 gtest_parent_3 -&gt; Append (cost=0.00..3.06 rows=3 width=14) -&gt; Seq Scan on gtest_child gtest_parent_1 (cost=0.00..1.01 rows=1 width=14) Filter: (f2 = 101) -&gt; Seq Scan on gtest_child2 gtest_parent_2 (cost=0.00..1.01 rows=1 width=14) Filter: (f2 = 101) -&gt; Seq Scan on gtest_child3 gtest_parent_3 (cost=0.00..1.01 rows=1 width=14) Filter: (f2 = 101) 在此示例中，Update 节点需要考虑三个子表，而不是最初提到的分区表（因为它从不存储任何数据）。因此，有三个输入扫描子计划，每个表一个。为了清晰起见，Update 节点被注释以显示将要更新的特定目标表，其顺序与相应的子计划相同。 EXPLAIN ANALYZE 显示的 Planning time 是从解析的查询生成查询计划并对其进行优化所需的时间。它不包括解析或重写。 EXPLAIN ANALYZE 显示的 Execution time 包括执行器启动和关闭时间，以及运行任何触发器的触发时间，但不包括解析、重写或规划时间。执行 BEFORE 触发器所花费的时间（如果有）包含在相关 Insert、Update 或 Delete 节点的时间中；但执行 AFTER 触发器所花费的时间不计入其中，因为 AFTER 触发器在整个计划完成后才触发。每个触发器（无论是 BEFORE 还是 AFTER）中花费的总时间也单独显示。请注意，延迟约束触发器直到事务结束才会执行，因此 EXPLAIN ANALYZE 完全不考虑它们。 顶级节点显示的时间不包括将查询的输出数据转换为可显示形式或将其发送到客户端所需的任何时间。虽然 EXPLAIN ANALYZE 永远不会将数据发送到客户端，但可以通过指定 SERIALIZE 选项来指示它将查询的输出数据转换为可显示形式并测量所需时间。该时间将单独显示，并且也包含在总 Execution time 中。 14.1.3. 注意事项 EXPLAIN ANALYZE 测量的运行时间与相同查询的正常执行方式之间存在两种显著差异。首先，由于没有输出行传递给客户端，因此不包括网络传输成本。除非指定 SERIALIZE，否则也不包括 I/O 转换成本。其次，EXPLAIN ANALYZE 添加的测量开销可能很大，尤其是在 gettimeofday() 操作系统调用缓慢的机器上。您可以使用 pg_test_timing 工具来测量您系统上计时开销。 EXPLAIN 的结果不应外推到与您实际测试的情况大相径庭的场景；例如，不能假定在玩具大小的表上的结果适用于大型表。规划器的成本估算不是线性的，因此它可能会为更大或更小的表选择不同的计划。一个极端的例子是，对于只占用一个磁盘页面的表，您几乎总是会得到一个顺序扫描计划，无论是否有索引可用。规划器知道无论如何处理表都需要读取一个磁盘页面，因此花费额外的页面读取来查看索引没有价值。（我们上面在 polygon_tbl 示例中看到了这一点。） 在某些情况下，实际值和估计值可能不匹配，但实际上并没有问题。一个这样的情况发生在计划节点执行因 LIMIT 或类似效果而提前停止时。例如，在我们之前使用的 LIMIT 查询中， 1234567891011EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2; QUERY PLAN------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.29..14.33 rows=2 width=244) (actual time=0.051..0.071 rows=2 loops=1) -&gt; Index Scan using tenk1_unique2 on tenk1 (cost=0.29..70.50 rows=10 width=244) (actual time=0.051..0.070 rows=2 loops=1) Index Cond: (unique2 &gt; 9000) Filter: (unique1 &lt; 100) Rows Removed by Filter: 287 Planning Time: 0.077 ms Execution Time: 0.086 ms Index Scan 节点的估计成本和行数显示为它已运行完成。但实际上 Limit 节点在获取到两行后停止请求行，因此实际行数仅为 2，并且运行时间低于成本估计所暗示的。这不是估计错误，只是估计值和真实值显示方式上的差异。 合并连接也有可能让不熟悉的人感到困惑的测量伪影。如果合并连接用尽了另一个输入，并且一个输入中的下一个键值大于另一个输入中的最后一个键值，它将停止读取一个输入；在这种情况下，将不再有匹配项，因此不需要扫描第一个输入的其余部分。这导致不读取一个子节点的全部内容，其结果类似于 LIMIT 中提到的情况。此外，如果外部（第一个）子节点包含具有重复键值的行，则内部（第二个）子节点会回溯并重新扫描与其键值匹配的那部分行。EXPLAIN ANALYZE 将这些相同的内部行的重复发出计为实际的额外行。当有许多外部重复项时，内部子计划节点的报告实际行数可能显著大于内部关系中实际的行数。 由于实现限制，BitmapAnd 和 BitmapOr 节点始终将其实际行数报告为零。 通常，EXPLAIN 将显示规划器创建的每个计划节点。但是，在某些情况下，执行器可以根据规划时不可用的参数值确定某些节点不需要执行，因为它们无法生成任何行。（目前这只可能发生在正在扫描分区表的 Append 或 MergeAppend 节点的子节点。）发生这种情况时，这些计划节点将从 EXPLAIN 输出中省略，并显示 Subplans Removed: N 注释。 参考 using-explain","link":"/postgres/2025/07/17/explain/index.html"}],"tags":[{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"入门教程","slug":"入门教程","link":"/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"JetBrains 全家桶","slug":"JetBrains-全家桶","link":"/tags/JetBrains-%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","link":"/tags/IntelliJ-IDEA/"},{"name":"WebStorm","slug":"WebStorm","link":"/tags/WebStorm/"},{"name":"GoLand","slug":"GoLand","link":"/tags/GoLand/"},{"name":"DataGrip","slug":"DataGrip","link":"/tags/DataGrip/"},{"name":"Docker Hub","slug":"Docker-Hub","link":"/tags/Docker-Hub/"},{"name":"庐山","slug":"庐山","link":"/tags/%E5%BA%90%E5%B1%B1/"},{"name":"消费","slug":"消费","link":"/tags/%E6%B6%88%E8%B4%B9/"},{"name":"个人总结","slug":"个人总结","link":"/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"},{"name":"音乐流媒体","slug":"音乐流媒体","link":"/tags/%E9%9F%B3%E4%B9%90%E6%B5%81%E5%AA%92%E4%BD%93/"},{"name":"自建","slug":"自建","link":"/tags/%E8%87%AA%E5%BB%BA/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"event","slug":"event","link":"/tags/event/"},{"name":"珂朵莉树","slug":"珂朵莉树","link":"/tags/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"},{"name":"老司机树","slug":"老司机树","link":"/tags/%E8%80%81%E5%8F%B8%E6%9C%BA%E6%A0%91/"},{"name":"VisualVM","slug":"VisualVM","link":"/tags/VisualVM/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"深度优先遍历","slug":"深度优先遍历","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"哈希计数","slug":"哈希计数","link":"/tags/%E5%93%88%E5%B8%8C%E8%AE%A1%E6%95%B0/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"大根堆","slug":"大根堆","link":"/tags/%E5%A4%A7%E6%A0%B9%E5%A0%86/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"分治法","slug":"分治法","link":"/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序哈希","slug":"有序哈希","link":"/tags/%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C/"},{"name":"优先级队列","slug":"优先级队列","link":"/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"中序遍历","slug":"中序遍历","link":"/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"一次遍历","slug":"一次遍历","link":"/tags/%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"差分数组","slug":"差分数组","link":"/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"},{"name":"直接计算","slug":"直接计算","link":"/tags/%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"广度优先遍历","slug":"广度优先遍历","link":"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"},{"name":"前缀树","slug":"前缀树","link":"/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"辗转相除法","slug":"辗转相除法","link":"/tags/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/"},{"name":"双重循环","slug":"双重循环","link":"/tags/%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AF/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"反转链表","slug":"反转链表","link":"/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"层序遍历","slug":"层序遍历","link":"/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","link":"/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"前序遍历","slug":"前序遍历","link":"/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"模运算","slug":"模运算","link":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/"},{"name":"堆栈","slug":"堆栈","link":"/tags/%E5%A0%86%E6%A0%88/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"双端队列","slug":"双端队列","link":"/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"循环","slug":"循环","link":"/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"双层循环","slug":"双层循环","link":"/tags/%E5%8F%8C%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"name":"LeetCode 里程碑","slug":"LeetCode-里程碑","link":"/tags/LeetCode-%E9%87%8C%E7%A8%8B%E7%A2%91/"},{"name":"四舍五入","slug":"四舍五入","link":"/tags/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","link":"/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"Dijkstra 算法","slug":"Dijkstra-算法","link":"/tags/Dijkstra-%E7%AE%97%E6%B3%95/"},{"name":"最小值之差","slug":"最小值之差","link":"/tags/%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%B7%AE/"},{"name":"一叶智能","slug":"一叶智能","link":"/tags/%E4%B8%80%E5%8F%B6%E6%99%BA%E8%83%BD/"},{"name":"技术面","slug":"技术面","link":"/tags/%E6%8A%80%E6%9C%AF%E9%9D%A2/"},{"name":"一面","slug":"一面","link":"/tags/%E4%B8%80%E9%9D%A2/"},{"name":"江西燃点","slug":"江西燃点","link":"/tags/%E6%B1%9F%E8%A5%BF%E7%87%83%E7%82%B9/"},{"name":"深圳同行者","slug":"深圳同行者","link":"/tags/%E6%B7%B1%E5%9C%B3%E5%90%8C%E8%A1%8C%E8%80%85/"},{"name":"行云绽放","slug":"行云绽放","link":"/tags/%E8%A1%8C%E4%BA%91%E7%BB%BD%E6%94%BE/"},{"name":"一临云科技","slug":"一临云科技","link":"/tags/%E4%B8%80%E4%B8%B4%E4%BA%91%E7%A7%91%E6%8A%80/"},{"name":"易世通达(跨境电商)","slug":"易世通达-跨境电商","link":"/tags/%E6%98%93%E4%B8%96%E9%80%9A%E8%BE%BE-%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86/"},{"name":"卓讯信息技术","slug":"卓讯信息技术","link":"/tags/%E5%8D%93%E8%AE%AF%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/"},{"name":"langchain4j","slug":"langchain4j","link":"/tags/langchain4j/"},{"name":"mcp","slug":"mcp","link":"/tags/mcp/"},{"name":"mcp-client","slug":"mcp-client","link":"/tags/mcp-client/"},{"name":"rag","slug":"rag","link":"/tags/rag/"},{"name":"langgraph4j","slug":"langgraph4j","link":"/tags/langgraph4j/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"自组","slug":"自组","link":"/tags/%E8%87%AA%E7%BB%84/"},{"name":"explain","slug":"explain","link":"/tags/explain/"}],"categories":[{"name":"mongodb","slug":"mongodb","link":"/categories/mongodb/"},{"name":"MyBatis","slug":"MyBatis","link":"/categories/MyBatis/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/categories/GitHub-Actions/"},{"name":"破解","slug":"破解","link":"/categories/%E7%A0%B4%E8%A7%A3/"},{"name":"Docker Hub","slug":"Docker-Hub","link":"/categories/Docker-Hub/"},{"name":"旅游","slug":"旅游","link":"/categories/%E6%97%85%E6%B8%B8/"},{"name":"碎碎念","slug":"碎碎念","link":"/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"spring event","slug":"spring-event","link":"/categories/spring-event/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"},{"name":"LeetCode每日一题","slug":"LeetCode每日一题","link":"/categories/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"路线规划","slug":"旅游/路线规划","link":"/categories/%E6%97%85%E6%B8%B8/%E8%B7%AF%E7%BA%BF%E8%A7%84%E5%88%92/"},{"name":"spring transaction","slug":"spring-event/spring-transaction","link":"/categories/spring-event/spring-transaction/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"面经","slug":"面经","link":"/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"ai","slug":"ai","link":"/categories/ai/"},{"name":"dart","slug":"ai/dart","link":"/categories/ai/dart/"},{"name":"折叠自行车","slug":"折叠自行车","link":"/categories/%E6%8A%98%E5%8F%A0%E8%87%AA%E8%A1%8C%E8%BD%A6/"},{"name":"postgres","slug":"postgres","link":"/categories/postgres/"}],"pages":[{"title":"wuhunyuの个人简历","text":"联系方式 手机：15687225042 (归属地为云南大理) Email：wuhunyu@gmail.com 微信号：wuhunyu3312 个人信息 龚志强 / 男 / 26岁 / 1997年12月出生 全日制统招本科 / 大理大学(2016.9 ~ 2020.7) / 计算机科学与技术 实际工作年限：4 年 期望职位：Java 工程师 力扣：https://leetcode.cn/u/wuhunyu 个人博客：https://wuhunyu.top 技能清单 熟练使用 MySQL，了解 sql 优化，开发过程中善于分析并优化 sql 熟练使用 Redis，了解 Redis 各个数据结构和持久化策略，并能根据不同的应用场景选择合适的数据结构 熟练使用 RocketMQ，善于使用 MQ 用于服务异步通信，延时队列等 熟练使用 Linux，Nginx，Docker 常用命令，能够编写简单的脚本并部署项目 熟练使用 Netty 框架，能够独立开发 RPC 框架 能够整合 SpringCloud Alibaba 微服务全家桶，能够独立开发微服务项目 阅读过 Java 常用集合的源码，在开发中会注意根据源码优化代码 了解 JUC 并发工具的使用，阅读过 CAS，AQS 源码 了解 JVM 运行原理，能够简单分析 dump 文件 工作经历江西绿萌科技控股有限公司（2022.10 ~ 2023.10） 绿萌云（2022.10 ~ 2023.10）Java 中级开发项目简介绿萌云是一个水果分选加工管理平台，涵盖了水果种植数据监控，采购入库，分选加工，仓储管理，销售出库，水果溯源等一整套水果管理流程 担任职责我在项目中主要负责水果种植期的数据监控模块和采购入库模块的开发工作 主要成果 水果的数据采集设备上报数据的频率大约为每 5 秒一次，我采用数据冷热分离的方式，保留最近一个月的实时数据以及最近三年的统计结果，过期的实时数据保存在冷库中，保证了监控数据的实时查询效率 监控数据异常或者采购入库成功时，需要在云平台实时通知管理者。由于平台是微服务架构集群的部署方式，我是通过 RocketMQ 广播的方式来解决WebSocket 分布式 Session 的问题 技术架构SpringCloudAlibaba MyBatis-Plus Redis Gateway Nacos Dubbo Quartz RocketMQ WebSocket 江西憶源多媒体科技有限公司（2021.2 ~ 2022.8） 校园资产管理平台（2022.2 ~ 2022.8）Java 初级开发项目简介对校园内的贵重资产进行管理记录，包含资产数字化管理，资产报表以及资产数据分析等模块 担任职责我负责该管理平台后端开发的领导人角色，主要负责的模块有资产数字化管理，资产报表 主要成果开发了一些方便的工具帮助快速开发，如：代码生成，Excel 导出工具，Cron 表达式转换工具，Java Bean 转 Map 工具等，得到了项目组其他同事的认可 技术架构SpringCloud MyBatis-Plus Redis Gateway Eureka OpenFeign Quartz 智慧警务管理平台（2021.8 ~ 2022.1）Java 初级开发项目简介统一管理派出所内部有所有装备柜设备，包括装备状态监控，装备数据报表，警员管理等模块 担任职责我主要负责装备状态监控模块的开发 主要成果每个装备的状态信息不会主动上报，需要系统主动去获取。我采用定时更新+增量更新的方式来获取每个装备的状态信息，每 5 分钟轮询一次，以及在用主动查询主动更新。保证了装备状态数据的最终一致性 技术架构SpringCloud MyBatis-Plus Redis Gateway Eureka OpenFeign 随手拍（2021.2 ~ 2021.7）Java 初级开发项目简介居民不文明或隐患行为拍照上传的微信小程序 担任职责我主要负责微信小程序后台的授权登录以及举报奖励模块的开发 主要成果举报奖励模块对接了微信的公众服务 企业付款到零钱，加入了幂等，重试等机制保证可靠性，支付失败会有告警提示。小程序交付运行一年以来，除了部分未实名认证无法收款的微信用户外，未出现异常 技术架构SpringBoot MyBatis-Plus Redis 宇信鸿泰科技有限公司（2020.3 ~ 2020.12） 中国进出口网上银行（2020.7 ~ 2020.12）Java 初级开发项目简介 &amp; 担任职责我在此项目中负责了电子对账业务，用户电子账号管理，账单提交以及账单复核等模块的开发 主要成果最后在同事的帮助下成功通过线上测试并发布到线上 技术框架SSM 手机银行（2020.3 ~ 2020.6）Java 实习项目简介 &amp; 担任职责在此项目中我使用 MUI 框架开发网上银行移动端页面，包含用户登录与注册和网上银行转账业务两个模块 主要成果通过这两个模块的开发，快速学习了移动端 H5 的开发过程，为今后接手简单的前端开发任务打下了基础 技术框架MUI VUE 个人开源项目rpc 框架 简介项目分为服务端和客户端两个模块，服务端在项目启动时将自己注册到 Nacos 服务中，客户端读取配置在 Nacos 中的配置后读取 Nacos 注册中心中服务端各个实例的访问地址和端口等配置信息，从而远程调用服务端的实例 解决问题了解 Dubbo，gRPC 底层通信原理，拥有独立开发 rpc 框架的能力 技术栈Nacos Netty 分布式序列ID 源码地址本体项目地址：https://github.com/wuhunyu/rpc.git demo项目地址：https://github.com/wuhunyu/rpc-demo.git 代码生成 简介这是一个在线代码生成器，核心使用 druid 框架和 freemarker 模板引擎。其中使用 druid 解析 MySQL 的 DDL 语句，使用 freemarker 生成模板，也就是在线解析 DDL 语句，并根据解析结果生成 Java 模板代码的一款 web 应用 解决问题通过 DDL 语句快速生成可用的 Java 后端模板代码 技术栈SpringBoot druid FreeMarker 源码地址https://github.com/wuhunyu/code-gen-by-ddl.git 演示地址https://wuhunyu.top/code-gen 证书软考中级软件设计师 云南省蓝桥杯C/C++程序设计大赛大学B组三等奖 英语(CET-4) 计算机等级考试四级-数据库工程师 个人总结擅长 Java 开发，对算法有浓厚兴趣，能够独立解决力扣简单，中等难度的算法题 乐于学习新技术，并应用到实际的开发中来 闲暇之余，有阅读源码的习惯 喜欢和同事讨论各种技术问题 致谢感谢您花时间阅读我的简历，期待能有机会和您共事","link":"/resume.html"}]}